<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[blogs]]></title>
  <link href="http://yuanchao.blogs.io/atom.xml" rel="self"/>
  <link href="http://yuanchao.blogs.io/"/>
  <updated>2022-10-12T10:23:39+08:00</updated>
  <id>http://yuanchao.blogs.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[部门测试服务更新重启步骤]]></title>
    <link href="http://yuanchao.blogs.io/16655391578542.html"/>
    <updated>2022-10-12T09:45:57+08:00</updated>
    <id>http://yuanchao.blogs.io/16655391578542.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E4%B8%80%E3%80%81tomcat%E6%9C%8D%E5%8A%A1">一、Tomcat服务</a>
<ul>
<li><a href="#1%E3%80%81%E5%A4%87%E4%BB%BD%E8%A6%81%E6%9B%B4%E6%96%B0%E7%9A%84jar%E5%8C%85">1、备份要更新的jar包</a></li>
<li><a href="#2%E3%80%81%E4%B8%8A%E4%BC%A0%E6%96%B0%E7%9A%84jar%E5%8C%85">2、上传新的jar包</a></li>
<li><a href="#3%E3%80%81%E6%9F%A5%E7%9C%8B%E5%B9%B6%E6%9D%80%E6%8E%89%E5%8E%9F%E6%9D%A5%E7%9A%84tomcat%E8%BF%9B%E7%A8%8B">3、查看并杀掉原来的tomcat进程</a></li>
<li><a href="#4%E3%80%81%E9%87%8D%E5%90%AF%E6%9C%8D%E5%8A%A1">4、重启服务</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1">二、微服务</a>
<ul>
<li><a href="#1%E3%80%81%E6%9F%A5%E6%89%BE%E5%B9%B6%E6%9D%80%E6%8E%89%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B">1、查找并杀掉微服务进程</a></li>
<li><a href="#2%E3%80%81%E4%B8%8A%E4%BC%A0%E6%96%B0%E7%9A%84jar%E5%8C%85">2、上传新的jar包</a></li>
<li><a href="#3%E3%80%81%E5%90%AF%E5%8A%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1">3、启动微服务</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E3%80%81nginx">三、Nginx</a>
<ul>
<li><a href="#1%E3%80%81%E8%BF%9B%E5%85%A5nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95">1、进入nginx配置文件目录</a></li>
<li><a href="#2%E3%80%81%E6%89%93%E5%BC%80default-conf%E6%96%87%E4%BB%B6">2、打开default.conf文件</a></li>
<li><a href="#3%E3%80%81%E6%9F%A5%E7%9C%8B%E5%85%B7%E4%BD%93%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E6%8C%89%E9%9C%80%E4%BF%AE%E6%94%B9">3、查看具体配置以及按需修改</a></li>
</ul>
</li>
</ul>
<h1><a id="%E4%B8%80%E3%80%81tomcat%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、Tomcat服务</h1>
<blockquote>
<p>非微服务，比如老渣土系统(construction_v2)。</p>
</blockquote>
<h2><a id="1%E3%80%81%E5%A4%87%E4%BB%BD%E8%A6%81%E6%9B%B4%E6%96%B0%E7%9A%84jar%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、备份要更新的jar包</h2>
<p><strong>cd /egova/web/eUrbanMIS/WEB-INF/lib</strong></p>
<p>在这个路径下重命名要更新的jar包，或者将它移出到别的目录，以达到备份的效果。</p>
<h2><a id="2%E3%80%81%E4%B8%8A%E4%BC%A0%E6%96%B0%E7%9A%84jar%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、上传新的jar包</h2>
<p>可以使用多种方式进行文件传输。比如使用xshell等客户端工具。</p>
<p>如果使用的mac系统，也可以直接使用如下命令：</p>
<p>scp -r /Users/yuanchao/Desktop/update/xxx.jar root@192.168.102.11:/egova/web/eUrbanMIS/WEB-INF/lib/xxx.jar</p>
<blockquote>
<p>备注：我使用上述命令上传jar包，发现存在一个权限的问题，默认新上传到服务器上的jar包是 rw------，即没有执行权限。所以还需要使用root用户修改一下权限，所以如果可以用xshell等工具，建议就用xshell传输文件。</p>
</blockquote>
<h2><a id="3%E3%80%81%E6%9F%A5%E7%9C%8B%E5%B9%B6%E6%9D%80%E6%8E%89%E5%8E%9F%E6%9D%A5%E7%9A%84tomcat%E8%BF%9B%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、查看并杀掉原来的tomcat进程</h2>
<p>查看进程：<strong>ps -ef|grep tomcat</strong></p>
<p>杀死进程：<strong>kill -9  pid</strong></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206301809719.png" alt="image-20220630180942467" /></p>
<p>找到对应的进程。部门服务器mis服务是8080端口，就是 apache-tomcat-8.5.70 这个。对比其它 tomcat ，明显别的带端口号命名【图中蓝色框部分】，所以可以定位我们要更新的的进程id是红色框的id【22507】。</p>
<h2><a id="4%E3%80%81%E9%87%8D%E5%90%AF%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4、重启服务</h2>
<p>目前我是直接进入对应 tomcat 的 bin 目录下执行 startup.sh 文件。</p>
<p><strong>cd /egova/apache-tomcat-8.5.70/bin</strong></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206301813055.png" alt="image-20220630181335639" /></p>
<p>启动服务：</p>
<p><strong>./startup.sh</strong></p>
<p>查看启动日志：</p>
<p><strong>tail -f ../logs/catalina.xxx(xxx表示当天日期).out</strong></p>
<blockquote>
<p>例如：tail -f ../logs/catalina.2022-06-30.out</p>
</blockquote>
<p>注意：启动过程中在执行changelog那一步会卡较长时间，一直到输出如下日志服务才算启动成功了！</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206301805733.png" alt="image-20220630180523097" /></p>
<h1><a id="%E4%BA%8C%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、微服务</h1>
<h2><a id="1%E3%80%81%E6%9F%A5%E6%89%BE%E5%B9%B6%E6%9D%80%E6%8E%89%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、查找并杀掉微服务进程</h2>
<p>查看进程：<strong>ps -ef|grep java</strong></p>
<p>以渣土微服务为例，对应的是 egova-boot-construction-service-1.0.0-SNAPSHOT.jar ，进程 ID如下所示，36127 就是对应的PID。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207012146603.png" alt="image-20220608152623524" /></p>
<p>杀死进程：<strong>kill -9 pid</strong></p>
<h2><a id="2%E3%80%81%E4%B8%8A%E4%BC%A0%E6%96%B0%E7%9A%84jar%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、上传新的jar包</h2>
<p>部门服务器，微服务部署目录为：/egova，以渣土微服务为例，对应的目录是：/egova/micro_construction</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207011823299.png" alt="image-20220701182310409" /></p>
<p>进入微服务目录，如下：</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207011825552.png" alt="image-20220701182523097" /></p>
<p>具体上传jar包的方式与更新普通tomcat服务一样，参考上面相关内容。</p>
<p>除此之外，还有2个重要的文件。</p>
<ul>
<li>
<p><strong>bootstrap.sh</strong>：启动微服务的脚本，里边包含一些配置项，可以覆盖项目的 application.yml 配置文件。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207011834786.png" alt="image-20220701183447210" /></p>
</li>
<li>
<p><strong>nohup.out</strong>：日志文件，启动微服务后，可以通过查看日志，看是否正常启动。</p>
</li>
</ul>
<h2><a id="3%E3%80%81%E5%90%AF%E5%8A%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、启动微服务</h2>
<p>启动命令：<strong>./bootstrap.sh</strong></p>
<p>查看日志：<strong>tail -f nohup.out</strong></p>
<h1><a id="%E4%B8%89%E3%80%81nginx" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、Nginx</h1>
<h2><a id="1%E3%80%81%E8%BF%9B%E5%85%A5nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、进入nginx配置文件目录</h2>
<p><strong>cd /etc/nginx</strong></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207012110213.png" alt="image-20220701184249093" /></p>
<h2><a id="2%E3%80%81%E6%89%93%E5%BC%80default-conf%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、打开default.conf文件</h2>
<p>default.conf 是服务器上nginx的的默认配置文件。</p>
<p>打开命令：<strong>vim default.conf  或 vi default.conf</strong></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207012112305.png" alt="image-20220701184315435" /></p>
<h2><a id="3%E3%80%81%E6%9F%A5%E7%9C%8B%E5%85%B7%E4%BD%93%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E6%8C%89%E9%9C%80%E4%BF%AE%E6%94%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、查看具体配置以及按需修改</h2>
<p>如下图所示，可以看到nginx转发的端口是 8080，我们平时访问的 <a href="http://192.168.102.11:8080/eUrbanMIS%EF%BC%8C%E4%B8%AD%E7%9A%848080%E7%AB%AF%E5%8F%A3%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E6%9D%A5%E7%9A%84%E3%80%82%E5%8F%A6%E5%A4%96%E8%BF%98%E6%9C%89%E5%85%B6%E5%AE%83%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%85%8D%E7%BD%AE%EF%BC%8C%E6%AF%94%E5%A6%82%E6%B8%A3%E5%9C%9F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%9A">http://192.168.102.11:8080/eUrbanMIS，中的8080端口就是这么来的。另外还有其它的一系列配置，比如渣土微服务的配置：</a></p>
<pre><code class="language-properties">location /microconstruction{

​	proxy_pass  http://192.168.102.11:8086/construction/;

}
</code></pre>
<p>表示拦截 /microconstruction 开头的请求，转发到实际的渣土微服务 8086 端口。</p>
<p>前端开发需要同时使用mis服务和微服务时，在 vue.config.js 中配置代理，都是统一配的8080，这样确保不会发生跨域错误，nginx则帮我们获取正确的后台返回结果。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207012116540.png" alt="image-20220701184357454" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207012116645.png" alt="image-20220701184431057" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208312035145.png" alt="image-20220831203458702" /></p>
<p>彩蛋：贴一张我最喜欢的理解正向代理和反向代理的图。</p>
<p>上面讲到的这种转发请求的模式，其实就是nginx的重要功能之一——反向代理。正向代理相信大伙都懂，威阳同学经常科学上网，用到的工具就是正向代理。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207012125806.png" alt="image-20220701212445782" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试上传图片]]></title>
    <link href="http://yuanchao.blogs.io/16655315320403.html"/>
    <updated>2022-10-12T07:38:52+08:00</updated>
    <id>http://yuanchao.blogs.io/16655315320403.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E6%8F%92%E5%85%A5%E6%96%87%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第一节：插入文本</h2>
<p>a：当前字符的后一个位置插入</p>
<p>i：当前字符的前一个位置插入</p>
<p>o：当前编辑位置下面新起一行</p>
<p>A：在行最后位置插入</p>
<p>I：  在行最前的位置插入</p>
<p>O：在当前编辑位置的上面新起一行</p>
<p>w：保存</p>
<p>wq：保存并退出(w and q)</p>
<h2><a id="%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9Avim%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第二节：Vim模式</h2>
<p>进入vim默认是normal模式</p>
<p>还有 : cmd命令模式 和 v(visual)可视化模式</p>
<p>命令模式：</p>
<p>保存  :w</p>
<p>退出  :q</p>
<p>保存并退出   :wq</p>
<p>纵向分屏  :vs</p>
<p>横向分屏  :sp</p>
<p>全局替换   :% s/foo/bar/g      （foo被替换的，bar替换后的）</p>
<p>设置显示行号  :set nu</p>
<p>Visual模式：</p>
<p>normal模式下使用 v 进入 visual 模式选择</p>
<p>使用 V 选择行</p>
<p>使用 ctrl+v 进行块状选择</p>
<h2><a id="%E7%AC%AC%E4%B8%89%E8%8A%82%EF%BC%9A%E5%BF%AB%E6%8D%B7%E5%88%A0%E9%99%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第三节：快捷删除</h2>
<h3><a id="%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%BF%AB%E9%80%9F%E7%BA%A0%E9%94%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>输入模式下快速纠错</h3>
<p>ctrl+h 删除上一个字符</p>
<p>ctrl+w 删除上一个单词</p>
<p>ctrl+u 删除当前行</p>
<p>ctrl+a (终端) 快速移动到开头</p>
<p>ctrl+e (终端)快速移动到结尾</p>
<p>ctrl+f (终端)光标后移</p>
<p>ctrl+b (终端)光标迁移</p>
<h3><a id="%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2insert%E5%92%8Cnormal%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快速切换insert和normal模式</h3>
<p>insert -&gt; normal: ctrl+c 或者 ctrl+[</p>
<p>gi: normal 模式切换到 insert 模式，且到上次编辑的地方</p>
<h2><a id="%E7%AC%AC%E5%9B%9B%E8%8A%82%EF%BC%9A%E5%BF%AB%E6%8D%B7%E7%A7%BB%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第四节：快捷移动</h2>
<h3><a id="normal%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>normal 移动的快捷方式</h3>
<p>w/W: 移动到下一个word/WORD 开头</p>
<p>e/E: 移动到下一个 word/WORD 结尾</p>
<p>b/B: 移动到上一个 word/WORD 开头  (backword)</p>
<h3><a id="%E8%A1%8C%E9%97%B4%E6%90%9C%E7%B4%A2%E7%A7%BB%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>行间搜索移动</h3>
<p>f{char}: 当前光标往行后搜索字符, 分号(;)下一个找到的字符，逗号(,)上一个找到的字符</p>
<p>F{char}: 当前光标往前搜索字符</p>
<p>0: 移动到行首第一个字符</p>
<p>^: 移动到第一个非空白字符</p>
<p>$: 移动到行尾</p>
<p>g_: 移动到行尾非空白字符</p>
<h3><a id="%E9%A1%B5%E9%9D%A2%E7%A7%BB%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>页面移动</h3>
<p>gg: 文件开头</p>
<p>G: 文件结尾</p>
<p>H: 屏幕的开头(Head)</p>
<p>M: 屏幕的中间(Middle)</p>
<p>L: 屏幕的结尾(Lower)</p>
<p>crtl+u: 上翻页（upword）</p>
<p>ctrl+f: 下翻页（forword）</p>
<p>zz: 屏幕置为中间</p>
<h2><a id="%E7%AC%AC%E4%BA%94%E8%8A%82%EF%BC%9A%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第五节：增删改查</h2>
<h3><a id="%E5%A2%9E%E5%8A%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>增加</h3>
<p>Normal模式 a/i/o A/I/O</p>
<h3><a id="%E5%88%A0%E9%99%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>删除</h3>
<p>Normal模式</p>
<p>x 删除一个字符</p>
<p>4x 删除4个字符</p>
<p>d(delete)</p>
<p>daw 删除单词和周围空格（delete around word）</p>
<p>diw 删除单词（dw）</p>
<p>dd 删除行</p>
<p>dt{char} 删除直到</p>
<p>d$ 删除到结尾</p>
<p>d0 删除到开头</p>
<p>2dd 删除两行</p>
<p>R 不断替换多个字符</p>
<p>S 删除整行进行插入</p>
<p>C 删除整行进行插入</p>
<h3><a id="%E4%BF%AE%E6%94%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>修改</h3>
<p>Normal模式下</p>
<p>r replace 替换一个字符</p>
<p>c change</p>
<p>cw 删除单词进入插入模式 change word</p>
<p>ct{char} 删除到字符，进入插入模式</p>
<p>s substitute 删除并进入插入模式 eg: 4s 删除4个字符进入插入模式</p>
<h3><a id="%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查询</h3>
<p>/ 前向搜索</p>
<p>? 反向搜索</p>
<p>n/N 下一个或者上一个</p>
<p>\		*/# 当前单词的前向和后向匹配</p>
<p>搜索结果高亮 :set hls (high light search)</p>
<p>:set incsearch</p>
<h2><a id="%E7%AC%AC%E5%85%AD%E8%8A%82%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%9B%BF%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第六节：快速替换</h2>
<h3><a id="%E6%9B%BF%E6%8D%A2%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>替换命令</h3>
<p><strong>:[range] s[ubstitute]/{pattern}/{string}/[flags]</strong></p>
<p><strong>range表示范围：</strong><br />
10, 20 表示10-20行<br />
% 表示全部<br />
pattern是要替换的模式<br />
string是替换后文本<br />
<strong>Flags：</strong></p>
<p>​	g(global) 表示全局范围内执行<br />
​	c(confirm)表示确认，可以确认或者拒绝修改<br />
​	n(number)报告匹配到的次数而不替换，可以用来查询匹配次数</p>
<h3><a id="%E7%B2%BE%E7%A1%AE%E6%9B%BF%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>精确替换</h3>
<pre><code class="language-plain_text">//将quack替换为jiao
:% s/\&lt;quack\&gt;/jiao/g

//只统计quack出现的次数不执行替换
:% s/quack//n
</code></pre>
<h3><a id="%E9%80%80%E5%87%BA%E6%90%9C%E7%B4%A2%E9%AB%98%E4%BA%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>退出搜索高亮</h3>
<pre><code class="language-plain_text">:noh
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/12/16655317167631.jpg" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MouseValidate表单验证库扩展与优化]]></title>
    <link href="http://yuanchao.blogs.io/16619493954842.html"/>
    <updated>2022-08-31T20:36:35+08:00</updated>
    <id>http://yuanchao.blogs.io/16619493954842.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">基本使用</a></li>
<li><a href="#%E7%BC%BA%E9%99%B7">缺陷</a></li>
<li><a href="#%E4%BC%98%E5%8C%96%E4%B8%8E%E6%89%A9%E5%B1%95">优化与扩展</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C">使用自定义校验</a></li>
<li><a href="#%E5%90%8E%E7%BB%AD">后续</a>
<ul>
<li><a href="#%E5%A2%9E%E5%8A%A0%E6%96%87%E6%9C%AC%E9%95%BF%E5%BA%A6%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99">增加文本长度校验规则</a>
<ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5">核心代码片段</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">使用方法</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h1>
<p>写这篇文档主要是为了渣土系统这样的KO(即Knockout)老项目，这里边使用的非常多。mouseValidate这个库确实没怎么听过，以至于我想找一下官方文档都搜不到，只能由我自己简单的定义一下了。mouseValidate是一个基于jquery的表单验证库，目前公司项目中除了KO老项目中普遍使用，其它系统基本没有用到，不过这并不妨碍我们学习它的设计思想，以及根据我们自己的需求对它进行定制修改。</p>
<h1><a id="%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本使用</h1>
<ul>
<li>第一步引进来，例如：</li>
</ul>
<pre><code class="language-js">  define([&quot;jquery&quot;, &quot;durandal/app&quot;, &quot;durandal/composition&quot;, &quot;knockout&quot;, &quot;mouseValidate&quot;],
      function ($, app, composition, ko, mouseValidate) {
          function viewModal() {
            
          }
     			return viewModal;
			});
</code></pre>
<ul>
<li>
<p>第二步初始化验证</p>
<blockquote>
<p>实际上就是定义一些规则，非空啊，手机号码啊，身份证号码之类的。这里只摘录核心代码片段，具体实例可以到渣土系统中找，例子非常多。另外，注意这个initValidate方法一般页面加载完毕就先调用一遍，这样被添加规则的表单字段就能做出响应了。</p>
</blockquote>
</li>
</ul>
<pre><code class="language-js">//添加规则 
model.initValidate = function () {
    mouseValidate.clearValidate();
    mouseValidate.initValidate($(_dom).find(&quot;#businessLicenseNumber&quot;), {&quot;isEmpty&quot;: &quot;请输入工商营业执照编号&quot;});
    mouseValidate.initValidate($(_dom).find(&quot;#registerMoney&quot;), {&quot;isEmpty&quot;: &quot;请输入注册资金&quot;,&quot;isNumber&quot;:&quot;请输入正确数值&quot;});
    mouseValidate.initValidate($(_dom).find(&quot;#legalRepresentative&quot;), {&quot;isEmpty&quot;: &quot;请输入企业法人&quot;});
    mouseValidate.initValidate($(_dom).find(&quot;#legalRepresentativeContact&quot;), {&quot;isEmpty&quot;: &quot;请输入企业法人联系方式&quot;,&quot;isAllPhone&quot;:&quot;&quot;});
    mouseValidate.initValidate($(_dom).find(&quot;#legalRepresentativeNumber&quot;), {&quot;isEmpty&quot;: &quot;请输入企业法人身份证号码&quot;});
};

//提交表单时校验
model.submit = function(){
  //注意returnFlag并不是boolean类型，而是&quot;true&quot;或&quot;false&quot;
   var returnFlag = MouseValidate.returnValidate();
   if (returnFlag === &quot;false&quot;) {
       commonUtil.showTip(_dom, &quot;error&quot;, &quot;完成提示与必填项！&quot;, &quot;company-tip&quot;);
       return false;
    }
};
</code></pre>
<ul>
<li>
<p>效果展示</p>
<p>调用MouseValidate.returnValidate()，校验的是整个表单。校验不通过的表单项显示红色边框。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202203311841421.png" alt="img" /></p>
<p>单击某个表单项让它获得焦点，然后再失去焦点，会单独对这个表单项进行校验。校验不通过，会显示相应提示信息。</p>
</li>
</ul>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202203311842519.png" alt="img" /></p>
<h1><a id="%E7%BC%BA%E9%99%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>缺陷</h1>
<ol>
<li>
<p>不支持自定义校验规则，比如：校验车牌号。</p>
</li>
<li>
<p>disabled或readonly的表单项，不能触发校验，这是因为这两种情况下，没办法走如下流程：获取焦点——手动输入或选择——失去焦点的操作方式，所以不能触发校验。为了便于大家理解，这里截取一个这样的场景。下面3个字段，都是通过点击按钮，在弹框界面选择某项，然后带回来赋值给右边的input框。因为是选择方式，不支持手动输入，故这几个input框全部都是readonly状态。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202203311843759.png" alt="img" /></p>
<p>下面选取具体的值后，发现Input框仍然是红色边框<img src="https://gitee.com/Allen_2017/picrepo/raw/master/youdaoyun/202203201913982.png" alt="image-20220320191338606" /></p>
</li>
</ol>
<h1><a id="%E4%BC%98%E5%8C%96%E4%B8%8E%E6%89%A9%E5%B1%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优化与扩展</h1>
<ul>
<li>
<p>本次优化与扩展的目的</p>
<p>针对上面2个缺陷，本次改造mouseValidate库希望达到2个目的。</p>
<ol>
<li>
<p>支持自定义校验规则，这一点非常重要。</p>
</li>
<li>
<p>readonly、disabled 字段值发生变化后，触发校验规则。</p>
</li>
</ol>
</li>
<li>
<p>mouseValidate库源码概览</p>
<p>其实结构非常简单，原来的代码主要由如下几部分构成：2个容器、初始化规则收集函数、表单提交校验函数、清除规则函数、一堆内置校验规则，本次扩展新增了一个customKeys和customFlag，以及增加了一个供外部注册规则的 registerValidate 方法，它们专门用于处理自定义校验规则。这些内容里比较重要的就是initValidate和returnValidate。</p>
</li>
</ul>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202203311844030.png" alt="image-20220320192006482" /></p>
<ul>
<li>
<p><strong>initValidate</strong></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202203311844096.png" alt="image-20220320193718886" /></p>
</li>
</ul>
<p>initValidate方法中，我并不打算详细解读focus、blur等方法，有兴趣的自己去研读。我主要讲一下自己加的一段处理readonly和disabled的逻辑。因为readonly(或disabled)表单项可以通过选择方式或其它非手动输入方式得到值，所以这里只能监听一下它的change事件，其实说穿了很简单，就是当它的值发生变化时，简单校验一下，如果为空就给它来个红色边框，反之就正常边框。</p>
<pre><code class="language-js">//readonly和disabled的元素增加一个change事件，同时还需在代码中还需要手动触发一下change事件，
// 这是因为readonly和disabled会导致默认的change失效，$(_dom).find(&quot;#fenceNames&quot;).trigger(&quot;change&quot;);
if ($(node).attr(&quot;readonly&quot;) === &quot;readonly&quot; || $(node).attr(&quot;disabled&quot;) === &quot;disabled&quot;) {
   $(node).change(function (evt) {
      var value = $(node).val();
      if (value || value === 0) {
         $(node).css(&quot;border&quot;, &quot;1px solid #B7C7CD&quot;);
      } else {
         $(node).css(&quot;border&quot;, &quot;1px solid red&quot;);
      }
   });
}
</code></pre>
<p>但是，这里有一个非常重要的细节，readonly或disabled后，change事件需要手动显示触发**$(_dom).find(&quot;xxx&quot;).trigger(&quot;change&quot;)**。这个地方我一直没有想到更好的办法，只能在当前表单项拿到值后，手动触发一下了。就像下面这样：</p>
<pre><code class="language-js">function initEvents() {
    app.off('app:construction:choose:fences');
    app.on('app:construction:choose:fences').then(function (data) {
        self._selectedFences = data;
        if (self._selectedFences &amp;&amp; self._selectedFences.length) {
            var fenceNames = commonUtil.getMappingFields(self._selectedFences, &quot;fenceName&quot;, &quot;,&quot;);
            self.fenceNames(fenceNames);
          
            //触发一下change事件配合mouseValidate库
            $(_dom).find(&quot;#fenceNames&quot;).trigger(&quot;change&quot;);
        }
    });
}
</code></pre>
<ul>
<li>
<p><strong>returnValidate</strong></p>
<p>returnValidate方法用于提交表单时，统一校验所有添加了规则的表单项。使用方法类似于：</p>
<pre><code class="language-js">//提交表单时校验
model.submit = function(){
  //注意returnFlag并不是boolean类型，而是&quot;true&quot;或&quot;false&quot;
   var returnFlag = MouseValidate.returnValidate();
   if (returnFlag === &quot;false&quot;) {
       commonUtil.showTip(_dom, &quot;error&quot;, &quot;完成提示与必填项！&quot;, &quot;company-tip&quot;);
       return false;
    }
};
</code></pre>
<p>那么它里边具体是怎么做的呢？</p>
<ol>
<li>校验isEmpty规则，将所以不通过的表单节点，放入到flag容器中；</li>
<li>校验自定义规则，将所有不通过的表单节点，放入到flag容器中（这个是我新加的逻辑）；</li>
<li>统一处理flag容器中的节点，依次添加红色边框，以表示哪些没有通过校验。</li>
</ol>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202203311845316.png" alt="image-20220320200007749" /></p>
</li>
</ul>
<p>下面主要讲一下我自己添加的逻辑。这里要结合前面的inValidate方法来看。故这里重新再贴一遍截图。我们首先要搞清楚customFlag里到底存储的是什么。customFlag.set(node, key) 中的node很好理解，key实际上就是 isVehicleNum、isTaskNum 这样的规则函数！所以customFlag里实际上是类似这样的结构：[ {node: isVehicleNum}, {node: isTaskNum} ] 这样的键值对。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202203311845902.png" alt="image-20220320201100060" /></p>
<p>了解了上面这些，然后如果对eval变态函数有些了解，下面这段逻辑就基本能看明白了。eval的神奇在这里表现得淋漓尽致了，能够将字符串拼接成的函数调用执行起来，并且拿到调用后的结果！当然前提是你这个method首先必须得存在，所以下面接着必须讲一下 registerValidate方法的作用了。</p>
<pre><code class="language-js">//处理自定义的校验
customFlag.forEach(function (method, node) {
   var value = $(node).val();
   var res = eval(method+&quot;('&quot;+value+&quot;')&quot;);
   if (res.success) {
      if (flag.get(node) === &quot;false&quot;) {
         flag.set(node, &quot;true&quot;);
      }
   } else {
      flag.set(node, &quot;false&quot;);
   }
});
</code></pre>
<ul>
<li>
<p><strong>registerValidate</strong></p>
<p>这个方法比较简单，这里就不多说了，主要目的就是向customKeys数组中添加元素(自定义规则函数名称)。同时，添加进去的规则，务必要有对应的校验函数。后面会举一个添加车牌号校验规则的实例，这个例子也是实际开发中遇到的需求，比较有代表性。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202203311845628.png" alt="image-20220320202515832" /></p>
</li>
</ul>
<h1><a id="%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用自定义校验</h1>
<ol>
<li>
<p>注册自定义规则，并给表单项添加该规则</p>
<pre><code class="language-js">model.initValidate = function () {
    //注册自定义规则isVehicleNum
    mouseValidate.registerValidate(&quot;isVehicleNum&quot;);
    mouseValidate.clearValidate();
    //给表单项添加规则，这里包含2个规则，isEmpty、isVehicleNum，多个规则是可以一起使用的
    mouseValidate.initValidate($(model._constrain).find(&quot;#vehicleNum&quot;), {&quot;isEmpty&quot;: &quot;请输入车牌号&quot;, &quot;isVehicleNum&quot;: &quot;请输入正确的车牌号码&quot;});
}
</code></pre>
</li>
<li>
<p>在mouseValidate文件中定义规则函数</p>
<blockquote>
<p>注意规则校验函数的返回值结构，务必保持一致！</p>
</blockquote>
<pre><code class="language-js">/*
 * 车牌号验证(这里只简单校验一下前缀和长度)
 * @param {string}
 */
function isVehicleNum(val) {
   //校验前缀
   var prefix = eUrban.global.LICENSE_PLATE_NUMBER || &quot;&quot;;
   if (prefix &amp;&amp; val.indexOf(prefix) !== 0) {
      return {success: false, message: '车牌号前缀不正确！'};
   }
   //校验长度,车牌号码长度目前是7、8位数
   if (val.length &lt; 7 || val.length &gt; 8) {
      return {success: false, message: '车牌号长度不正确！'};
   }
   return {success: true};
}
</code></pre>
</li>
<li>
<p>校验效果</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202203311846225.png" alt="img" /></p>
</li>
</ol>
<h1><a id="%E5%90%8E%E7%BB%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>后续</h1>
<h2><a id="%E5%A2%9E%E5%8A%A0%E6%96%87%E6%9C%AC%E9%95%BF%E5%BA%A6%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>增加文本长度校验规则</h2>
<h3><a id="%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>核心代码片段</h3>
<pre><code class="language-js">/**
	 * 校验文本长度
	 * @param val
	 * @returns {{success: boolean, message: string}|{success: boolean}}
	 */
	function checkLen(val) {
		if (!window._checkNode) {
			return {success: true};
		}
		var min = $(window._checkNode).attr(&quot;minlen&quot;);
		var max = $(window._checkNode).attr(&quot;maxLen&quot;);
		min = min &amp;&amp; !isNaN(min) ? Number(min) : 0;
		max = max &amp;&amp; !isNaN(max) ? Number(max) : 0;
		var len = val.length;
		if (len &lt; min) {
			return {success: false, message: '文本长度不得小于' + min};
		}
		if (len &gt; max) {
			return {success: false, message: '文本长度不得大于' + max};
		}
		return {success: true};
	}

//returnValidate、blur等代码中增加window._checkNode赋值。
customFlag.forEach(function (method, node) {
  window._checkNode = node; //增加它，用于在校验函数中获取边界
  var value = $(node).val();
  var res = eval(method+&quot;('&quot;+value+&quot;')&quot;);
  if (res.success) {
    if (flag.get(node) === &quot;false&quot;) {
      flag.set(node, &quot;true&quot;);
    }
  } else {
    flag.set(node, &quot;false&quot;);
  }
});
</code></pre>
<h3><a id="%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用方法</h3>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202203311850517.png" alt="image-20220331185015321" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202203311851235.png" alt="image-20220331185109074" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202203311851346.png" alt="image-20220331185130070" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202203311851672.png" alt="image-20220331185144487" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运管服子系统签名鉴权总结]]></title>
    <link href="http://yuanchao.blogs.io/16619488841255.html"/>
    <updated>2022-08-31T20:28:04+08:00</updated>
    <id>http://yuanchao.blogs.io/16619488841255.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E9%9C%80%E6%B1%82%E8%83%8C%E6%99%AF">需求背景</a></li>
<li><a href="#%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99">校验规则</a></li>
<li><a href="#%E6%94%B9%E9%80%A0%E7%82%B9">改造点</a></li>
<li><a href="#%E5%B0%81%E8%A3%85%E5%B7%A5%E5%85%B7%E7%B1%BB">封装工具类</a>
<ul>
<li><a href="#signatureforjquery">signatureForJquery</a></li>
<li><a href="#signatureforaxios">signatureForAxios</a></li>
<li><a href="#signatureforurl">signatureForUrl</a></li>
<li><a href="#window-open%E6%89%B9%E5%A4%84%E7%90%86">window.open批处理</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%B8%BE%E4%BE%8B">使用及举例</a>
<ul>
<li><a href="#axios-fetch%E7%B1%BB%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86">axios(fetch)类网络请求处理</a></li>
<li><a href="#window-open%E7%9A%84%E5%A4%84%E7%90%86">window.open的处理</a></li>
<li><a href="#window-location-href%E5%A4%84%E7%90%86">window.location.href处理</a></li>
<li><a href="#iframe%E5%8F%8A%E4%B8%AD%E7%9A%84src%E5%A4%84%E7%90%86">iframe及中的src处理</a></li>
<li><a href="#a%E6%A0%87%E7%AD%BEhref%E9%93%BE%E6%8E%A5%E7%9A%84%E5%A4%84%E7%90%86">a标签href链接的处理</a></li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%EF%BC%9F">如何验证？</a>
<ul>
<li><a href="#%E6%88%90%E5%8A%9F%E6%A1%88%E4%BE%8B">成功案例</a></li>
<li><a href="#%E5%A4%B1%E8%B4%A5%E6%A1%88%E4%BE%8B">失败案例</a></li>
</ul>
</li>
<li><a href="#%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">开发注意事项</a></li>
<li><a href="#%E5%89%A9%E4%BD%99%E5%B7%A5%E4%BD%9C">剩余工作</a></li>
</ul>
<h2><a id="%E9%9C%80%E6%B1%82%E8%83%8C%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求背景</h2>
<p>接口签名验证是公司从去年底就开始推行的事情，在我看来主要有两个目的，一是应对第三方测评机构和业主方的需求，二是它确确实实能够降低一些网络安全风险，为我们系统的稳定性提供一份保障。因此，尽管过去的一周为了做好签名鉴权这件事，耗费了我大量的精力和脑细胞，但是我还是想尽量做到位，同时也能够学习一些新东西。</p>
<h2><a id="%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>校验规则</h2>
<p>公司各系统签名鉴权详细规则请参考<a href="https://alidocs.dingtalk.com/i/team/9JOGOlqDaEMJz4QL/docs/9JOGOj4ynpd4em4Q?iframeQuery=">此文档</a>。简单来说，就是要在我们发出的每个请求上都额外附加3个签名鉴权参数，nonce、timestamp、signature，其中nonce和timestamp的生成相对简单和固定，signature则复杂的多，有一套专门的计算方法。前端将这3个参数传送到后台，后台据此解析和验证，从而可以避免一些url的篡改、伪造等攻击。</p>
<h2><a id="%E6%94%B9%E9%80%A0%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>改造点</h2>
<p>由于我们是先有成型的项目，然后再做这个事情，因此需要改造的地方还是比较多的。并且我们也不可能挨个在发送请求的地方插入签名鉴权的逻辑，否则工作量将大到无法估量。因此最好的办法还是要封装一个工具类，然后在所有请求都必须经过的地方植入这段逻辑。在做这个工作之前，我们首先需要总结分类，搞清楚到底有哪些地方需要进行处理。</p>
<ul>
<li>普通请求。包括常见的get、post、put、delete，以及部分项目中还会用到$.ajax()请求。</li>
<li>文件下载。包括<a href=""></a>这类链接形式的下载。</li>
<li>window.open和window.location.href等。</li>
<li>iframe等</li>
</ul>
<h2><a id="%E5%B0%81%E8%A3%85%E5%B7%A5%E5%85%B7%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>封装工具类</h2>
<p>运管服前端子系统使用的网络框架主要有以下几类：\(.ajax 【以渣土系统等老KO项目为主】，axios库【以react等新项目为主】，fetch【户外广告、门前三包等】。其中\).ajax算一个大类，axios和fetch大同小异，可以归为一个大类，最后再加上诸如window.open这类直接通过url发送请求算作一类，总共可以划分3个大类。因此，我们的工具类至少需要对外暴露3个API。即：signatureForJquery、signatureForAxios、signatureForUrl。这里我们不展开讨论工具类的每一个细节，大家可以直接去查看项目中的源码。这里只贴一个核心代码片段，让大家感受一些生成签名参数的流程。</p>
<h3><a id="signatureforjquery" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>signatureForJquery</h3>
<pre><code class="language-js">export const signatureForJquery = function ($) {
    let _ajax = $.ajax;
    $.ajax = function (options) {
        let isJson = isApplicationJson(options, 'jquery');
        let isFormdata = isFormData(options);
        let url = options.url;

        // 1.获取url参数
        const urlParams = getUrlParam(url);
        if (urlParams.signature) {
            delete urlParams.signature
        }

        // 2.初始化签名鉴权参数
        let option = initOptions();
        let signatureOption = Object.assign({}, urlParams, option);
        if (options.data &amp;&amp; !isJson &amp;&amp; !isFormdata) {
            signatureOption = Object.assign(signatureOption, options.data);
        }
        if (options.dataType === 'jsonp') {
            signatureOption.callback = options.jsonpCallback
        }

        // 3.排序
        let paramStr = sortOption(signatureOption);
        // application/json 请求需要签名 body 的 json(JSON.stringify()后的字符串)
        if (isJson) {
            paramStr = paramStr + encode(typeof options.data === 'object'? JSON.stringify(options.data): options.data);
        }

        // 4.获取 uri
        let uri = generateUri(url);

        // 5.拼接 uri 和 params
        paramStr = uri + &quot;?&quot; + paramStr;

        // 6.加密(执行完这一步option中包含完整的签名鉴权3个参数)
        option.signature = cryptoHash(paramStr);

        // 7.原来的urlParams和签名鉴权的option一起做到url上，防止有application/json情况
        options.url = buildUrl(url, Object.assign({}, urlParams, option));

        //8.调用原生的$.ajax方法
        _ajax(options);
    };
}
</code></pre>
<h3><a id="signatureforaxios" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>signatureForAxios</h3>
<pre><code class="language-js">export const signatureForAxios = function (url, params = {}, config = {}) {
    let isJson = isApplicationJson(config);
    let isMedia = isFormData(config);

    // 1.获取url参数
    const urlParams = getUrlParam(url);

    // 2.初始化签名鉴权参数
    let option = initOptions();

    //3.合并签名鉴权参数
    let signatureOption = mergeOptions(urlParams, params, option, config);

    // 3.排序
    let paramStr = sortOption(signatureOption);

    // 4.获取uri
    let uri = generateUri(url);

    // 5.组装uri和params
    if (isJson) {
        paramStr = uri + &quot;?&quot; + paramStr + encode(typeof params === 'string' ? params : JSON.stringify(params));
    }else {
        paramStr = uri + &quot;?&quot; + paramStr;
    }

    // 6.加密
    signatureOption.signature = cryptoHash(paramStr);

    // 7.获取纯净的url
    url = getPureUrl(url);

    //8.返回新的url和params
    if (isJson || isMedia) {
        //json和media类型签名鉴权参数拼接到url上，此signatureOption中只包含urlParams和签名3参数
        url = buildUrl(url, signatureOption);
        return {url, params};
    } else {
        return {url: url, params: signatureOption};
    }
}
</code></pre>
<h3><a id="signatureforurl" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>signatureForUrl</h3>
<pre><code class="language-js">export const signatureForUrl = function (url) {
    // 1.获取url参数
    const urlParams = getUrlParam(url);

    // 2.生成 option (不含signature)
    let option = initOptions();
    let signatureOption = Object.assign({}, urlParams, option);

    // 3.排序
    let paramStr = sortOption(signatureOption);

    // 4.获取 uri
    let uri = generateUri(url);

    // 5.拼接 uri 和 params
    paramStr = uri + &quot;?&quot; + paramStr;

    // 6.加密
    signatureOption.signature = cryptoHash(paramStr);

    // 7.拼接加密参数
    url = buildUrl(url, signatureOption);

    return url;
}
</code></pre>
<h3><a id="window-open%E6%89%B9%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>window.open批处理</h3>
<p>本来打算全局搜索window.open(url)的代码，然后对括号中的url参数，调用signature工具类中的signatureForUrl进行签名处理，后来发现这样的地方实在有些多，故产生了改写原生的window.open方法的想法，即表面上看原来的代码原封不动，但实际上已经被我偷梁换柱了。不过考虑到这个改动比较大，将来说不定还是要用到原生的方法，所以我还是保留了对原来逻辑的支持----在参数列表末尾中多传递一个true，就表示要使用原生的window.open()。</p>
<pre><code class="language-js">/**
 * 重写原生的window.open方法，但兼顾了原来的逻辑，如果要使用原来的window.open,只需要在参数列表末尾加一个true即可
 * 例如：window.open(url, true)、window.open(url, target, true)、window.open(url, target, features, true).
 * @param url 与原来的window.open参数相同
 * @param target 与原来的window.open参数相同(_blank、_parent、_self、_top、name等)
 * @param features 与原来的window.open参数相同 参考: https://www.runoob.com/jsref/met-win-open.html
 * @param original 布尔类型，true-使用原来的逻辑，即不参与签名鉴权，反之则参与
 */
const winOpen = window.open;
window.open = function (url, target, features, original) {
    const len = arguments.length;
    if (len &gt;= 2 &amp;&amp; arguments[len - 1] === true) {
        let args = [];
        for (let i = 0; i &lt; arguments.length - 1; i++) {
            args.push(arguments[i]);
        }
        winOpen.apply(this, args);
    } else {
        url = signatureForUrl(url);
        winOpen(url, target, features);
    }
}
</code></pre>
<h2><a id="%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%B8%BE%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用及举例</h2>
<h3><a id="axios-fetch%E7%B1%BB%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>axios(fetch)类网络请求处理</h3>
<pre><code class="language-js">import {signatureForAxios, TYPE_JSON, TYPE_MEDIA} from '@/utils/signature';

//GET请求
const get = (url, params = {}, config = {}) =&gt; {
    //执行签名鉴权逻辑
    const signature = signatureForAxios(url, params);
    url = signature.url;
    params = signature.params;
    return axios.get(url, { params, baseURL: url.includes('http') ? '' : baseURL, ...config }).then(res =&gt; {
        if (res &amp;&amp; res.data) {
            if (res.data.data) {
                return res.data.data;
            }
            return res.data;
        }
        return res;
    });
};

//POST请求
const post = (url, params, config) =&gt; {
  //执行签名鉴权逻辑
  const signature = signatureForAxios(url, params);
  url = signature.url;
  params = signature.params;
  return axios.post(url, qs.stringify(params), config).then(res =&gt; {
    if (res &amp;&amp; res.data) {
      return res.data.resultInfo;
    }
    return res;
  });
};

//Content-Type为application/json的POST请求
const postJson = (url, params, config) =&gt; {
  //执行签名鉴权逻辑
  const signature = signatureForAxios(url, params, {type: TYPE_JSON});
  url = signature.url;
  params = signature.params;
  return axios.post(url, params, config).then(res =&gt; {
    if (res &amp;&amp; res.data) {
      return res.data.resultInfo;
    }
    return res;
  });
};

//Content-Type为multipart/formdata的POST请求
const upLoad = (url, formData) =&gt; {
  //执行签名鉴权逻辑
  const signature = signatureForAxios(url, formData, {type: TYPE_MEDIA});
  url = signature.url;
  formData = signature.params;
  return axios.post(url, formData).then(res =&gt; {
    if (res &amp;&amp; res.data &amp;&amp; res.data.data) {
      return res.data.data;
    } else if (res &amp;&amp; res.data &amp;&amp; res.data.resultInfo) {
      return res.data.resultInfo;
    }
    return res;
  });
};
</code></pre>
<h3><a id="window-open%E7%9A%84%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>window.open的处理</h3>
<p>由于之前在signature工具类中已经改写了原生的window.open，所以项目中实际上调用的是我自己的window.open方法，在真正打开目标页面之前，我拦截并处理了它的url，所以实际上就已经携带了签名3参数，故不需要额外再处理。</p>
<h3><a id="window-location-href%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>window.location.href处理</h3>
<p>window.location.href实际上和window.open(url, '_self')的效果是等同的，因此可以将它修改为window.open(url, '_self')。这样就可以沿用window.open的批处理逻辑。当然也可以导入工具类中的signatureForUrl，然后调用这个方法先处理一下url。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208312030214.png" alt="202203262217718" /></p>
<h3><a id="iframe%E5%8F%8A%E4%B8%AD%E7%9A%84src%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>iframe及中的src处理</h3>
<p>这类请求没有任何捷径，只能挨个处理。但是好在项目中使用的场景一般不多，所以工作量不算大。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208312031662.png" alt="202203262219604" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208312031131.png" alt="202203262219881" /></p>
<h3><a id="a%E6%A0%87%E7%AD%BEhref%E9%93%BE%E6%8E%A5%E7%9A%84%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>a标签href链接的处理</h3>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208312032321.png" alt="202203262220499" /></p>
<h2><a id="%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何验证？</h2>
<p>需要注意的是，携带了签名鉴权的3个参数，不代表签名就一定成功了。目前，由于签名鉴权的功能还不是很稳定，各个部门都还在测试完善阶段，因此现在签名失败对调用接口还没有什么影响，但是我们可以通过response headers查看签名是否成功。</p>
<h3><a id="%E6%88%90%E5%8A%9F%E6%A1%88%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成功案例</h3>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208312032674.png" alt="202203262235638" /></p>
<h3><a id="%E5%A4%B1%E8%B4%A5%E6%A1%88%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>失败案例</h3>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208312032353.png" alt="202203262315863" /></p>
<h2><a id="%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>开发注意事项</h2>
<ol>
<li>尽量少用window.location.href，可以使用 window.open(url, '_self') 代替，如果一定要使用，请将url用signatureForUrl包装一下；</li>
<li><a></a>标签的href属性、iframe的src属性，请使用signatureForUrl包装一下；</li>
<li>其它特殊请求凡是涉及到url的都类似处理一下，保证发出去的请求都有签名鉴权参数；</li>
</ol>
<h2><a id="%E5%89%A9%E4%BD%99%E5%B7%A5%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>剩余工作</h2>
<p>目前已完成综合考评、户外广告、门前三包、渣土企业年审等react项目的主体签名鉴权工作，不排除一些url方式的请求尚未发现，比如window.location.href之类。老项目工地渣土、应急指挥等$.ajax请求不需要我们考虑，但是url类请求、附件上传等需要特殊处理。这部分需要修改的地方还比较多，需要挨个解决。另外，还有没发现的bug，只能后面慢慢发现慢慢解决了。</p>
<p>1、ant-design moment对象问题；</p>
<p>2、get请求url参数json字符串 {} 问题；</p>
<p>3、{} [] $ 等特殊符号问题;</p>
<p>4、$.ajax() tranditinal问题</p>
<pre><code class="language-js"> _saveplanproctree = http.getInstance('home/emergencyv2/planmgr/saveplanproc',{type:&quot;post&quot;,traditional: true}); 
var params={
      planID:self._planID,
      procIDs:procIDs.join(',')
}
_deletePlanProc.ajax(params).then(function(data){
   self.initPlanProcTree();
});
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[城市管理部门前端仓库迁移整改汇总]]></title>
    <link href="http://yuanchao.blogs.io/16602859341958.html"/>
    <updated>2022-08-12T14:32:14+08:00</updated>
    <id>http://yuanchao.blogs.io/16602859341958.html</id>
    <content type="html"><![CDATA[
<h1><a id="%E8%83%8C%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>背景</h1>
<p>最近测试部门主导进行了一次仓库迁移整改，对于前端来说，期望达到的目标有2个：</p>
<p>1、可以直接通过脚本编译打包源码，从而前端研发不再需要提交打包后的文件到wizdom-urban-v14这个庞大无比的仓库；</p>
<p>2、前端代码也可以进行版本管理，包括hotfix、release等分支，解决由于后端变更较大导致的前后端版本不兼容的问题；</p>
<p>我们部门前端仓库非常多，其中有很大一部分是从原前端组转交过来的，初步计划7月底将所有仓库迁移到<a href="http://192.168.101.70:8000/csgl/frontend">csgl/frontend</a>这个分组下，后期找代码就会非常方便，只需要关注本部门的分组即可。</p>
<h1><a id="%E8%BF%81%E7%A7%BB%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>迁移仓库地址</h1>
<p>持续更新中~~~</p>
<p><a href="https://alidocs.dingtalk.com/spreadsheetv2/pg9JjM8PrUNBaY2l/edit?dentryKey=pg9JjM8PrUNBaY2l&amp;dd_user_keyboard=false&amp;dd_progress=true&amp;dt_editor_toolbar=true&amp;sheet_range=s1_0_0_1_1">https://alidocs.dingtalk.com/spreadsheetv2/pg9JjM8PrUNBaY2l/edit?dentryKey=pg9JjM8PrUNBaY2l&amp;dd_user_keyboard=false&amp;dd_progress=true&amp;dt_editor_toolbar=true&amp;sheet_range=s1_0_0_1_1</a></p>
<p>注意：已经完成迁移的项目，会陆陆续续关闭提交权限，所以如果有新需求，请大家尽量往新仓库提交代码。</p>
<h1><a id="wizdom-react-submodule" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Wizdom-react &amp; submodule</h1>
<p>wizdom-react是一个基于React的前端框架，里边包含非常多的子系统代码。本部门主要包括以下11个：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>advertisement</td>
<td>户外广告</td>
</tr>
<tr>
<td>cityexam</td>
<td>北京城市体检</td>
</tr>
<tr>
<td>egovaszyd</td>
<td>青岛三重一大</td>
</tr>
<tr>
<td>egovatydc</td>
<td>通用督查</td>
</tr>
<tr>
<td>vote</td>
<td>龙岩电子投票</td>
</tr>
<tr>
<td>wizsite</td>
<td>天津滨海智慧工地</td>
</tr>
<tr>
<td>wizsitenew</td>
<td>天津滨海智慧工地(新)</td>
</tr>
<tr>
<td>extract</td>
<td>龙岩双随机</td>
</tr>
<tr>
<td>butler</td>
<td>红色管家</td>
</tr>
<tr>
<td>constraint</td>
<td>联合约束</td>
</tr>
<tr>
<td>starevaluation</td>
<td>龙岩星级评价</td>
</tr>
</tbody>
</table>
<p>之所以单独列出来，是因为它们与其它仓库的迁移有所不同，其它项目只是单纯的迁移代码，但是上面这些项目迁移出来后与原仓库还存在关联关系——即它们属于 wizdom-react 的submodule。<strong>可以简单理解为：wizdom-react是一个大仓库，我们在它的 src/plugins 目录下又 clone 了一个新仓库进来，只不过submodule这个clone方式有点不同，它会让主仓库和子仓库之间产生一定的联系。</strong></p>
<p>git submodule 相关文档：</p>
<p>wizdom-react README文档【重要】：</p>
<p><a href="http://192.168.101.70:8000/frontend/wizdom-react/-/blob/develop/README.md">http://192.168.101.70:8000/frontend/wizdom-react/-/blob/develop/README.md</a></p>
<p>git module 基本概念和用法：</p>
<p><a href="https://juejin.cn/post/6844903492750934029">https://juejin.cn/post/6844903492750934029</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/87053283">https://zhuanlan.zhihu.com/p/87053283</a></p>
<p>如果实在不想看文档，下面摘出非常重要的几点务必认真阅读（<strong>以wizsite为例</strong>）：</p>
<h2><a id="%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>目录结构</h2>
<pre><code class="language-plain_text">react
├── src
│   └── plugins                 # 子系统目录
│       └── wizsite             # 子系统
│           ├── src             # 源码
│           │   ├── images      # 图片
│           │   ├── pages       # 页面
│           │   ├── routes      # 路由
│           │   └── setting     # 配置
│           └── package.json
└── package.json
</code></pre>
<h2><a id="git%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>git操作</h2>
<h3><a id="1%E3%80%81%E6%96%B0%E5%A2%9Esubmodule" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、新增submodule</h3>
<pre><code class="language-shell"># 记住新增submodule是新增在plugins目录下，故要先cd到src/plugins这个目录里边
cd ./src/plugins
git submodule add ssh://git@192.168.101.70:222/csgl/frontend/wizdom-react-plugins/wizsite.git
</code></pre>
<blockquote>
<p>如果在根目录下是使用这个命令：<br />
git submodule add --force ssh://git@192.168.101.70:222/csgl/frontend/wizdom-react-plugins/egovatydc.git src/plugins/egovatydc</p>
</blockquote>
<p>执行完上述命令后，wizsite项目代码就会clone到plugins目录下，同时在wizdom-react的根目录下的 .gitmodules 文件中会追加几行记录，表示该submodule已经添加进来了。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207231303410.png" alt="image-20220723130259269" /></p>
<p>进入wizsite目录，会发现它默认是master分支。由于我们通常是在wizdom-react的develop分支开发，所以开发时请将 wizsite 切换到 develop 分支。</p>
<pre><code class="language-shell"># 由于当前是在src/plugins目录下，需要cd到wizsite里
cd wizdite
# 现在是master分支，需切换到develop分支
git checkout develop
</code></pre>
<h3><a id="2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96submodule" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、初始化submodule</h3>
<p>由于目前新增submodule的工作是我来做的，我新增了submodule后，大家需要把代码拉下来。<strong>需要注意的是，与新增 submodule 不同，初始化 submodule 需要在 wizdom-react的根目录下进行。</strong></p>
<blockquote>
<p>新增的时候需要切换到 src/plugins 目录下，当然也有不切换直接在wizdom-react主目录下干的方式，相对而言本文档这种比较好理解一些。</p>
</blockquote>
<p>第一步：修改 .gitmodules 文件，屏蔽掉非本部门的submodule。</p>
<p><strong><font color="red">备注：这种方式是一次update所有submodule， 由于各个部门仓库权限问题，才需要这么做，但是后面有更好的方式，请继续往下阅读。</font></strong></p>
<p>因为其它部门的仓库，我们没有权限，如果不屏蔽掉，会导致整体代码都clone不下来。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207231331909.png" alt="image-20220723133125691" /></p>
<p>第二步：执行  <strong>git submodule init</strong>  初始化submodule。</p>
<hr />
<p><strong><font color="red">备注：init 和 update 可以放到一条命令里，请继续往下阅读。</font></strong></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207231345057.png" alt="image-20220723134530408" /></p>
<p>第三步：执行  <strong>git submodule update</strong> 即可拉取所有submodule的代码。</p>
<p><strong><font color="red">备注：第三步：执行  git submodule update --init --remote ./src/plugins/xxx(submodule名称)，clone 指定的submodule代码到本地</font></strong></p>
<p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/LAJdl62EgpGQlke1/img/d0c0bab9-15bd-447e-beb9-a19ca50cb3d2.png" alt="img" /></p>
<p><strong>第一次进入 submodule ，会看到 git(1bab43xx) ，貌似产生了一个新分支，但实际上没有。切换分支到develop后（git checkout develop ）后， 用 git branch -a 命令查看， 没有产生多余分支，因此大家不用理会。</strong></p>
<p><strong><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/LAJdl62EgpGQlke1/img/3cece30b-e98d-4be0-a749-fe13027bfea5.png" alt="img" /></strong></p>
<h3><a id="3%E3%80%81%E6%9B%B4%E6%96%B0submodule" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、更新submodule</h3>
<p>当我们修改了submodule（如：wizsite）里的代码后，需要提交代码，这个提交需要分2个步骤，第一步提交submodule的代码，第二步提交submodule版本信息。</p>
<pre><code class="language-shell"># 查看是否在submodule(如：wizsite)目录下，如果不是则需进入submodule 目录
cd ./src/plugins/wizsite

# 提交 submodule 代码，注意submodule是否处于develop分支，如果不是则切换到develop
git add
git commit
git push

# 返回wizdom-react 主目录
cd ../../../

# 提交 submodule 文件版本信息，所谓版本信息其实就 .gitmodules，src/plugins/wizsite 等
git add
git commit
git push
</code></pre>
<h3><a id="4%E3%80%81%E5%88%A0%E9%99%A4submodule" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4、删除submodule</h3>
<p>暂时涉及不到，不过前面发的文档里有操作方法。</p>
<h2><a id="%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%88%96%E6%89%93%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目启动或打包</h2>
<h3><a id="%E8%BF%90%E8%A1%8C%E5%8E%9Fpages%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>运行原 pages 下的代码</h3>
<p>截止到目前，wizdom-react的本部门的项目，均已完成迁移，因此这个方式不再建议，后期 pages目录下的代码一删掉，这种方式就终结了。</p>
<p>1、修改App.js文件切换注释</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207231359898.png" alt="image-20220723135906460" /></p>
<p>2、执行相关命令</p>
<pre><code class="language-shell">#启动命令
pnpm start xxx

#打包命令
pnpm run build xxx
</code></pre>
<h3><a id="%E8%BF%90%E8%A1%8Cplugins%E4%B8%8B-submodule%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>运行 plugins 下submodule代码</h3>
<pre><code class="language-shell">#启动命令
pnpm start xxx -- --plugin

#打包命令
pnpm run build xxx -- --plugin
</code></pre>
<h1><a id="%E6%94%B6%E8%8E%B7%E4%B8%8E%E5%88%86%E4%BA%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>收获与分享</h1>
<p>本次仓库迁移整改遇到了很多问题，在解决相关问题的过程中，也学习到了不少东西，这里简单的分享几个小技巧。</p>
<h2><a id="1%E3%80%81prettier%E6%89%B9%E9%87%8F%E6%A0%BC%E5%BC%8F%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、prettier 批量格式化</h2>
<p>我们平时用的比较多的是在 webstore、visual studio 里设置启用 prettier，但是这种方式只能格式化某一个打开的文件，在迁移仓库这么繁杂的工作中，不可能挨个打开文件去格式化，所以使用 prettier 自身的命令去批量处理是一个不错的选择。</p>
<p>参考文档：<a href="https://prettier.io/docs/en/cli.html">https://prettier.io/docs/en/cli.html</a></p>
<p>相关命令：</p>
<pre><code class="language-shell">#check 是检查，write是执行格式化代码的操作.
prettier --check ./*.js

prettier --write ./*.js

prettier --check ./src/**/*.js

prettier --write ./src/**/*.js

prettier --config ./my/.prettierrc --write ./my/file.js
</code></pre>
<h2><a id="2%E3%80%81%E5%85%A8%E5%B1%80%E6%9B%BF%E6%8D%A2%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、全局替换引用路径</h2>
<p>在整理wizdom-react中的项目时，由于代码路径变了，所以代码中类似 @/images/xxx/、@pages/xxx/ 这样的引用路径都需要修改，同样也不可能挨个搜索替换，可以使用 sed 命令处理。</p>
<pre><code class="language-shell"># 替换图片引用路径
sed -i &quot;s|@/images/wizsite|@/plugins/wizsite/src/images|g&quot; src/**/*.js src/**/*.scss

# 替换组件引用路径
sed -i &quot;s|@/pages/wizsite|@/plugins/wizsite/src/pages|g&quot; src/**/*.js
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[业务系统与灵珑平台结合方案]]></title>
    <link href="http://yuanchao.blogs.io/16599168465041.html"/>
    <updated>2022-08-08T08:00:46+08:00</updated>
    <id>http://yuanchao.blogs.io/16599168465041.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E4%B8%80%E3%80%81%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83">一、集成环境</a></li>
<li><a href="#%E4%BA%8C%E3%80%81%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B">二、演变过程</a>
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC">第一个版本</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E7%89%88%E6%9C%AC">第二个版本</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E4%B8%AA%E7%89%88%E6%9C%AC">第三个版本</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">三、如何使用</a>
<ul>
<li><a href="#%E5%88%97%E8%A1%A8%E9%9B%86%E6%88%90">列表集成</a></li>
<li><a href="#%E9%A1%B5%E9%9D%A2%E9%9B%86%E6%88%90">页面集成</a></li>
<li><a href="#%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%85%8D%E7%BD%AE">导航栏配置</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E3%80%81%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA">四、效果展示</a></li>
<li><a href="#%E4%BA%94%E3%80%81%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">五、扩展阅读</a></li>
</ul>
<h1><a id="%E4%B8%80%E3%80%81%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、集成环境</h1>
<p>由于我们本身就是Vue+TS项目，所以直接使用npm集成即可。业务系统集成灵珑开发环境，请仔细阅读：<a href="https://alidocs.dingtalk.com/i/team/9JOGOL2jPWEaz4QL/docs/9JOGOjQ9L8aVjm4Q">灵珑前端集成概述</a>。</p>
<h1><a id="%E4%BA%8C%E3%80%81%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、演变过程</h1>
<p>业务系统与灵珑平台的结合使用方案，我们经历了一段摸索时期。在这个过程中，确实遇到了不少问题，但同时也解决了不少问题。在昊哥以及其它大佬的带领下，我们进行了不少跨部门的沟通，也进行了不少内部交流。从最原始的使用方式，慢慢进化，最后形成了一套比较成熟的支撑方案。</p>
<h2><a id="%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第一个版本</h2>
<p>比较原始，中规中矩，先引入灵珑组件，然后在html模板中使用，pageId 是写在配置文件里的。</p>
<p>缺点：每个模块都要新增一个组件目录，代码高度相似、冗余。</p>
<p>实现：</p>
<ol>
<li>
<p>引入灵珑组件</p>
<pre><code class="language-typescript">import { config, component, View } from &quot;@egova/base-lib&quot;;
import { TableListRenderView } from &quot;@magic/design-web&quot;;
import { DataKey } from &quot;@magic/magic-core&quot;;
import &quot;./index.scss&quot;;

@component({
    template: require(&quot;./index.html&quot;),
    components: {
        &quot;u-tablelist-render&quot;: TableListRenderView
    }
})
export default class VehicleControl extends View {
  	// code...
}
</code></pre>
</li>
<li>
<p>使用灵珑组件</p>
<pre><code class="language-html">&lt;div class=&quot;ll-table-container&quot;&gt;
    &lt;u-tablelist-render :pageId=&quot;dataKey.pageId&quot;&gt;&lt;/u-tablelist-render&gt;
&lt;/div&gt;
</code></pre>
</li>
</ol>
<h2><a id="%E7%AC%AC%E4%BA%8C%E4%B8%AA%E7%89%88%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第二个版本</h2>
<p>对灵珑组件做二次封装，pageId 也不要写在配置文件里了，直接在导航栏中配置，然后在组件内部解析路由参数得到 pageId。</p>
<p>优点：不需要每个灵珑配置的页面都新增一个组件目录了，具有了较强的可复用性。</p>
<p>缺点：不支持组件内嵌套使用。</p>
<p>实现：（以灵珑列表组件为例）</p>
<ol>
<li>
<p>TS代码</p>
<pre><code class="language-typescript">import { config, component, View } from &quot;@egova/base-lib&quot;;
import { TableListRenderView } from &quot;@magic/design-web&quot;;
import { RouteUtil } from &quot;@/common/utils/route-util&quot;;
import { DataKey } from &quot;@magic/magic-core&quot;;
import &quot;./index.scss&quot;;

@component({
    name: &quot;LLTable&quot;,
    template: require(&quot;./index.html&quot;),
    components: {
        &quot;u-tablelist-render&quot;: TableListRenderView
    }
})
export default class LLTable extends View {
    // 灵珑组件需要
    public dataKey: DataKey = {
        pageId: this.pageId,
        version: &quot;&quot;,
        documentNo: &quot;&quot;
    };

    public mounted() {
        // 初始化pageId
        this.initPageId();
    }

    public beforeRouteEnter(to: any, from: any, next: any) {
        next((vm: any) =&gt; {
            vm.initPageId();
        });
    }

    public initPageId() {
        let param = RouteUtil.getMenuParamByRoute(this.$route);
        this.dataKey.pageId = param?.pageId;
    }
}
</code></pre>
</li>
<li>
<p>HTML</p>
<pre><code class="language-html">&lt;div class=&quot;ll-table-container&quot;&gt;
    &lt;u-tablelist-render v-if=&quot;dataKey.pageId&quot; :pageId=&quot;dataKey.pageId&quot;&gt;&lt;/u-tablelist-render&gt;
    &lt;a-empty v-else class=&quot;empty-pageId&quot; description=&quot;获取 pageId 为空，请检查配置！&quot;/&gt;
&lt;/div&gt;
</code></pre>
</li>
</ol>
<h2><a id="%E7%AC%AC%E4%B8%89%E4%B8%AA%E7%89%88%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第三个版本</h2>
<p>在第二个版本的基础上，增加props传参，即支持父组件传递 pageId，优先从父组件拿到 pageId，如果拿不到再从路由参数中解析。</p>
<p>优点：1、不需要每个灵珑配置的页面都新增一个组件目录，具有了较强的可复用性；2、支持组件内嵌套使用。</p>
<p>缺点：暂无。</p>
<p>实现：（以灵珑列表组件为例）</p>
<ol>
<li>
<p>TS代码</p>
<pre><code class="language-typescript">import { config, component, View } from &quot;@egova/base-lib&quot;;
import { TableListRenderView } from &quot;@magic/design-web&quot;;
import { RouteUtil } from &quot;@/common/utils/route-util&quot;;
import { DataKey } from &quot;@magic/magic-core&quot;;
import &quot;./index.scss&quot;;

@component({
    name: &quot;LLTable&quot;,
    template: require(&quot;./index.html&quot;),
    components: {
        &quot;u-tablelist-render&quot;: TableListRenderView
    }
})
export default class LLTable extends View {
    // pageId 可以来自2种途径，外部 props 方式传入 、路由参数.
    @config({ default: () =&gt; &quot;&quot; })
    public pageId!: string;

    // 灵珑组件需要
    public dataKey: DataKey = {
        pageId: this.pageId,
        version: &quot;&quot;,
        documentNo: &quot;&quot;
    };

    public mounted() {
        // 初始化pageId
        this.initPageId();
    }

    public beforeRouteEnter(to: any, from: any, next: any) {
        next((vm: any) =&gt; {
            vm.initPageId();
        });
    }

    public initPageId() {
        let param = RouteUtil.getMenuParamByRoute(this.$route);
        this.dataKey.pageId = param?.pageId || this.pageId;
    }
}
</code></pre>
</li>
<li>
<p>HTML</p>
<pre><code class="language-html">&lt;div class=&quot;ll-table-container&quot;&gt;
    &lt;u-tablelist-render v-if=&quot;dataKey.pageId&quot; :pageId=&quot;dataKey.pageId&quot;&gt;&lt;/u-tablelist-render&gt;
    &lt;a-empty v-else class=&quot;empty-pageId&quot; description=&quot;获取 pageId 为空，请检查配置！&quot;/&gt;
&lt;/div&gt;
</code></pre>
</li>
</ol>
<h1><a id="%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、如何使用</h1>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208071847255.png" alt="image-20220807184733010" /></p>
<h2><a id="%E5%88%97%E8%A1%A8%E9%9B%86%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>列表集成</h2>
<pre><code class="language-typescript">// route/index.ts
{
    name: &quot;lawcaseitem&quot;,
    path: &quot;lawcaseitem&quot;,
    meta: {
        icon: &quot;icon-violation-alarmtrack&quot;,
        title: &quot;执法案由&quot;,
        schemaId: &quot;construction:lawcaseitem&quot;
    },
    component: () =&gt; import(&quot;@/components/linglong/table&quot;)
}
</code></pre>
<h2><a id="%E9%A1%B5%E9%9D%A2%E9%9B%86%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>页面集成</h2>
<pre><code class="language-typescript">// route/index.ts
{
    name: &quot;violation-vehiclecontrol&quot;,
    path: &quot;/vehiclecontrol&quot;,
    meta: {
        icon: &quot;icon-vehicle&quot;,
        title: &quot;车辆管控&quot;
    },
    component: () =&gt; import(&quot;@/components/linglong/page&quot;)
}
</code></pre>
<h2><a id="%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>导航栏配置</h2>
<p>应用管理——导航栏——子系统——导航项——导航项描述中配置灵珑页面的 pageId 即可。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208071807815.png" alt="image-20220807180646122" /></p>
<h1><a id="%E5%9B%9B%E3%80%81%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、效果展示</h1>
<ol>
<li>
<p>桃源车辆管控</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208080738127.png" alt="image-20220808073854596" /></p>
</li>
<li>
<p>滨海政企交流</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208071948313.png" alt="image-20220807194841025" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208071949342.png" alt="image-20220807194929982" /></p>
</li>
<li>
<p>渣土消纳点公示、执法案由等</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208080737114.png" alt="image-20220808073745440" /></p>
</li>
</ol>
<h1><a id="%E4%BA%94%E3%80%81%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>五、扩展阅读</h1>
<p>【扩展1】<a href="https://alidocs.dingtalk.com/i/team/9JOGOLjlap1oz4QL/docs/9JOGO4r13eeMRz4Q">灵珑列表与手写页面丝滑交互方案</a></p>
<p>【扩展2】<a href="https://docs.dingtalk.com/i/nodes/3mzaPNMZ6jkJqkD32QqQWYLDwXq4Ky1r?nav=share&amp;navQuery=spaceId%3D9JOGOLjlap1oz4QL">灵珑飞天集成案例——龙岩物业</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[灵珑列表与手写页面丝滑交互方案]]></title>
    <link href="http://yuanchao.blogs.io/16595894248167.html"/>
    <updated>2022-08-04T13:03:44+08:00</updated>
    <id>http://yuanchao.blogs.io/16595894248167.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E9%9C%80%E6%B1%82%E8%83%8C%E6%99%AF">需求背景</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">实现方案</a>
<ul>
<li><a href="#%E9%A2%84%E6%9C%9F%E7%9B%AE%E6%A0%87">预期目标</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E6%A6%82%E8%BF%B0">方案概述</a></li>
<li><a href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4">具体步骤</a>
<ul>
<li><a href="#1%E3%80%81%E9%85%8D%E7%BD%AE%E7%81%B5%E7%8F%91%E5%88%97%E8%A1%A8">1、配置灵珑列表</a></li>
<li><a href="#2%E3%80%81%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E4%BD%9C%E3%80%81%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC">2、绑定自定义动作、编写脚本</a></li>
<li><a href="#3%E3%80%81%E5%B0%81%E8%A3%85%E7%81%B5%E7%8F%91%E5%88%97%E8%A1%A8%E7%BB%84%E4%BB%B6">3、封装灵珑列表组件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">如何使用</a>
<ul>
<li><a href="#1%E3%80%81%E5%BC%95%E5%85%A5%E5%B0%81%E8%A3%85%E5%90%8E%E7%9A%84lltable%E7%BB%84%E4%BB%B6">1、引入封装后的LLTable组件</a></li>
<li><a href="#2%E3%80%81html%E4%B8%AD%E4%BD%BF%E7%94%A8">2、html中使用</a></li>
<li><a href="#3%E3%80%81%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA">3、效果展示</a></li>
</ul>
</li>
<li><a href="#%E6%89%A9%E5%B1%95%E4%B8%8E%E5%B1%95%E6%9C%9B">扩展与展望</a></li>
</ul>
<h1><a id="%E9%9C%80%E6%B1%82%E8%83%8C%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求背景</h1>
<p>自从公司推出灵珑以来，部门大力支持，在处理项目实际需求的过程中，很多页面都开始采用灵珑来进行开发。但是经常遇到这样的场景：一个功能模块包含很多页面，列表页面可以用灵珑配置，但新增（编辑）、详情或其它子页面过于复杂，用灵珑无法实现或者及其困难，从而只能手写实现。但是经常因为手写的页面需要使用列表里的数据，而灵珑页面和手写页面两者无法直接交互，导致最终不得不将列表也采用手写方式开发。这也无形之中给以前用灵珑实现过的项目蒙上了一层阴影，即万一后面需求发生变更，比如加一个列操作按钮，点击按钮要求打开一个复杂的子页面怎么办？如果子页面灵珑实现不了，难道又倒退回去重写手写列表吗？针对这一难点，本文提供了一套详细解决方案，经过初步测试，基本能否达到预期效果。</p>
<h1><a id="%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现方案</h1>
<p>首先在金总和园姐的陪同下，与灵珑相关研发进行了深度沟通，形成了初步的思路。而后集火园姐、志超等小伙伴的智慧，群策群力，终于弄出了一套解决方案。</p>
<h2><a id="%E9%A2%84%E6%9C%9F%E7%9B%AE%E6%A0%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>预期目标</h2>
<ul>
<li>
<p>灵珑列表操作按钮，可以触发手写页面的显示或者隐藏</p>
</li>
<li>
<p>灵珑列表数据能够传递给手写页面</p>
</li>
<li>
<p>手写页面能否触发灵珑列表执行刷新等简单操作</p>
</li>
<li>
<p>灵珑列表与手写页面之间的交互非常丝滑，不能损耗系统性能</p>
</li>
</ul>
<h2><a id="%E6%96%B9%E6%A1%88%E6%A6%82%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方案概述</h2>
<p><strong>灵珑自定义动作脚本 + 二次封装灵珑列表组件。</strong></p>
<p>灵珑端：给灵珑列表的操作按钮绑定动作，在绑定动作面板中选择自定义动作，编写一段DOM操作的JS脚本。</p>
<p>业务系统端：使用封装好的灵珑列表组件，只关注自己手写页面的实现。</p>
<h2><a id="%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>具体步骤</h2>
<h3><a id="1%E3%80%81%E9%85%8D%E7%BD%AE%E7%81%B5%E7%8F%91%E5%88%97%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、配置灵珑列表</h3>
<p>配置过程请参考相关文档，这里不是重点。如红框所示，为灵珑配置的页面。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208041144500.png" alt="image-20220804114409732" /></p>
<h3><a id="2%E3%80%81%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E4%BD%9C%E3%80%81%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、绑定自定义动作、编写脚本</h3>
<p>列表操作的脚本，目前可以使用如下模板代码。 后续如果有其它脚本可以抽取出来作为模板。这里分两种情况，列表单独存在或者以page嵌入的形式存在，触发列表刷新的方式有所不同。其中后一种更加通用，但是它依赖于一个 id 属性，而不同现场 id 属性可能不同，所以为了减少不必要的麻烦，对于独立的列表，我们还是使用前一种模板，而对于page里嵌入的列表，则我们使用后一种脚本模板。</p>
<pre><code class="language-js">// 如果列表是单独存在的，那么模板脚本如下：
function main(data, event){
     // 显示预先占位的子页面div
     let llSubPage = document.getElementById(&quot;llSubPage&quot;);
     llSubPage.style.transform='translateY(0)';
     
     // 重新组装行数据，灵珑默认的行数据data语义性极差
     let rowData = {};
     let fieldList = this.state.allTableFields;
     if(data &amp;&amp; typeof data === &quot;object&quot;){
       Object.keys(data).forEach((key) =&gt; {
          let value = data[key];
          let field = fieldList.find((item) =&gt; item.columnFieldOption.id === key);
          if (field) {
               rowData[field.columnFieldOption.name] = value;
          }
     		});
     }
    
     // 执行预先定义的回调函数传递数据给业务系统。如果列操作有多个按钮，需指明操作类型，比如：&quot;add&quot;、&quot;edit&quot;、&quot;detail&quot;等。
     window.lingLongCallback(rowData, &quot;detail&quot;);
}


//-------------------------------------------------------------------------------------------------
// 如果是列表以page的形式存在，则模板脚本如下：
function main(data, event){
     // 列表组件实例，根据 id 获得。id可以通过点击“保存按钮”，查看 network 查看 payload 得到。
     var tableComp = this.findElement(&quot;widget_list_table_pc_4e7dy8&quot;);
     // 刷新列表的方法
     function refresh(){
          tableComp.refresh();
     }

     // 显示预先占位的子页面div
     let llSubPage = document.getElementById(&quot;llSubPage&quot;);
     llSubPage.style.transform='translateY(0)';
     
     // 重新组装行数据，灵珑默认的行数据data语义性极差
     let rowData = {};
     let fieldList = this.state.allTableFields;
     if(data &amp;&amp; typeof data === &quot;object&quot;){
          Object.keys(data).forEach((key) =&gt; {
               let value = data[key];
               let field = fieldList.find((item) =&gt; item.columnFieldOption.id === key);
               if (field) {
                    rowData[field.columnFieldOption.name] = value;
               }
          });
     }
    
     // 执行预先定义的回调函数传递数据给业务系统。如果列操作有多个按钮，需指明操作类型，比如：&quot;add&quot;、&quot;edit&quot;、&quot;detail&quot;等。
     // 将refresh方法传递给手写页面使用，从而实现可以刷新灵珑列表的目标。
     window.lingLongCallback({}, &quot;edit&quot;, {refresh: refresh});
}
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208080804468.png" alt="image-20220808080423058" /></p>
<h3><a id="3%E3%80%81%E5%B0%81%E8%A3%85%E7%81%B5%E7%8F%91%E5%88%97%E8%A1%A8%E7%BB%84%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、封装灵珑列表组件</h3>
<p>**html模板：**除了封装灵珑的 TableListRender 组件，还内置了一个占位div。默认其实就是存在的，只不过通过 CSS 的 transform 属性将其放置到不可见的位置而已。</p>
<pre><code class="language-html">&lt;div class=&quot;ll-table-container&quot;&gt;
    &lt;u-tablelist-render ref=&quot;llTable&quot; v-if=&quot;dataKey.pageId&quot; :pageId=&quot;dataKey.pageId&quot;&gt;&lt;/u-tablelist-render&gt;
    &lt;a-empty v-else class=&quot;empty-pageId&quot; description=&quot;获取 pageId 为空，请检查配置！&quot;/&gt;

    &lt;!--灵珑列表子页面--&gt;
    &lt;div id=&quot;llSubPage&quot; v-if=&quot;hasSubPage&quot;&gt;
        &lt;!--Vue作用域插槽--&gt;
        &lt;slot :rowData=&quot;rowData&quot; :actionType=&quot;actionType&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css"> #llSubPage{
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #fff;
        transform: translateY(110%);
        transition: all 0.5s linear;
}
</code></pre>
<p><strong>TS文件：</strong></p>
<ol>
<li>
<p>定义了一系列属性如下所示。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>pageId</td>
<td>灵珑需要的核心标识，pageId</td>
<td>注意pageId既可以通过属性传递，也可以通过路由配置自动获取</td>
</tr>
<tr>
<td>hasSubPage</td>
<td>是否包含手写子页面</td>
<td>默认值false，如果包含手写子页面则传true</td>
</tr>
<tr>
<td>refreshOnHide</td>
<td>手写子页面隐藏时是否需要刷新页面</td>
<td>默认为false，如果需要则传true</td>
</tr>
<tr>
<td>onHide</td>
<td>手写子页面隐藏时可执行的外操作，回调函数</td>
<td>默认不执行任何操作，回调函数接收2个参数，参数1-行数据，参数2-灵珑列表对象</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>对外暴露了一个自定义事件名称，使用全局事件总线监听子页面关闭事件。</p>
</li>
<li>
<p>处理了手写子页面关闭时的逻辑。</p>
</li>
<li>
<p>全部源码如下所示：</p>
<pre><code class="language-typescript">import { config, component, View } from &quot;@egova/base-lib&quot;;
import { TableListRenderView } from &quot;@magic/design-web&quot;;
import { RouteUtil } from &quot;@/common/utils/route-util&quot;;
import { DataKey } from &quot;@magic/magic-core&quot;;
import FuncType from &quot;@/models/common/functype&quot;;
import &quot;./index.scss&quot;;

// 灵珑table子页面关闭事件名称
export const EVENT_HIDE_SUBPAGE: string = &quot;EVENT_HIDE_SUBPAGE&quot;;

@component({
    name: &quot;LLTable&quot;,
    template: require(&quot;./index.html&quot;),
    components: {
        &quot;u-tablelist-render&quot;: TableListRenderView
    }
})
export default class LLTable extends View {
    // pageId 可以来自2种途径，外部 props 方式传入 、路由参数.
    @config({ default: () =&gt; &quot;&quot; })
    public pageId!: string;

    // 是否有子页面，灵珑列表与手写页面交互时可用
    @config({ default: () =&gt; false })
    public hasSubPage!: boolean;

    // 隐藏子页面时是否需要刷新列表
    @config({ default: () =&gt; false })
    public refreshOnHide!: boolean;

    // 隐藏子页面后可执行的额外操作
    @config({
        default: () =&gt; () =&gt; {}
    })
    public onHide!: FuncType;

    // 灵珑组件需要
    public dataKey: DataKey = {
        pageId: this.pageId,
        version: &quot;&quot;,
        documentNo: &quot;&quot;
    };

    // 灵珑列表选中的行数据
    public rowData: any = {};

    // 灵珑列表列操作按钮动作类型，常见的如：新增、编辑、删除、详情等
    public actionType: string = &quot;&quot;;

    public mounted() {
        // 初始化pageId
        this.initPageId();

        // 定义回调函数，供灵珑自定义动作脚本使用
        window.llTableCallback = (data: any, type: string=&quot;&quot;) =&gt; {
            this.rowData = data || {};
            this.actionType = type;
        };
        // 绑定监听事件
        (this as any).$bus.$on(EVENT_HIDE_SUBPAGE, this.hide);
    }

    // 解绑监听事件
    public beforeDestroy() {
        (this as any).$bus.$off(EVENT_HIDE_SUBPAGE);
    }

    public beforeRouteEnter(to: any, from: any, next: any) {
        next((vm: any) =&gt; {
            vm.initPageId();
        });
    }

    public initPageId() {
        let param = RouteUtil.getMenuParamByRoute(this.$route);
        this.dataKey.pageId = param?.pageId || this.pageId;
    }

    public hide() {
        let llSubPage = document.getElementById(&quot;llSubPage&quot;) as HTMLElement;
        llSubPage.style.transform = &quot;translateY(110%)&quot;;
        if (this.refreshOnHide) {
            (this.$refs.llTable as any).refresh();
        }
        this.onHide(this.rowData, this.$refs.llTable as any);
    }
}
</code></pre>
</li>
</ol>
<h1><a id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何使用</h1>
<h3><a id="1%E3%80%81%E5%BC%95%E5%85%A5%E5%B0%81%E8%A3%85%E5%90%8E%E7%9A%84lltable%E7%BB%84%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、引入封装后的LLTable组件</h3>
<pre><code class="language-typescript">import { autowired, component, View } from &quot;@egova/base-lib&quot;;
import LLTable from &quot;@/components/linglong/table&quot;;
import Detail from &quot;./detail&quot;;
import Service from &quot;./service&quot;;
import &quot;./index.scss&quot;;

@component({
    name: &quot;ApproveSite&quot;,
    template: require(&quot;./index.html&quot;),
    components: {
        &quot;u-ll-table&quot;: LLTable,
        &quot;u-detail&quot;: Detail
    }
})
export default class ApproveSite extends View {
    @autowired(Service)
    public service!: Service;

    public handleExtra() {
        console.log(&quot;==========额外操作===========&quot;);
    }
}
</code></pre>
<h3><a id="2%E3%80%81html%E4%B8%AD%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、html中使用</h3>
<p>这里有手写页面、隐藏手写页面时需要刷新灵珑列表、隐藏手写页面时有额外操作。</p>
<pre><code class="language-html">&lt;div class=&quot;height-100&quot;&gt;
    &lt;u-ll-table :hasSubPage=&quot;true&quot; :refreshOnHide=&quot;true&quot; :onHide=&quot;handleExtra&quot;&gt;
        &lt;template slot-scope=&quot;{rowData, actionType}&quot;&gt;
            &lt;!--详情页面--&gt;
            &lt;u-detail :rowData=&quot;rowData&quot;&gt;&lt;/u-detail&gt;
        &lt;/template&gt;
    &lt;/u-ll-table&gt;
&lt;/div&gt;
</code></pre>
<h3><a id="3%E3%80%81%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、效果展示</h3>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202208080849464.gif" alt="2022-08-08 08.47.32" /></p>
<h1><a id="%E6%89%A9%E5%B1%95%E4%B8%8E%E5%B1%95%E6%9C%9B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展与展望</h1>
<p>1、今后再遇到类似需求，尽量像文档中那样，自定义动作脚本写的通用一些，并且将脚本收集保存，甚至提交到Git仓库中，详细注释方便查阅。</p>
<p>2、本文档只展示了灵珑列表组件与手写子页面的交互方案，但是这个思路是通用的，可以推广到灵珑页面、灵珑表单与手写页面的交互。后期如有类似需求，再进行扩展。</p>
<p>3、解决疑难问题，要善于集合群体的智慧。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[前端仓库迁移整改汇总]]></title>
    <link href="http://yuanchao.blogs.io/16585604440329.html"/>
    <updated>2022-07-23T15:14:04+08:00</updated>
    <id>http://yuanchao.blogs.io/16585604440329.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E8%83%8C%E6%99%AF">背景</a></li>
<li><a href="#%E8%BF%81%E7%A7%BB%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80">迁移仓库地址</a></li>
<li><a href="#wizdom-react-submodule">Wizdom-react &amp; submodule</a>
<ul>
<li><a href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">目录结构</a></li>
<li><a href="#git%E6%93%8D%E4%BD%9C">git操作</a>
<ul>
<li><a href="#1%E3%80%81%E6%96%B0%E5%A2%9Esubmodule">1、新增submodule</a></li>
<li><a href="#2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96submodule">2、初始化submodule</a></li>
<li><a href="#3%E3%80%81%E6%9B%B4%E6%96%B0submodule">3、更新submodule</a></li>
<li><a href="#4%E3%80%81%E5%88%A0%E9%99%A4submodule">4、删除submodule</a></li>
</ul>
</li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%88%96%E6%89%93%E5%8C%85">项目启动或打包</a>
<ul>
<li><a href="#%E8%BF%90%E8%A1%8C%E5%8E%9Fpages%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%A0%81">运行原 pages 下的代码</a></li>
<li><a href="#%E8%BF%90%E8%A1%8Cplugins%E4%B8%8B-submodule%E4%BB%A3%E7%A0%81">运行 plugins 下submodule代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%94%B6%E8%8E%B7%E4%B8%8E%E5%88%86%E4%BA%AB">收获与分享</a>
<ul>
<li><a href="#1%E3%80%81prettier%E6%89%B9%E9%87%8F%E6%A0%BC%E5%BC%8F%E5%8C%96">1、prettier 批量格式化</a></li>
<li><a href="#2%E3%80%81%E5%85%A8%E5%B1%80%E6%9B%BF%E6%8D%A2%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84">2、全局替换引用路径</a></li>
</ul>
</li>
</ul>
<h1><a id="%E8%83%8C%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>背景</h1>
<p>最近测试部门主导进行了一次仓库迁移整改，对于前端来说，期望达到的目标有2个：</p>
<p>1、可以直接通过脚本编译打包源码，从而前端研发不再需要提交打包后的文件到wizdom-urban-v14这个庞大无比的仓库；</p>
<p>2、前端代码也可以进行版本管理，包括hotfix、release等分支，解决由于后端变更较大导致的前后端版本不兼容的问题；</p>
<p>我们部门前端仓库非常多，其中有很大一部分是从原前端组转交过来的，初步计划7月底将所有仓库迁移到<a href="http://192.168.101.70:8000/csgl/frontend">csgl/frontend</a>这个分组下，后期找代码就会非常方便，只需要关注本部门的分组即可。</p>
<h1><a id="%E8%BF%81%E7%A7%BB%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>迁移仓库地址</h1>
<p>持续更新中~~~</p>
<p><a href="https://alidocs.dingtalk.com/spreadsheetv2/pg9JjM8PrUNBaY2l/edit?dentryKey=pg9JjM8PrUNBaY2l&amp;dd_user_keyboard=false&amp;dd_progress=true&amp;dt_editor_toolbar=true&amp;sheet_range=s1_0_0_1_1">https://alidocs.dingtalk.com/spreadsheetv2/pg9JjM8PrUNBaY2l/edit?dentryKey=pg9JjM8PrUNBaY2l&amp;dd_user_keyboard=false&amp;dd_progress=true&amp;dt_editor_toolbar=true&amp;sheet_range=s1_0_0_1_1</a></p>
<p>注意：已经完成迁移的项目，会陆陆续续关闭提交权限，所以如果有新需求，请大家尽量往新仓库提交代码。</p>
<h1><a id="wizdom-react-submodule" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Wizdom-react &amp; submodule</h1>
<p>wizdom-react是一个基于React的前端框架，里边包含非常多的子系统代码。本部门主要包括以下11个：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>advertisement</td>
<td>户外广告</td>
</tr>
<tr>
<td>cityexam</td>
<td>北京城市体检</td>
</tr>
<tr>
<td>egovaszyd</td>
<td>青岛三重一大</td>
</tr>
<tr>
<td>egovatydc</td>
<td>通用督查</td>
</tr>
<tr>
<td>vote</td>
<td>龙岩电子投票</td>
</tr>
<tr>
<td>wizsite</td>
<td>天津滨海智慧工地</td>
</tr>
<tr>
<td>wizsitenew</td>
<td>天津滨海智慧工地(新)</td>
</tr>
<tr>
<td>extract</td>
<td>龙岩双随机</td>
</tr>
<tr>
<td>butler</td>
<td>红色管家</td>
</tr>
<tr>
<td>constraint</td>
<td>联合约束</td>
</tr>
<tr>
<td>starevaluation</td>
<td>龙岩星级评价</td>
</tr>
</tbody>
</table>
<p>之所以单独列出来，是因为它们与其它仓库的迁移有所不同，其它项目只是单纯的迁移代码，但是上面这些项目迁移出来后与原仓库还存在关联关系——即它们属于 wizdom-react 的submodule。<strong>可以简单理解为：wizdom-react是一个大仓库，我们在它的 src/plugins 目录下又 clone 了一个新仓库进来，只不过submodule这个clone方式有点不同，它会让主仓库和子仓库之间产生一定的联系。</strong></p>
<p>git submodule 相关文档：</p>
<p>wizdom-react README文档【重要】：</p>
<p><a href="http://192.168.101.70:8000/frontend/wizdom-react/-/blob/develop/README.md">http://192.168.101.70:8000/frontend/wizdom-react/-/blob/develop/README.md</a></p>
<p>git module 基本概念和用法：</p>
<p><a href="https://juejin.cn/post/6844903492750934029">https://juejin.cn/post/6844903492750934029</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/87053283">https://zhuanlan.zhihu.com/p/87053283</a></p>
<p>如果实在不想看文档，下面摘出非常重要的几点务必认真阅读（<strong>以wizsite为例</strong>）：</p>
<h2><a id="%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>目录结构</h2>
<pre><code class="language-plain_text">react
├── src
│   └── plugins                 # 子系统目录
│       └── wizsite             # 子系统
│           ├── src             # 源码
│           │   ├── images      # 图片
│           │   ├── pages       # 页面
│           │   ├── routes      # 路由
│           │   └── setting     # 配置
│           └── package.json
└── package.json
</code></pre>
<h2><a id="git%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>git操作</h2>
<h3><a id="1%E3%80%81%E6%96%B0%E5%A2%9Esubmodule" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、新增submodule</h3>
<p>如果wizdom-react中已经新增过submodule了直接略过此步骤.</p>
<blockquote>
<p>除了用下面的方式，也可以在根目录下直接一条命令搞定：git submodule add --force ssh://git@192.168.101.70:222/csgl/frontend/wizdom-react-plugins/wizsite.git src/plugins/wizsite</p>
</blockquote>
<pre><code class="language-shell"># 记住新增submodule是新增在plugins目录下，故要先cd到src/plugins这个目录里边
cd ./src/plugins
git submodule add ssh://git@192.168.101.70:222/csgl/frontend/wizdom-react-plugins/wizsite.git
</code></pre>
<p>执行完上述命令后，wizsite项目代码就会clone到plugins目录下，同时在wizdom-react的根目录下的 .gitmodules 文件中会追加几行记录，表示该submodule已经添加进来了。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207231303410.png" alt="image-20220723130259269" /></p>
<p>进入wizsite目录，会发现它默认是master分支。由于我们通常是在wizdom-react的develop分支开发，所以开发时请将 wizsite 切换到 develop 分支。</p>
<pre><code class="language-shell"># 由于当前是在src/plugins目录下，需要cd到wizsite里
cd wizdite
# 现在是master分支，需切换到develop分支
git checkout develop
</code></pre>
<h3><a id="2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96submodule" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、初始化submodule</h3>
<p>由于目前新增submodule的工作是我来做的，我新增了submodule后，大家需要把代码拉下来。<strong>需要注意的是，与新增 submodule 不同，初始化 submodule 需要在 wizdom-react的根目录下进行。</strong></p>
<blockquote>
<p>新增的时候需要切换到 src/plugins 目录下，当然也有不切换直接在wizdom-react主目录下干的方式，相对而言本文档这种比较好理解一些。</p>
</blockquote>
<p>第一步：修改 .gitmodules 文件，屏蔽掉非本部门的submodule。</p>
<p><strong><font color="red">备注：这种方式是一次update所有submodule， 由于各个部门仓库权限问题，才需要这么做，但是后面有更好的方式，请继续往下阅读。</font></strong></p>
<p>因为其它部门的仓库，我们没有权限，如果不屏蔽掉，会导致整体代码都clone不下来。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207231331909.png" alt="image-20220723133125691" /></p>
<p>第二步：执行  <strong>git submodule init</strong>  初始化submodule。</p>
<hr />
<p><strong><font color="red">备注：init 和 update 可以放到一条命令里，请继续往下阅读。</font></strong></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207231345057.png" alt="image-20220723134530408" /></p>
<p>第三步：执行  <strong>git submodule update</strong> 即可拉取所有submodule的代码。</p>
<p><strong><font color="red">备注：第三步：执行  git submodule update --init --remote ./src/plugins/xxx(submodule名称)，clone 指定的submodule代码到本地</font></strong></p>
<p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/LAJdl62EgpGQlke1/img/d0c0bab9-15bd-447e-beb9-a19ca50cb3d2.png" alt="img" /></p>
<p><strong>第一次进入 submodule ，会看到 git(1bab43xx) ，貌似产生了一个新分支，但实际上没有。切换分支到develop后（git checkout develop ）后， 用 git branch -a 命令查看， 没有产生多余分支，因此大家不用理会。</strong></p>
<p><strong><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/LAJdl62EgpGQlke1/img/3cece30b-e98d-4be0-a749-fe13027bfea5.png" alt="img" /></strong></p>
<h3><a id="3%E3%80%81%E6%9B%B4%E6%96%B0submodule" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、更新submodule</h3>
<p>当我们修改了submodule（如：wizsite）里的代码后，需要提交代码，这个提交需要分2个步骤，第一步提交submodule的代码，第二步提交submodule版本信息。</p>
<pre><code class="language-shell"># 查看是否在submodule(如：wizsite)目录下，如果不是则需进入submodule 目录
cd ./src/plugins/wizsite

# 提交 submodule 代码，注意submodule是否处于develop分支，如果不是则切换到develop
git add
git commit
git push

# 返回wizdom-react 主目录
cd ../../../

# 提交 submodule 文件版本信息，所谓版本信息其实就 .gitmodules，src/plugins/wizsite 等
git add
git commit
git push
</code></pre>
<h3><a id="4%E3%80%81%E5%88%A0%E9%99%A4submodule" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4、删除submodule</h3>
<p>暂时涉及不到，不过前面发的文档里有操作方法。</p>
<h2><a id="%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%88%96%E6%89%93%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目启动或打包</h2>
<h3><a id="%E8%BF%90%E8%A1%8C%E5%8E%9Fpages%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>运行原 pages 下的代码</h3>
<p>截止到目前，wizdom-react的本部门的项目，均已完成迁移，因此这个方式不再建议，后期 pages目录下的代码一删掉，这种方式就终结了。</p>
<p>1、修改App.js文件切换注释</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207231359898.png" alt="image-20220723135906460" /></p>
<p>2、执行相关命令</p>
<pre><code class="language-shell">#启动命令
pnpm start xxx

#打包命令
pnpm run build xxx
</code></pre>
<h3><a id="%E8%BF%90%E8%A1%8Cplugins%E4%B8%8B-submodule%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>运行 plugins 下submodule代码</h3>
<pre><code class="language-shell">#启动命令
pnpm start xxx -- --plugin

#打包命令
pnpm run build xxx -- --plugin
</code></pre>
<h1><a id="%E6%94%B6%E8%8E%B7%E4%B8%8E%E5%88%86%E4%BA%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>收获与分享</h1>
<p>本次仓库迁移整改遇到了很多问题，在解决相关问题的过程中，也学习到了不少东西，这里简单的分享几个小技巧。</p>
<h2><a id="1%E3%80%81prettier%E6%89%B9%E9%87%8F%E6%A0%BC%E5%BC%8F%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、prettier 批量格式化</h2>
<p>我们平时用的比较多的是在 webstore、visual studio 里设置启用 prettier，但是这种方式只能格式化某一个打开的文件，在迁移仓库这么繁杂的工作中，不可能挨个打开文件去格式化，所以使用 prettier 自身的命令去批量处理是一个不错的选择。</p>
<p>参考文档：<a href="https://prettier.io/docs/en/cli.html">https://prettier.io/docs/en/cli.html</a></p>
<p>相关命令：</p>
<pre><code class="language-shell">#check 是检查，write是执行格式化代码的操作.
prettier --check ./*.js

prettier --write ./*.js

prettier --check ./src/**/*.js

prettier --write ./src/**/*.js

prettier --config ./my/.prettierrc --write ./my/file.js
</code></pre>
<h2><a id="2%E3%80%81%E5%85%A8%E5%B1%80%E6%9B%BF%E6%8D%A2%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、全局替换引用路径</h2>
<p>在整理wizdom-react中的项目时，由于代码路径变了，所以代码中类似 @/images/xxx/、@pages/xxx/ 这样的引用路径都需要修改，同样也不可能挨个搜索替换，可以使用 sed 命令处理。</p>
<pre><code class="language-shell"># 替换图片引用路径
sed -i &quot;s|@/images/wizsite|@/plugins/wizsite/src/images|g&quot; src/**/*.js src/**/*.scss

# 替换组件引用路径
sed -i &quot;s|@/pages/wizsite|@/plugins/wizsite/src/pages|g&quot; src/**/*.js
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vue新框架和微服务交换token说明]]></title>
    <link href="http://yuanchao.blogs.io/16571697876895.html"/>
    <updated>2022-07-07T12:56:27+08:00</updated>
    <id>http://yuanchao.blogs.io/16571697876895.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E6%B5%81%E7%A8%8B%E5%9B%BE">流程图</a>
<ul>
<li><a href="#%E7%99%BB%E5%BD%95%E5%85%A8%E6%B5%81%E7%A8%8B">登录全流程</a></li>
<li><a href="#token%E4%BA%A4%E6%8D%A2%E6%B5%81%E7%A8%8B">token交换流程</a></li>
</ul>
</li>
<li><a href="#token%E4%BA%A4%E6%8D%A2%E7%BB%86%E8%8A%82">token交换细节</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%83%85%E5%86%B5">常见错误情况</a></li>
</ul>
<p>今年三四月份以来，部门开始推渣土精细化，使用中台提供的最新Vue框架。由于中台的原始框架，默认只能使用统一用户中心后端，即默认全部是走微服务，而目前的实际情况是我们还有很多接口必须要走mis服务。因此，我按照中台提供的相关文档对原始框架做了一些定制化的改动，让它可以同时支持mis服务和微服务，而支持微服务就需要进行token交换，这个过程在开发和部署中经常出现问题，原因就是很多同事搞不清楚其中的关联关系和相关细节，下面对此做一个全面的介绍。</p>
<h1><a id="%E6%B5%81%E7%A8%8B%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>流程图</h1>
<p>由于token交换只发生在登录流程中，故这里绘制了2个流程图，一个是登录全流程，一个是token交换流程。</p>
<h2><a id="%E7%99%BB%E5%BD%95%E5%85%A8%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>登录全流程</h2>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207071128868.png" alt="Vue框架登录流程" /></p>
<h2><a id="token%E4%BA%A4%E6%8D%A2%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>token交换流程</h2>
<p>理论上下面4个要素可以分布在不同的服务器，但实际场景可能不会有这么多，可能只有2~3甚至就1台服务器。总之，部署的服务器越多，越要注意服务器之间的网络是否互联互通。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207071223481.png" alt="image-20220707122317930" /></p>
<h1><a id="token%E4%BA%A4%E6%8D%A2%E7%BB%86%E8%8A%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>token交换细节</h1>
<blockquote>
<p>所谓token交换本质上就是将mis的token作为参数，调用微服务接口(/token/exchange) 获得微服务的token，为了以示区分，我们把它叫做 access_token，后面再发送微服务相关请求时，会在请求头里携带这个access_token，从而得到正确的响应结果。</p>
</blockquote>
<ol>
<li>
<p>从前面的登录流程图可以看到，只有启用了微服务的情况下才涉及到token交换，否则是不用管的。同时，<strong>目前的版本里，获取微服务地址分两种情况，一是像渣土微服务这种从配置项获取，二是从浏览器地址栏解析得到。</strong></p>
</li>
<li>
<p>渣土精细化项目里微服务地址是走的配置项，需要从后台接口获取。这个配置项我查了下，是前同事在2022年4月15号写的changelog，故早期版本里是没有的， 所以<strong>一定要使用较新的渣土后台更新包</strong>（egova-construction-v2-1.0.1-mysql.jar）。渣土微服务配置项在：系统配置——扩展子系统——渣土工地。<strong>配置规则是一定要是nginx里做了正确部署，浏览器里可以真实访问的、并且前端更新包所在的服务器必须是能够访问到的地址。</strong></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207071133985.png" alt="image-20220707113336616" /></p>
</li>
<li>
<p>其它新项目(非渣土项目)，目前没有走配置项，所以直接从浏览器里地址栏里解析，比如：<a href="http://192.168.102.11:8080/eUrbanMIS/view/construction/index.html">http://192.168.102.11:8080/eUrbanMIS/view/construction/index.html</a>  这个是前端访问地址，我们会把 <a href="http://192.168.102.11:8080">http://192.168.102.11:8080</a> 解析出来，然后再拼上具体微服务后缀名，最终得到的微服务地址为：<a href="http://192.168.102.11:8080/microconstruction%E3%80%82">http://192.168.102.11:8080/microconstruction。</a></p>
</li>
</ol>
<h1><a id="%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常见错误情况</h1>
<p>除了渣土精细化项目需要注意配置项外，其它问题都可以参考token交换流程图。为了避免向上翻看内容不便，这里再贴一遍：</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202207071223481.png" alt="image-20220707122317930" /></p>
<ol>
<li>
<p>渣土精细化项目，渣土jar包版本过低，缺少相关配置项</p>
<p>解决：升级渣土jar包。</p>
</li>
<li>
<p>Nginx 中没有正确部署，配置的微服务地址或者从浏览器解析得到的微服务地址，实际无法访问</p>
<p>解决：正确部署，参考现成案例（城市应用管理部门服务器）。</p>
</li>
<li>
<p>Nginx正常部署，浏览器里可以正常访问，前端项目交换token报错</p>
<p>原因：可能是前端更新包所在的服务器和nginx转发出来的地址，网络不通。可以使用 ping 、telnet 、curl 等命令测试确认一下。</p>
<p>解决：解决网络不通问题。</p>
</li>
<li>
<p>Nginx正常部署、网络互通、前端项目仍然交换token报错</p>
<p>原因：可能是微服务配置文件中配置的 mis认证地址所在的服务器，与部署微服务所在的服务器两者网络不通，即进行token交换时，前端的请求确实到达了微服务这里，微服务里调用配置的mis服务进行认证时失败，最终导致交换token失败。</p>
<p>解决：判断一下这两台服务器之间是否存在这种可能性，联系后台同事修改mis认证地址。</p>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小球绕中心点旋转效果实现原理及案例分析]]></title>
    <link href="http://yuanchao.blogs.io/16562311591649.html"/>
    <updated>2022-06-26T16:12:39+08:00</updated>
    <id>http://yuanchao.blogs.io/16562311591649.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E9%9C%80%E6%B1%82%E8%83%8C%E6%99%AF">需求背景</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">思路分析</a></li>
<li><a href="#%E5%88%86%E6%AD%A5%E5%AE%9E%E7%8E%B0">分步实现</a></li>
<li><a href="#%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8">深入探讨</a>
<ul>
<li><a href="#%E5%A4%9A%E4%B8%AA%E5%B0%8F%E7%90%83%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D">多个小球如何定位</a></li>
<li><a href="#%E5%8A%A8%E7%94%BB%E5%81%9C%E6%AD%A2%E4%B8%8E%E5%BC%80%E5%90%AF">动画停止与开启</a></li>
</ul>
</li>
<li><a href="#%E6%89%A9%E5%B1%95%E6%80%9D%E8%80%83">扩展思考</a></li>
</ul>
<h1><a id="%E9%9C%80%E6%B1%82%E8%83%8C%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求背景</h1>
<p>这两天有个住建部大屏首页导航的需求，并且要的还比较急。就是以前做过的类似的绕中心点转圈那种效果，之前虽然处理过类似的需求，但主要靠复制粘贴别人的代码实现，并未做太多思考，其中的原理和一些细节了解的并不透彻。老话说可一可二不可再三，现在差不多属于第三次接触了，不可不做一番总结。先贴几张类似的效果图出来，让开始探讨前明白我们要实现的效果。另外本篇文档的目的是让从没有做过类似需求的人也可以快速上手做出类似效果。</p>
<ol>
<li>
<p>综管服首页导航</p>
<p>地址：<a href="http://123.56.170.103:8080/eUrbanMIS0601/view/integratedServicePlatform.html">http://123.56.170.103:8080/eUrbanMIS0601/view/integratedServicePlatform.html</a></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261539331.gif" alt="2022-06-26 09.56.15" /></p>
</li>
<li>
<p>文昌综管服导航</p>
<p>地址：<a href="http://123.56.170.103:8080/eUrbanMIS0601/view/navigator-map/index.html?name=%E6%AD%A6%E6%B1%89%E5%B8%82&amp;value=420100&amp;sysName=navigator-map">http://123.56.170.103:8080/eUrbanMIS0601/view/navigator-map/index.html?name=%E6%AD%A6%E6%B1%89%E5%B8%82&amp;value=420100&amp;sysName=navigator-map</a></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261342404.gif" alt="2022-06-26 13.39.37" /></p>
</li>
<li>
<p>住建部新版首页导航</p>
<p>地址：<a href="http://ygf.mohurd.gov.cn/eUrbanMIS/zjb/index.html#/home">http://ygf.mohurd.gov.cn/eUrbanMIS/zjb/index.html#/home</a></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261523698.gif" alt="2022-06-25 22.40.37" /></p>
</li>
</ol>
<h1><a id="%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>思路分析</h1>
<p>我们采用网上出现的最多一种也是相对比较简单的一种解决方案。这里提供一篇参考<a href="https://www.jianshu.com/p/2b85973ad1ed">文章</a>，文章内容较短，可以迅速浏览一下，我们的思路和他差不多。但是比较坑的是作者有些细节没说清楚，比如说最后一步怎么将各个子元素“立”起来语焉不详，如果你真的按照他的方法去做，很有可能和我一样卡在最后一步，各导航项都扁扁的，严重变形，根本无法拿去交差。当然文档后面会给出解决办法。这里简单列一下大致思路：</p>
<ol>
<li>准备一个父容器和一个子元素（父容器就是轨道，子元素就是我们看到的小圆球），注意这里先讨论一个子元素的情况，多个子元素的情况只需均匀分布在轨道上即可。</li>
<li>将父容器沿X轴旋转80度（注意是80度不是90度，真旋转到90度父容器就看不见了）。</li>
<li>将父容器&quot;转&quot;起来，我们视觉上是小球在绕中心点转圈，但实际上是父容器在自转。</li>
<li>将子元素沿X轴反向旋转90度，这里90度是经验值，按道理反向旋转80度就能够抵消父容器的旋转效果，但实际测试发现不是特别理想，如果子元素中有文本，文本可能会歪歪斜斜。</li>
<li>将子元素自转，子元素自转动画的时长、动效函数必须与父容器的自转动画完全一致，但是转动方向与父容器刚好相反。</li>
<li>在完成前面5个步骤后，我们给父容器增加多个子元素，并且采用数学方法计算每个小球的初始坐标位置即可。</li>
</ol>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261024749.png" alt="image-20220626102409237" /></p>
<h1><a id="%E5%88%86%E6%AD%A5%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分步实现</h1>
<p>下面我们开始按步骤分解实现小球绕中心点旋转的效果。<strong>特别提醒，文档后面出现&quot;父容器&quot;、&quot;轨道&quot; 指的是一个东西。同理，子元素和小球也表示同一个东西</strong>。</p>
<ol>
<li>
<p>准备一个父容器和一个子元素，分别设置好他们的样式，便于观察效果。</p>
<p>container 是整个页面容器；</p>
<p>orbit 是轨道容器，即我们之前一直说的父容器，用于放置小球。这里要注意几个细节：</p>
<p><strong>1、父容器必须是 relative</strong>， 因为子元素将来要使用绝对布局，父容器必须设置一个定位属性；</p>
<p><strong>2、父容器必须设置 <code>transform-style: preserve-3d;</code></strong>  transform-style属性指定子元素是怎样在三维空间中呈现，preserve-3d表示所有子元素在3D空间中呈现，这一点特别重要，否则将来父容器沿X轴旋转后，子元素将无法“立”起来。</p>
<p><strong>3、子元素的初始坐标如何设置？</strong> 由于我们现在只讨论一个小球的情况，故我们假设这个小球的位置如下图所示位置，接下来用数学的方法计算其初始位置。在Web体系中 A 才是顶点(0, 0)，小球初始位置坐标为 (AB, AC)，这里只需求出AB、AC的长度即可。另外还要注意一个点，就是小球本身也是有尺寸的，因此计算初始位置时，还要减去小球自身宽高的一半作为偏移量。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261154638.png" alt="image-20220626115416627" /></p>
<p>本例中，大圆半径是 200px， 故AB距离大约是 0.3 * 200 = 60px。小球的宽高是60px，宽高的一半即为 30px，故最终计算出来小球的初始位置是：(60 - 30, 60 - 30)  ==&gt; {left: 30px, right: 30px}。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .container {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
        }

        .orbit {
            position: relative;
            width: 400px;
            height: 400px;
            border: 2px solid black;
            border-radius: 50%;
            transform-style: preserve-3d;
        }

        .ball {
            position: absolute;
            left: 30px;
            top: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            color: white;
            background: red;
        }

        .center {
            display: flex;
            align-items: center;
            justify-content: center;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container center&quot;&gt;
    &lt;!--轨道--&gt;
    &lt;div class=&quot;orbit&quot;&gt;
        &lt;!--小球--&gt;
        &lt;div class=&quot;ball center&quot;&gt;
            &lt;span class=&quot;name&quot;&gt;小球&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261203379.png" alt="image-20220626114222713" /></p>
</li>
<li>
<p>将父容器沿X轴旋转80度</p>
<pre><code class="language-css">.orbit {
    position: relative;
    width: 400px;
    height: 400px;
    border: 2px solid black;
    border-radius: 50%;
    transform-style: preserve-3d;
    transform: rotateX(80deg);
}
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261204002.png" alt="image-20220626120449388" /></p>
</li>
<li>
<p>将父容器&quot;转&quot;起来，我们视觉上是小球在绕中心点转圈，但实际上是父容器在自转。这里使用 CSS 动画，注意父容器要始终保持 rotateX: 80deg。</p>
<pre><code class="language-css">.orbit {
    position: relative;
    width: 400px;
    height: 400px;
    border: 2px solid black;
    border-radius: 50%;
    transform-style: preserve-3d;
    transform: rotateX(80deg);
    animation: orbit-rotate 10s linear infinite;
}



@keyframes orbit-rotate {
    0% {
        transform: rotateX(80deg) rotateZ(0deg);
    }

    100% {
        transform: rotateX(80deg) rotateZ(360deg);
    }
}
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261209594.gif" alt="2022-06-26 12.08.55" /></p>
</li>
<li>
<p>将子元素沿X轴反向旋转90度，这里90度是经验值，按道理反向旋转80度就能够抵消父容器的旋转效果，但实际测试发现不是特别理想，如果子元素中有文本，文本可能会歪歪斜斜。</p>
<pre><code class="language-css">.ball {
    position: absolute;
    left: 30px;
    top: 30px;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    color: white;
    background: red;
    transform: rotateX(-90deg);
}
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261229340.gif" alt="2022-06-26 12.12.12" /></p>
</li>
<li>
<p>显然小球并不是时刻正面对着我们，还需要让子元素自转起来，子元素自转动画的时长、动效函数必须与父容器的自转动画完全一致，但是转动方向与父容器刚好相反。</p>
<pre><code class="language-css">.ball {
    position: absolute;
    left: 30px;
    top: 30px;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    color: white;
    background: red;
    transform: rotateX(-90deg);
    animation: self-rotate 10s linear infinite;
}

@keyframes self-rotate {
    0% {
        transform: rotateX(-90deg) rotateY(-360deg);
    }

    100% {
        transform: rotateX(-90deg) rotateY(0deg);
    }
}
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261234481.gif" alt="2022-06-26 12.33.41" /></p>
</li>
<li>
<p>完整版示例代码</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .container {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
        }

        .orbit {
            position: relative;
            width: 400px;
            height: 400px;
            border: 2px solid black;
            border-radius: 50%;
            transform-style: preserve-3d;
            transform: rotateX(80deg);
            animation: orbit-rotate 10s linear infinite;
        }

        .ball {
            position: absolute;
            left: 30px;
            top: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            color: white;
            background: red;
            transform: rotateX(-90deg);
            animation: self-rotate 10s linear infinite;
        }

        .center {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes orbit-rotate {
            0% {
                transform: rotateX(80deg) rotateZ(0deg);
            }

            100% {
                transform: rotateX(80deg) rotateZ(360deg);
            }
        }

        @keyframes self-rotate {
            0% {
                transform: rotateX(-90deg) rotateY(-360deg);
            }

            100% {
                transform: rotateX(-90deg) rotateY(0deg);
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container center&quot;&gt;
    &lt;!--轨道--&gt;
    &lt;div class=&quot;orbit&quot;&gt;
        &lt;!--小球--&gt;
        &lt;div class=&quot;ball center&quot;&gt;
            &lt;span class=&quot;name&quot;&gt;小球1号&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ol>
<h1><a id="%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>深入探讨</h1>
<p>前面我们分步骤解析了一下小球绕中心点旋转的原理及相关细节。但是实际开发中我们经常是需要多个小球一起旋转，此时如何计算各个小球的初始坐标就显得尤为重要。此外，我们有时候还需要根据实际需求，控制动画的开始和停止。所以，只有把这两个实际需求处理到位，这个技术要点才真正变得实用起来。</p>
<h2><a id="%E5%A4%9A%E4%B8%AA%E5%B0%8F%E7%90%83%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多个小球如何定位</h2>
<p>如下所示，假设蓝色小球位于轨道上任意位置，a 是小球绕O点旋转的角度，则可以得出O1点相对于父容器顶点P的坐标：</p>
<p>{ left: (1 + Math.cos(a)) * R - W/2,   top: (1 + Math.sin(a)) * R - H/2 } 。</p>
<p>计算过程如下所示：</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261304430.png" alt="image-20220626130421387" /></p>
<p>一般来说，R 和 W 、H 我们是很容易知道的。 那么旋转角度 a 怎么得到呢？ 这就要根据小球的数量来计算了。我们的目的是让小球均匀分布在轨道上，故每2个相邻小球与O的连线形成的夹角应该是相等的，为：360deg / num。其中，num 为小球总数量。那么每个小球旋转了多少度，就很容易算出来了。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261508676.png" alt="image-20220626150835484" /></p>
<p>完整版代码实现：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .container {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
        }

        .orbit {
            position: relative;
            width: 400px;
            height: 400px;
            border: 2px solid black;
            border-radius: 50%;
            transform-style: preserve-3d;
            transform: rotateX(80deg);
            animation: orbit-rotate 10s linear infinite;
        }

        .ball {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            color: white;
            background: red;
            transform: rotateX(-90deg);
            animation: self-rotate 10s linear infinite;
        }

        .center {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes orbit-rotate {
            0% {
                transform: rotateX(80deg) rotateZ(0deg);
            }

            100% {
                transform: rotateX(80deg) rotateZ(360deg);
            }
        }

        @keyframes self-rotate {
            0% {
                transform: rotateX(-90deg) rotateY(-360deg);
            }

            100% {
                transform: rotateX(-90deg) rotateY(0deg);
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container center&quot;&gt;
    &lt;!--轨道--&gt;
    &lt;div class=&quot;orbit&quot;&gt;
        &lt;!--小球--&gt;
        &lt;div class=&quot;ball center&quot;&gt;
            &lt;span class=&quot;name&quot;&gt;小球1号&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;ball center&quot;&gt;
            &lt;span class=&quot;name&quot;&gt;小球2号&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;ball center&quot;&gt;
            &lt;span class=&quot;name&quot;&gt;小球3号&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;ball center&quot;&gt;
            &lt;span class=&quot;name&quot;&gt;小球4号&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;ball center&quot;&gt;
            &lt;span class=&quot;name&quot;&gt;小球5号&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    // 以下几个常量分别是轨道半径、小球的宽高、小球个数
    // 注意这里我们是固定死了，实际开发中可以去动态获取。
    const R = 200;
    const W = 60;
    const H = 60;
    const num = 5

    const balls = document.getElementsByClassName(&quot;ball&quot;);
    for (let i = 0; i &lt; balls.length; i++) {
        const ball = balls[i];
        ball.style.left = getPosition(num, i).left;
        ball.style.top = getPosition(num, i).top;
    }

    function getPosition(total, index) {
        let deg = index * 360 / total;
        let rad = deg * Math.PI / 180;
        // W/2、H/2 为偏移量，因为导航项小球自身也是有尺寸的
        return {
            left: ((1 + Math.cos(rad)) * R - W / 2) + &quot;px&quot;,
            top: ((1 + Math.sin(rad)) * R - H / 2) + &quot;px&quot;
        }
    }

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>轨道翻转之前的小球分布：</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261329072.png" alt="image-20220626132952402" /></p>
<p>轨道翻转之后的效果：</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261331354.gif" alt="2022-06-26 13.30.59" /></p>
<h2><a id="%E5%8A%A8%E7%94%BB%E5%81%9C%E6%AD%A2%E4%B8%8E%E5%BC%80%E5%90%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动画停止与开启</h2>
<p><strong>需求：鼠标悬浮在某个小球上时停止动画，鼠标移开时重新开始动画。</strong></p>
<p>这就需要动画是可控的，由于我们使用的是CSS动画，它的确是可以控制的，通过一个 animationPlayState 属性。它只有2个值，paused（暂停动画），running（运行动画）。鼠标悬浮于移除，可以监听 onmouseenter、onmouseleave 事件。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261433623.png" alt="image-20220626143318409" /></p>
<p>完整版代码实现：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .container {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
        }

        .orbit {
            position: relative;
            width: 400px;
            height: 400px;
            border: 2px solid black;
            border-radius: 50%;
            transform-style: preserve-3d;
            transform: rotateX(80deg);
            animation: orbit-rotate 10s linear infinite;
        }

        .ball {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            color: white;
            background: red;
            cursor: pointer;
            transform: rotateX(-90deg);
            animation: self-rotate 10s linear infinite;
        }

        .ball:hover {
            background: #c40000;
        }

        .center {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes orbit-rotate {
            0% {
                transform: rotateX(80deg) rotateZ(0deg);
            }

            100% {
                transform: rotateX(80deg) rotateZ(360deg);
            }
        }

        @keyframes self-rotate {
            0% {
                transform: rotateX(-90deg) rotateY(-360deg);
            }

            100% {
                transform: rotateX(-90deg) rotateY(0deg);
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container center&quot;&gt;
    &lt;!--轨道--&gt;
    &lt;div class=&quot;orbit&quot;&gt;
        &lt;!--小球--&gt;
        &lt;div class=&quot;ball center&quot;&gt;
            &lt;span class=&quot;name&quot;&gt;小球1号&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;ball center&quot;&gt;
            &lt;span class=&quot;name&quot;&gt;小球2号&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;ball center&quot;&gt;
            &lt;span class=&quot;name&quot;&gt;小球3号&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;ball center&quot;&gt;
            &lt;span class=&quot;name&quot;&gt;小球4号&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;ball center&quot;&gt;
            &lt;span class=&quot;name&quot;&gt;小球5号&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    // 以下几个常量分别是轨道半径、小球的宽高、小球个数
    // 注意这里我们是固定死了，实际开发中可以去动态获取。
    const R = 200;
    const W = 60;
    const H = 60;
    const num = 5;

    init();

    function init() {
        initPosition();
        initEvents();
    }

    function initPosition() {
        const balls = document.getElementsByClassName(&quot;ball&quot;);
        for (let i = 0; i &lt; balls.length; i++) {
            const ball = balls[i];
            ball.style.left = getPosition(num, i).left;
            ball.style.top = getPosition(num, i).top;
        }
    }

    function getPosition(total, index) {
        let deg = index * 360 / total;
        let rad = deg * Math.PI / 180;
        // W/2、H/2 为偏移量，因为导航项小球自身也是有尺寸的
        return {
            left: ((1 + Math.cos(rad)) * R - W / 2) + &quot;px&quot;,
            top: ((1 + Math.sin(rad)) * R - H / 2) + &quot;px&quot;
        }
    }

    function initEvents() {
        const balls = document.getElementsByClassName(&quot;ball&quot;);
        for (let i = 0; i &lt; balls.length; i++) {
            const ball = balls[i];
            ball.onmouseenter = function () {
                stopAnimation();
            }
            ball.onmouseleave = function () {
                startAnimation();
            }
        }
    }

    function startAnimation() {
        const orbit = document.getElementsByClassName(&quot;orbit&quot;)[0];
        const balls = document.getElementsByClassName(&quot;ball&quot;);
        // 开启轨道动画
        orbit.style.animationPlayState = &quot;running&quot;;
        // 开启所有小球动画
        for (let i = 0; i &lt; balls.length; i++) {
            const ball = balls[i];
            ball.style.animationPlayState = &quot;running&quot;;
        }
    }

    function stopAnimation() {
        const orbit = document.getElementsByClassName(&quot;orbit&quot;)[0];
        const balls = document.getElementsByClassName(&quot;ball&quot;);
        // 停止轨道动画
        orbit.style.animationPlayState = &quot;paused&quot;;
        // 停止所有小球动画
        for (let i = 0; i &lt; balls.length; i++) {
            const ball = balls[i];
            ball.style.animationPlayState = &quot;paused&quot;;
        }
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>效果展示：</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261447990.gif" alt="2022-06-26 14.47.12" /></p>
<h1><a id="%E6%89%A9%E5%B1%95%E6%80%9D%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展思考</h1>
<p>前面我们已经完整的实现了一版多个小球绕中心点旋转的动画效果。在它的基础上，其实还可以做一些扩展。比如：</p>
<p>1、鼠标悬浮或者点击时，当前小球改变背景、文本颜色、小图标等等。</p>
<p>2、半圆形分布，我们之前是完整的分布在轨道容器上，实际上也可以只分布在半圆上。但此时有一个要点需要<strong>格外注意：N个小球可以N等分一个完整的圆，但是N等分一个半圆，只需要N-1个小球。反过来说，每2个相邻小球的夹角为 180/num-1 ，num为小球数量。</strong></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206261522459.png" alt="image-20220626152201635" /></p>
<ol start="3">
<li>
<p>本文档使用原声js、css 实现相关功能。如果是在Vue、React等项目，可以考虑封装成一个组件。将一些变量通过组件属性传入，如：大圆的半径、子元素的宽高、子元素的文本、小图标、背景图片等等。计算初始坐标的方法是固定的，我们只要按照传入的各个属性计算出来即可，这个工作交给大家自己去完成吧。</p>
</li>
<li>
<p>如果轨道不是一个正圆而是一个椭圆，多个小球分布如何计算？其实这个问题是我当时想多了，因为当一个正圆，rotateX(80deg) 后，我们从视觉上看到的效果就已经是一个椭圆了，所以不需要将轨道设计为一个椭圆。但是为了不浪费劳动成功，我还是将椭圆上任意一点的坐标计算方法分享出来。实际上如果我们将椭圆的长半轴和短半轴设置为相同，它就变成了一个正圆，所以下面这个方法对椭圆和正圆来说是通用的。</p>
<pre><code class="language-typescript">/**
 * total: 小球的数量，index: 当前计算坐标的小球的索引，从0开始。
 * 当deg为0， 90， 180， 270 时，位置比较特殊，tan(rad) 的值也比较特殊，单独计算小球坐标即可。
 * a, b, w, h 分别为椭圆轨道长半轴、短半轴、小球的宽度、小球的高度。
 */
public getPosition(total: number, index: number) {
    let deg = index * 360 / total;
    let rad = deg * Math.PI / 180;
    let x;
    let y;
    if (deg === 0) {
        x = a;
        y = 0;
    } else if (deg === 90) {
        x = 0;
        y = b;
    } else if (deg === 180) {
        x = -a;
        y = 0;
    } else if (deg === 270) {
        x = 0;
        y = -b;
    } else if (deg &gt; 90 &amp;&amp; deg &lt; 270) {
        x = -a * b / Math.sqrt(Math.pow(b, 2) + Math.pow(a * Math.tan(rad), 2));
        y = x * Math.tan(rad); // 此时Math.tan(rad)为负值，x为负值，y 为正值
    } else {
        x = a * b / Math.sqrt(Math.pow(b, 2) + Math.pow(a * Math.tan(rad), 2));
        y = x * Math.tan(rad);
    }
    // w/2、h/2 为偏移量，因为导航项DOM自身也是有尺寸的
    return {
        left: (a + x - w / 2) + &quot;rem&quot;,
        top: (b + y - h / 2) + &quot;rem&quot;
    };
}
</code></pre>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用TS手写Promise源码实现]]></title>
    <link href="http://yuanchao.blogs.io/16556395831078.html"/>
    <updated>2022-06-19T19:53:03+08:00</updated>
    <id>http://yuanchao.blogs.io/16556395831078.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B">内容简介</a></li>
<li><a href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86">前置知识</a></li>
<li><a href="#promise-then%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0">Promise +then 初步实现</a></li>
<li><a href="#executor%E5%86%85%E9%83%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">executor内部异常处理</a></li>
<li><a href="#%E5%90%8C%E6%AD%A5%E7%BA%A7%E8%81%94then%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0">同步级联 then 方法实现</a></li>
<li><a href="#%E5%8D%95%E7%BA%A7%E5%BC%82%E6%AD%A5%E5%8D%95%E7%BA%A7then%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0">单级异步+单级 then 方法实现</a></li>
<li><a href="#%E5%A4%9A%E7%BA%A7%E5%BC%82%E6%AD%A5%E7%BA%A7%E8%81%94then%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">多级异步+级联 then实现方式</a>
<ul>
<li><a href="#settimeout%E5%AE%9E%E7%8E%B0">setTimeout 实现</a></li>
<li><a href="#%E4%BC%A0%E7%BB%9F%E5%AE%9E%E7%8E%B0">传统实现</a></li>
</ul>
</li>
<li><a href="#promise%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0">Promise 静态方法实现</a>
<ul>
<li><a href="#all%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0">all 方法实现</a></li>
<li><a href="#race%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0">race 方法实现</a></li>
<li><a href="#all%E3%80%81race%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B">all、race测试用例</a></li>
<li><a href="#%E5%85%B6%E5%AE%83%E7%AD%89%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0">其它等静态方法实现</a></li>
</ul>
</li>
<li><a href="#catch%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84">catch方法实现及代码重构</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E">相关说明</a></li>
</ul>
<h1><a id="%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内容简介</h1>
<blockquote>
<p>源码地址：<a href="https://gitee.com/Allen_2017/ts-promise">https://gitee.com/Allen_2017/ts-promise</a></p>
</blockquote>
<ol>
<li>Promise 的三种状态和注意细节；</li>
<li>Promise 第一步—— Promise 回调 +then 初步实现</li>
<li>resolve 方法执行失败后的处理</li>
<li>同步级联 then 方法实现</li>
<li>实现单级异步+单级 then 方法</li>
<li>实现单级异步+级联 then 方法</li>
<li>实现多级异步+级联 then （第一种实现方式）</li>
<li>实现多级异步+级联 then （ 第二种实现方式）</li>
<li>Promise静态方法实现(all, race, resolve, reject 等)</li>
</ol>
<h1><a id="promise%E5%9F%BA%E7%A1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise基础</h1>
<blockquote>
<p>参考资料：<a href="https://note.youdao.com/s/PTWkebtw">https://note.youdao.com/s/PTWkebtw</a></p>
</blockquote>
<p><strong>promise的三种状态</strong>：pending ，resolve，reject 。pending 就是 等待，resolve可以理解为成功，reject 可以理解为拒绝</p>
<p><strong>pending状态理解</strong>： pending状态下，可能执行 resolve方法，也可能执行 reject方法。 但在执行 resolve 或 reject前 为 pending 状态。</p>
<p><strong>resolve状态理解</strong>：代表成功态，执行 resolve方法后的状态。</p>
<p><strong>reject状态理解</strong>：代表失败态，执行 reject方法后的状态。</p>
<p><strong>状态特性</strong>：一旦成功了就不能失败，反过来也是一样。</p>
<p><strong>then方法</strong>： 每个 promsie 都有一个 then 方法。</p>
<p><strong>其他也执行 reject 的 场景：</strong> 正在执行 resolve 方法报错了，也进入 reject 失败状态。</p>
<h1><a id="promise-then%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise +then 初步实现</h1>
<p><strong>重点知识：</strong>  1. 实现 actiontype    2.  Promise 回调实现   3. 测试类实现</p>
<p><strong>1. 添加Promise相关类型</strong></p>
<pre><code class="language-typescript">export type ResolveType = (value: any) =&gt; void;

export type RejectType = (value: any) =&gt; void;

export type Executor = (resolve: ResolveType, reject: RejectType) =&gt; void;

// Promise的3种状态
export enum Status {
    PENDING = &quot;pending&quot;,
    FULLFILLED = &quot;fullfilled&quot;,
    REJECTED = &quot;rejected&quot;,
}

</code></pre>
<p><strong>2.  Promise 回调实现</strong></p>
<pre><code class="language-typescript">import {ResolveType, RejectType, Executor, Status} from &quot;../types&quot;;

class Promise {
    public resolve!: ResolveType;
    public reject!: RejectType;
    public status!: string;
    public resolveValue!: any;
    public rejectValue!: any;

    constructor(executor: Executor) {
        this.status = Status.PENDING;
        this.resolve = (value) =&gt; {
            if (this.status === Status.PENDING) {
                console.log(&quot;成功了!&quot;);
                this.status = Status.FULLFILLED;
                this.resolveValue = value;
            }
        };
        this.reject = (value) =&gt; {
            if (this.status === Status.PENDING) {
                console.log(&quot;失败了!&quot;);
                this.status = Status.REJECTED;
                this.rejectValue = value;
            }
        };
        executor(this.resolve, this.reject);
    }

    then(resolveFn: ResolveType, rejectFn: RejectType): void {
        if (this.status === Status.FULLFILLED) {
            resolveFn(this.resolveValue);
        }
        if (this.status === Status.REJECTED) {
            resolveFn(this.rejectValue);
        }
    }
}


export default Promise;
</code></pre>
<p><strong>3. 测试类实现</strong></p>
<pre><code class="language-typescript">import Promise from &quot;../promise&quot;;

// 注意：此时还没涉及到异步，完全是纯同步执行的。
let promise = new Promise((resolve, reject) =&gt; {
    resolve(&quot;成功了！&quot;);
    // reject(&quot;失败了！&quot;);
});

promise.then((resolveData) =&gt; {
    console.log(&quot;resolveData:&quot;, resolveData);
}, (rejectData) =&gt; {
    console.log(&quot;rejectData:&quot;, rejectData);
});

export {}
</code></pre>
<h1><a id="executor%E5%86%85%E9%83%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>executor内部异常处理</h1>
<pre><code class="language-typescript">// 例如：executor 执行器函数内部调用 resolve 传递的参数是字符串，但是resolve 函数内部却故意当做数组使用。
let promise = new Promise((resolve, reject) =&gt; {
    resolve(&quot;成功了！&quot;);
    // reject(&quot;失败了！&quot;);
});

//-----------------------------------------------------------------------------------------------------
import {ResolveType, RejectType, Executor, Status} from &quot;../types&quot;;

class Promise {
    public resolve!: ResolveType;
    public reject!: RejectType;
    public status!: string;
    public resolveValue!: any;
    public rejectValue!: any;

    constructor(executor: Executor) {
        this.status = Status.PENDING;
        this.resolve = (value) =&gt; {
            // value 故意当做数组使用，编译时不会报错，因为 value 是any类型，但是运行时会报错，因为外部传入的是字符串。
            value[1] = 100;
            if (this.status === Status.PENDING) {
                console.log(&quot;成功了!&quot;);
                this.status = Status.FULLFILLED;
                this.resolveValue = value;
            }
        };
        this.reject = (value) =&gt; {
            if (this.status === Status.PENDING) {
                console.log(&quot;失败了!&quot;);
                this.status = Status.REJECTED;
                this.rejectValue = value;
            }
        };

        try {
            executor(this.resolve, this.reject);
        } catch (err) {
            // 必须修改状态，否则后面的 this.reject()不会执行.
            this.status = Status.PENDING;
            this.reject(&quot;executor执行出错!&quot;);
            throw new Error(&quot;程序终止!&quot;);
        }
    }

    then(resolveFn: ResolveType, rejectFn: RejectType): void {
        if (this.status === Status.FULLFILLED) {
            resolveFn(this.resolveValue);
        }
        if (this.status === Status.REJECTED) {
            resolveFn(this.rejectValue);
        }
    }
}


export default Promise;
</code></pre>
<h1><a id="%E5%90%8C%E6%AD%A5%E7%BA%A7%E8%81%94then%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>同步级联 then 方法实现</h1>
<ol>
<li>
<p><strong>修改type文件【返回值any】</strong></p>
<pre><code class="language-typescript">export type ResolveType = (value: any) =&gt; any;

export type RejectType = (value: any) =&gt; any;

export type Executor = (resolve: ResolveType, reject: RejectType) =&gt; any;

// Promise的3种状态
export enum Status {
    PENDING = &quot;pending&quot;,
    FULLFILLED = &quot;fullfilled&quot;,
    REJECTED = &quot;rejected&quot;,
}
</code></pre>
</li>
<li>
<p><strong>修改 Promise 类</strong></p>
<p>then 方法返回值类型修改为 Promise 类型，这样就可以使用链式调用 promise.then().then()...。</p>
<pre><code class="language-typescript">import {ResolveType, RejectType, Executor, Status} from &quot;../types&quot;;

class Promise {
    public resolve!: ResolveType;
    public reject!: RejectType;
    public status!: string;
    public resolveValue!: any;
    public rejectValue!: any;

    constructor(executor: Executor) {
        this.status = Status.PENDING;
        this.resolve = (value) =&gt; {
            if (this.status === Status.PENDING) {
                this.status = Status.FULLFILLED;
                this.resolveValue = value;
            }
        };
        this.reject = (value) =&gt; {
            if (this.status === Status.PENDING) {
                this.status = Status.REJECTED;
                this.rejectValue = value;
            }
        };

        try {
            executor(this.resolve, this.reject);
        } catch (err) {
            // 必须修改状态，否则后面的 this.reject()不会执行.
            this.status = Status.PENDING;
            this.reject(&quot;executor执行出错!&quot;);
            throw new Error(&quot;程序终止!&quot;);
        }
    }

    // then()返回值为Promise类型
    then(resolveFn: ResolveType, rejectFn: RejectType): Promise {
        return new Promise((resolve, reject) =&gt; {
            let result;
            if (this.status === Status.FULLFILLED) {
                result = resolveFn(this.resolveValue);
                resolve(result);
            }
            if (this.status === Status.REJECTED) {
                result = resolveFn(this.rejectValue);
                reject(result);
            }
        })
    }
}


export default Promise;
</code></pre>
</li>
<li>
<p><strong>修改测试类</strong></p>
<pre><code class="language-typescript">import Promise from &quot;../promise&quot;;

let promise = new Promise((resolve, reject) =&gt; {
    resolve(&quot;成功了！&quot;);
    // reject(&quot;失败了！&quot;);
});

promise.then((resolveData1) =&gt; {
    console.log(&quot;第1个then执行成功:&quot;, resolveData1);
    return &quot;ok1&quot;;
}, (rejectData1) =&gt; {
    console.log(&quot;第1个then执行失败:&quot;, rejectData1);
    return &quot;failed1&quot;;
}).then((resolveData2) =&gt; {
    console.log(&quot;第2个then执行成功:&quot;, resolveData2);
    return &quot;ok2&quot;;
}, (rejectData2) =&gt; {
    console.log(&quot;第2个then执行失败:&quot;, rejectData2);
    return &quot;failed2&quot;;
}).then((resolveData3) =&gt; {
    console.log(&quot;第3个then执行成功:&quot;, resolveData3);
}, (rejectData3) =&gt; {
    console.log(&quot;第3个then执行失败:&quot;, rejectData3);
})

export {}
</code></pre>
</li>
</ol>
<h1><a id="%E5%8D%95%E7%BA%A7%E5%BC%82%E6%AD%A5%E5%8D%95%E7%BA%A7then%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单级异步+单级 then 方法实现</h1>
<p><strong>1. Promise 类</strong></p>
<pre><code class="language-typescript">import {ResolveType, RejectType, Executor, Status, Fn} from &quot;../types&quot;;

class Promise {
    public resolve!: ResolveType;
    public reject!: RejectType;
    public status!: string;
    public resolveValue!: any;
    public rejectValue!: any;
    // 保存成功状态要执行的函数
    public resolveCallbacks: Array&lt;Fn&gt; = [];
    // 保存失败状态要执行的函数
    public rejectCallbacks: Array&lt;Fn&gt; = [];

    constructor(executor: Executor) {
        this.status = Status.PENDING;
        this.resolve = (value) =&gt; {
            if (this.status === Status.PENDING) {
                this.status = Status.FULLFILLED;
                this.resolveValue = value;
                // 执行回调函数，此时 this.resolveValue 已经有值
                this.resolveCallbacks.forEach(callback =&gt; callback());
            }
        };
        this.reject = (value) =&gt; {
            if (this.status === Status.PENDING) {
                this.status = Status.REJECTED;
                this.rejectValue = value;
                // 执行回调函数，此时 this.rejectValue 已经有值
                this.rejectCallbacks.forEach(callback =&gt; callback());
            }
        };

        try {
            executor(this.resolve, this.reject);
        } catch (err) {
            // 必须修改状态，否则后面的 this.reject()不会执行.
            this.status = Status.PENDING;
            this.reject(&quot;executor执行出错!&quot;);
            throw new Error(&quot;程序终止!&quot;);
        }
    }

    then(resolveFn: ResolveType, rejectFn: RejectType): Promise {
        return new Promise((resolve, reject) =&gt; {
            let result;
            if (this.status === Status.FULLFILLED) {
                result = resolveFn(this.resolveValue);
                resolve(result);
            } else if (this.status === Status.REJECTED) {
                result = rejectFn(this.rejectValue);
                reject(result);
            } else { //pending状态下先不执行回调函数，而是保存起来
                //注意：resolveFn来自于上一个promise.then()传递过来的参数，而resolve则来自本new Promise()里的executor执行器的参数.
                // 那executor的参数resolve哪来的呢？在 Promise 类的构造函数中创建的. 同样的道理对于 rejectFn 和 reject。
                this.resolveCallbacks.push(() =&gt; {
                    result = resolveFn(this.resolveValue);
                    resolve(result);
                });
                this.rejectCallbacks.push(() =&gt; {
                    result = rejectFn(this.rejectValue);
                    reject(result);
                });
            }
        })
    }
}


export default Promise;
</code></pre>
<p><strong>2. 修改测试类</strong></p>
<pre><code class="language-typescript">import Promise from &quot;../promise&quot;;

let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve(&quot;成功了！&quot;);
        // reject(&quot;失败了！&quot;);
    }, 1000)
});

// 1.promise 的 xxxCallbacks 里保存的是第 then1() 返回的Promise对象的executor中的回调函数, xxxCallbacks.length = 1;
// 2.then1 的 xxxCallbacks 里保存的是 then2() 返回的Promise对象的executor中的回调函数, xxxCallbacks.length = 1;
// 3.then2 的 xxxCallbacks 里保存的是 then3() 返回的Promise对象的executor中的回调函数, xxxCallbacks.length = 1;
// 4.then3 的 xxxCallbacks 是空的, xxxCallbacks.length = 0;
promise.then((resolveData1) =&gt; {
    console.log(&quot;第1个then执行成功:&quot;, resolveData1);
    return &quot;ok1&quot;;
}, (rejectData1) =&gt; {
    console.log(&quot;第1个then执行失败:&quot;, rejectData1);
    return &quot;failed1&quot;;
}).then((resolveData2) =&gt; {
    console.log(&quot;第2个then执行成功:&quot;, resolveData2);
    return &quot;ok2&quot;;
}, (rejectData2) =&gt; {
    console.log(&quot;第2个then执行失败:&quot;, rejectData2);
    return &quot;failed2&quot;;
}).then((resolveData3) =&gt; {
    console.log(&quot;第3个then执行成功:&quot;, resolveData3);
}, (rejectData3) =&gt; {
    console.log(&quot;第3个then执行失败:&quot;, rejectData3);
})

export {}
</code></pre>
<h1><a id="%E5%A4%9A%E7%BA%A7%E5%BC%82%E6%AD%A5%E7%BA%A7%E8%81%94then%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多级异步+级联 then实现方式</h1>
<p>本节实现  1. 升级 Promise 类 实现多级异步+级联 then    2. 修改测试类</p>
<h2><a id="settimeout%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>setTimeout 实现</h2>
<p>实现方式一：setTimeout 方式，这种方式很好理解，但是有缺陷，因为setTimeout 的延时时长不好确定，但必须要大于等于then里边的Promise里的异步操作执行的时间，这样 result.resolveValue、result.rejectValue 才有值。</p>
<p><strong>1. 升级Promise类</strong></p>
<p>将 then 方法中 else 分支的逻辑封装一个 processPending 方法，让 then 方法变得清爽一些。</p>
<pre><code class="language-typescript">import {ResolveType, RejectType, Executor, Status, Fn} from &quot;../types&quot;;

class Promise&lt;T = any&gt; {
    public resolve!: ResolveType;
    public reject!: RejectType;
    public status!: string;
    public resolveValue!: any;
    public rejectValue!: any;
    // 保存成功状态要执行的函数
    public resolveCallbacks: Array&lt;Fn&gt; = [];
    // 保存失败状态要执行的函数
    public rejectCallbacks: Array&lt;Fn&gt; = [];

    constructor(executor: Executor) {
        this.status = Status.PENDING;
        this.resolve = (value) =&gt; {
            if (this.status === Status.PENDING) {
                this.status = Status.FULLFILLED;
                this.resolveValue = value;
                // 执行回调函数，此时 this.resolveValue 已经有值
                this.resolveCallbacks.forEach(callback =&gt; callback());
            }
        };
        this.reject = (value) =&gt; {
            if (this.status === Status.PENDING) {
                this.status = Status.REJECTED;
                this.rejectValue = value;
                // 执行回调函数，此时 this.rejectValue 已经有值
                this.rejectCallbacks.forEach(callback =&gt; callback());
            }
        };

        try {
            executor(this.resolve, this.reject);
        } catch (err) {
            // 必须修改状态，否则后面的 this.reject()不会执行.
            this.status = Status.PENDING;
            this.reject(&quot;executor执行出错!&quot;);
            throw new Error(&quot;程序终止!&quot;);
        }
    }

    then(resolveFn: ResolveType, rejectFn: RejectType): Promise {
        return new Promise((resolve, reject) =&gt; {
            let result;
            if (this.status === Status.FULLFILLED) {
                result = resolveFn(this.resolveValue);
                resolve(result);
            } else if (this.status === Status.REJECTED) {
                result = rejectFn(this.rejectValue);
                reject(result);
            } else {
                //pending状态下先不执行回调函数，而是保存起来
                this.processPending(resolveFn, rejectFn, resolve, reject);
            }
        })
    }

    processPending(resolveFn: ResolveType, rejectFn: RejectType, resolve: ResolveType, reject: RejectType) {
        let result: any;
        //注意：resolveFn来自于上一个promise.then()传递过来的参数，而resolve则来自本new Promise()里的executor执行器的参数.
        // 那executor的参数resolve哪来的呢？在 Promise 类的构造函数中创建的. 同样的道理对于 rejectFn 和 reject。
        this.resolveCallbacks.push(() =&gt; {
            result = resolveFn(this.resolveValue);
            if (isPromise(result)) {
                // 由于result这个promise里执行的也是异步操作，故直接拿不到result.resolveValue，需要等异步操作执行完后
                // result.resolveValue才有值，所以这里也使用一个 setTimeout 等待一下。
                setTimeout(() =&gt; {
                    resolve(result.resolveValue);
                }, 1000);
            } else {
                resolve(result);
            }
        });
        this.rejectCallbacks.push(() =&gt; {
            result = rejectFn(this.rejectValue);
            if (isPromise(result)) {
                setTimeout(() =&gt; {
                    reject(result.rejectValue);
                }, 1000);
            } else {
                reject(result);
            }
        });
    }
}

function isObject(val: any): val is Record&lt;any, any&gt; {
    return val &amp;&amp; typeof val === &quot;object&quot;;
}

function isFunction(val: any): val is Function {
    return val &amp;&amp; typeof val === &quot;function&quot;;
}

function isPromise(val: any): val is Promise {
    return isObject(val) &amp;&amp; isFunction(val.then);
}

export default Promise;
</code></pre>
<p><strong>2. 修改测试类</strong></p>
<pre><code class="language-typescript">import Promise from &quot;../promise&quot;;

let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve(&quot;成功了！&quot;);
        // reject(&quot;失败了！&quot;);
    }, 1000)
});

// 1.promise 的 xxxCallbacks 里保存的是 then1() 返回的Promise对象的executor中的回调函数, xxxCallbacks.length = 1;
// 2.then1 的 xxxCallbacks 里保存的是 then2() 返回的Promise对象的executor中的回调函数, xxxCallbacks.length = 1;
// 3.then2 的 xxxCallbacks 里保存的是 then3() 返回的Promise对象的executor中的回调函数, xxxCallbacks.length = 1;
// 4.then3 的 xxxCallbacks 是空的, xxxCallbacks.length = 0;
// promise.then((resolveData1) =&gt; {
//     console.log(&quot;第1个then执行成功:&quot;, resolveData1);
//     return &quot;ok1&quot;;
// }, (rejectData1) =&gt; {
//     console.log(&quot;第1个then执行失败:&quot;, rejectData1);
//     return &quot;failed1&quot;;
// }).then((resolveData2) =&gt; {
//     console.log(&quot;第2个then执行成功:&quot;, resolveData2);
//     return &quot;ok2&quot;;
// }, (rejectData2) =&gt; {
//     console.log(&quot;第2个then执行失败:&quot;, rejectData2);
//     return &quot;failed2&quot;;
// }).then((resolveData3) =&gt; {
//     console.log(&quot;第3个then执行成功:&quot;, resolveData3);
// }, (rejectData3) =&gt; {
//     console.log(&quot;第3个then执行失败:&quot;, rejectData3);
// })


promise.then((resolveData1) =&gt; {
    console.log(&quot;第1个then执行成功:&quot;, resolveData1);
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve(&quot;第二个异步操作执行成功!&quot;);
        }, 1000);
    });
}, (rejectData1) =&gt; {
    console.log(&quot;第1个then执行失败:&quot;, rejectData1);
    return &quot;failed1&quot;;
}).then((resolveData2) =&gt; {
    console.log(&quot;第2个then执行成功:&quot;, resolveData2);
    return &quot;ok2&quot;;
}, (rejectData2) =&gt; {
    console.log(&quot;第2个then执行失败:&quot;, rejectData2);
    return &quot;failed2&quot;;
}).then((resolveData3) =&gt; {
    console.log(&quot;第3个then执行成功:&quot;, resolveData3);
}, (rejectData3) =&gt; {
    console.log(&quot;第3个then执行失败:&quot;, rejectData3);
})

export {}
</code></pre>
<h2><a id="%E4%BC%A0%E7%BB%9F%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>传统实现</h2>
<p><strong>实现方式二：正统方式，可以完美避免实现方式一的缺陷，但是理解起来费劲一些。</strong></p>
<p><strong>1 升级 Promise 类</strong></p>
<p>将 then 方法重构，抽出 processResolve、processReject 等方法。</p>
<pre><code class="language-typescript">import {ResolveType, RejectType, Executor, Status, Fn} from &quot;../types&quot;;

class Promise&lt;T = any&gt; {
    public resolve!: ResolveType;
    public reject!: RejectType;
    public status!: string;
    public resolveValue!: any;
    public rejectValue!: any;
    // 保存成功状态要执行的函数
    public resolveCallbacks: Array&lt;Fn&gt; = [];
    // 保存失败状态要执行的函数
    public rejectCallbacks: Array&lt;Fn&gt; = [];

    constructor(executor: Executor) {
        this.status = Status.PENDING;
        this.resolve = (value) =&gt; {
            if (this.status === Status.PENDING) {
                this.status = Status.FULLFILLED;
                this.resolveValue = value;
                // 执行回调函数，此时 this.resolveValue 已经有值
                this.resolveCallbacks.forEach(callback =&gt; callback());
            }
        };
        this.reject = (value) =&gt; {
            if (this.status === Status.PENDING) {
                this.status = Status.REJECTED;
                this.rejectValue = value;
                // 执行回调函数，此时 this.rejectValue 已经有值
                this.rejectCallbacks.forEach(callback =&gt; callback());
            }
        };

        try {
            executor(this.resolve, this.reject);
        } catch (err) {
            // 必须修改状态，否则后面的 this.reject()不会执行.
            this.status = Status.PENDING;
            this.reject(&quot;executor执行出错!&quot;);
            throw new Error(&quot;程序终止!&quot;);
        }
    }

    then(resolveFn: ResolveType, rejectFn: RejectType): Promise {
        return new Promise((resolve, reject) =&gt; {
            let result;
            if (this.status === Status.FULLFILLED) {
                this.processResolve(resolveFn, resolve, reject);
            } else if (this.status === Status.REJECTED) {
                this.processReject(rejectFn, resolve, reject);
            } else {
                //pending状态下先不执行then的回调函数，而是保存起来.
                this.resolveCallbacks.push(() =&gt; {
                    this.processResolve(resolveFn, resolve, reject);
                });
                this.rejectCallbacks.push(() =&gt; {
                    this.processReject(rejectFn, resolve, reject);
                });
            }
        })
    }

    processResolve(resolveFn: ResolveType, resolve: ResolveType, reject: RejectType) {
        let result: any;
        //注意：resolveFn来自于上一个promise.then()传递过来的参数，而resolve、reject则来自本new Promise()里的executor执行器的参数.
        // 那executor的参数resolve、reject哪来的呢？在 Promise 类的构造函数中创建的。
        result = resolveFn(this.resolveValue);
        if (isPromise(result)) {
            // 由于result这个promise里执行的也是异步操作，故直接拿不到result.resolveValue，需要等异步操作执行完后result.resolveValue才有值，
            // 也就是在result.then()里才能拿到值。
            result.then((resolveData) =&gt; {
                resolve(resolveData);
            }, (rejectData) =&gt; {
                reject(rejectData);
            });
        } else {
            resolve(result);
        }
    }

    processReject(rejectFn: RejectType, resolve: ResolveType, reject: RejectType) {
        let result: any;
        //注意：rejectFn来自于上一个promise.then()传递过来的参数，而resolve、reject则来自本new Promise()里的executor执行器的参数.
        // 那executor的参数resolve、reject哪来的呢？在 Promise 类的构造函数中创建的。
        result = rejectFn(this.rejectValue);
        if (isPromise(result)) {
            // 由于result这个promise里执行的也是异步操作，故直接拿不到result.rejectValue，需要等异步操作执行完后result.rejectValue才有值，
            // 也就是在result.then()里才能拿到值。
            result.then((resolveData) =&gt; {
                resolve(resolveData);
            }, (rejectData) =&gt; {
                reject(rejectData);
            });
        } else {
            reject(result);
        }
    }
}

function isObject(val: any): val is Record&lt;any, any&gt; {
    return val &amp;&amp; typeof val === &quot;object&quot;;
}

function isFunction(val: any): val is Function {
    return val &amp;&amp; typeof val === &quot;function&quot;;
}

function isPromise(val: any): val is Promise {
    return isObject(val) &amp;&amp; isFunction(val.then);
}

export default Promise;
</code></pre>
<p><strong>2. 修改测试类</strong></p>
<pre><code class="language-typescript">import Promise from &quot;../promise&quot;;

let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve(&quot;成功了！&quot;);
        // reject(&quot;失败了！&quot;);
    }, 1000);
    // 同步，实际开发中这种情况很少，Promise设计的初衷就是用来处理异步的.
    // resolve(&quot;成功了！&quot;);
    // reject(&quot;失败了！&quot;);
});

// 1.promise 的 xxxCallbacks 里保存的是 then1() 返回的Promise对象的executor中的回调函数, xxxCallbacks.length = 1;
// 2.then1 的 xxxCallbacks 里保存的是 then2() 返回的Promise对象的executor中的回调函数, xxxCallbacks.length = 1;
// 3.then2 的 xxxCallbacks 里保存的是 then3() 返回的Promise对象的executor中的回调函数, xxxCallbacks.length = 1;
// 4.then3 的 xxxCallbacks 是空的, xxxCallbacks.length = 0;
// promise.then((resolveData1) =&gt; {
//     console.log(&quot;第1个then执行成功:&quot;, resolveData1);
//     return &quot;ok1&quot;;
// }, (rejectData1) =&gt; {
//     console.log(&quot;第1个then执行失败:&quot;, rejectData1);
//     return &quot;failed1&quot;;
// }).then((resolveData2) =&gt; {
//     console.log(&quot;第2个then执行成功:&quot;, resolveData2);
//     return &quot;ok2&quot;;
// }, (rejectData2) =&gt; {
//     console.log(&quot;第2个then执行失败:&quot;, rejectData2);
//     return &quot;failed2&quot;;
// }).then((resolveData3) =&gt; {
//     console.log(&quot;第3个then执行成功:&quot;, resolveData3);
// }, (rejectData3) =&gt; {
//     console.log(&quot;第3个then执行失败:&quot;, rejectData3);
// })


promise.then((resolveData1) =&gt; {
    console.log(&quot;第1个then执行成功:&quot;, resolveData1);
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve(&quot;第二个异步操作执行成功!&quot;);
            // reject(&quot;第二个异步操作执行失败!&quot;);
        }, 1000);
    });
}, (rejectData1) =&gt; {
    console.log(&quot;第1个then执行失败:&quot;, rejectData1);
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve(&quot;第二个异步操作执行成功!&quot;);
            // reject(&quot;第二个异步操作执行失败!&quot;);
        }, 1000);
    });
}).then((resolveData2) =&gt; {
    console.log(&quot;第2个then执行成功:&quot;, resolveData2);
    return &quot;ok2&quot;;
}, (rejectData2) =&gt; {
    console.log(&quot;第2个then执行失败:&quot;, rejectData2);
    return &quot;failed2&quot;;
}).then((resolveData3) =&gt; {
    console.log(&quot;第3个then执行成功:&quot;, resolveData3);
}, (rejectData3) =&gt; {
    console.log(&quot;第3个then执行失败:&quot;, rejectData3);
})

export {}
</code></pre>
<h1><a id="promise%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise 静态方法实现</h1>
<h2><a id="all%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>all 方法实现</h2>
<p>思路：将 al l方法参数 promises 的所有 promise 挨个去 .then 一下，拿到执行结果保存到一个数组 successResults 里。遍历过程中当最后一个 promise 执行成功后，才将当前 promise resolve 掉，遍历过程中只要有一个 promise 失败，则直接将当前 promise reject掉。</p>
<pre><code class="language-typescript">static all(promises: Promise[]) {
    return new Promise((resolve, reject) =&gt; {
        let successResults: Array&lt;any&gt; = [];
        for (let i = 0; i &lt; promises.length; i++) {
            // 使用立即执行函数解决i的问题
            (function (index: number) {
                let promise = promises[index];
                promise.then((resolveData) =&gt; {
                    successResults[index] = resolveData;
                    // 最后一个执行完毕，才resolve出去.
                    if (index === promises.length - 1) {
                        resolve(successResults);
                    }
                }, (rejectData) =&gt; {
                    // 1个失败则全部失败
                    console.log(`第${index + 1}个promise执行失败，导致Promise.all执行失败!`);
                    reject(rejectData);
                });
            })(i)
        }
    })
}
</code></pre>
<h2><a id="race%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>race 方法实现</h2>
<p>思路：与 al l 类似，同样是挨个遍历 promises，不同的是 race 方法是只要有一个 promise 状态发生变化，就直接结束当前 promise （修改当前 promise 状态），这就需要设置一个状态变量 finished ，当 promises 中任意一个 promise 状态发生改变时，就修改此状态变量的值，并且把结果返回出去。</p>
<pre><code class="language-typescript">static race(promises: Promise[]) {
    return new Promise((resolve, reject) =&gt; {
        let finished: boolean = false;
        for (let i = 0; i &lt; promises.length; i++) {
            // 使用立即执行函数解决i的问题
            (function (index: number) {
                let promise = promises[index];
                promise.then((resolveData) =&gt; {
                    if (!finished) {
                        console.log(`第${index + 1}个promise率先改变状态，Promise.race执行完毕!`);
                        resolve(resolveData);
                        finished = true;
                    }
                }, (rejectData) =&gt; {
                    if (!finished) {
                        console.log(`第${index + 1}个promise率先改变状态，Promise.race执行完毕!`);
                        reject(rejectData);
                        finished = true;
                    }
                });
            })(i)
        }
    })
}
</code></pre>
<h2><a id="all%E3%80%81race%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>all、race测试用例</h2>
<pre><code class="language-typescript">import Promise from &quot;../promise&quot;;


// 用于测试Promise.all 和 Promise.race
let promise1 = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve(&quot;第1个异步操作成功了！&quot;);
    }, 1000);
});

let promise2 = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve(&quot;第2个异步操作成功了！&quot;);
        // reject(&quot;第2个异步操作失败了！&quot;);
    }, 1000);
});

let promise3 = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve(&quot;第3个异步操作成功了！&quot;);
    }, 1000);
});

// all: [p1,p2,p3] 全部成功才算成功，一个失败全部失败。成功的结果：全部执行成功的结果数组；失败结果：执行失败的那个结果
// Promise.all([promise1, promise2, promise3]).then((resolveData) =&gt; {
//     console.log(`resolveData: `, resolveData);
// }, (rejectData) =&gt; {
//     console.log(`rejectData: `, rejectData);
// });

// race: [p1,p2,p3] 有1个promise率先改变状态race执行完毕，then()的结果取决于这个率先改变状态的promise，可以是成功的也可以是失败的。
Promise.race([promise1, promise2, promise3]).then((resolveData) =&gt; {
    console.log(`resolveData: `, resolveData);
}, (rejectData) =&gt; {
    console.log(`rejectData: `, rejectData);
});

export {}
</code></pre>
<h2><a id="%E5%85%B6%E5%AE%83%E7%AD%89%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其它等静态方法实现</h2>
<p>主要包括：resolve、reject。</p>
<p><strong>1. 升级Promise类</strong></p>
<pre><code class="language-typescript">import {ResolveType, RejectType, Executor, Status, Fn} from &quot;../types&quot;;

class Promise&lt;T = any&gt; {
    public resolve!: ResolveType;
    public reject!: RejectType;
    public status!: string;
    public resolveValue!: any;
    public rejectValue!: any;
    // 保存成功状态要执行的函数
    public resolveCallbacks: Array&lt;Fn&gt; = [];
    // 保存失败状态要执行的函数
    public rejectCallbacks: Array&lt;Fn&gt; = [];

    constructor(executor: Executor) {
        this.status = Status.PENDING;
        this.resolve = (value) =&gt; {
            if (this.status === Status.PENDING) {
                this.status = Status.FULLFILLED;
                this.resolveValue = value;
                // 执行回调函数，此时 this.resolveValue 已经有值
                this.resolveCallbacks.forEach(callback =&gt; callback());
            }
        };
        this.reject = (value) =&gt; {
            if (this.status === Status.PENDING) {
                this.status = Status.REJECTED;
                this.rejectValue = value;
                // 执行回调函数，此时 this.rejectValue 已经有值
                this.rejectCallbacks.forEach(callback =&gt; callback());
            }
        };

        try {
            executor(this.resolve, this.reject);
        } catch (err: any) {
            // 必须修改状态，否则后面的 this.reject()不会执行.
            this.status = Status.PENDING;
            this.reject(&quot;executor执行出错!&quot;);
            throw new Error(&quot;程序终止!&quot;);
        }
    }

    then(resolveFn?: ResolveType, rejectFn?: RejectType): Promise {
        return new Promise((resolve, reject) =&gt; {
            if (this.status === Status.FULLFILLED) {
                this.processResolve(resolveFn, resolve, reject);
            } else if (this.status === Status.REJECTED) {
                this.processReject(rejectFn, resolve, reject);
            } else {
                //pending状态下先不执行then的回调函数，而是保存起来.
                this.resolveCallbacks.push(() =&gt; {
                    this.processResolve(resolveFn, resolve, reject);
                });
                this.rejectCallbacks.push(() =&gt; {
                    this.processReject(rejectFn, resolve, reject);
                });
            }
        })
    }

    catch(rejectFn: RejectType): Promise {
        return this.then(undefined, rejectFn);
    }

    processResolve(resolveFn: ResolveType | undefined, resolve: ResolveType, reject: RejectType) {
        if (isFunction(resolveFn)) {
            let result = resolveFn(this.resolveValue);
            if (isPromise(result)) {
                result.then((resolveData) =&gt; {
                    resolve(resolveData);
                }, (rejectData) =&gt; {
                    reject(rejectData);
                });
            } else {
                resolve(result);
            }
        } else {
            resolve(undefined);
        }
    }

    processReject(rejectFn: RejectType | undefined, resolve: ResolveType, reject: RejectType) {
        if (isFunction(rejectFn)) {
            let result = rejectFn(this.rejectValue);
            if (isPromise(result)) {
                result.then((resolveData) =&gt; {
                    resolve(resolveData);
                }, (rejectData) =&gt; {
                    reject(rejectData);
                });
            } else {
                reject(result);
            }
        } else {
            reject(undefined);
        }
    }

    static all(promises: Promise[]): Promise {
        return new Promise((resolve, reject) =&gt; {
            let successResults: Array&lt;any&gt; = [];
            for (let i = 0; i &lt; promises.length; i++) {
                // 使用立即执行函数解决i的问题
                (function (index: number) {
                    let promise = promises[index];
                    promise.then((resolveData) =&gt; {
                        successResults[index] = resolveData;
                        if (index === promises.length - 1) {
                            resolve(successResults);
                        }
                    }, (rejectData) =&gt; {
                        // 1个失败则全部失败
                        console.log(`第${index + 1}个promise执行失败，导致Promise.all执行失败!`);
                        reject(rejectData);
                    });
                })(i)
            }
        })
    }

    static race(promises: Promise[]): Promise {
        return new Promise((resolve, reject) =&gt; {
            let finished: boolean = false;
            for (let i = 0; i &lt; promises.length; i++) {
                // 使用立即执行函数解决i的问题
                (function (index: number) {
                    let promise = promises[index];
                    promise.then((resolveData) =&gt; {
                        if (!finished) {
                            console.log(`第${index + 1}个promise率先改变状态，Promise.race执行完毕!`);
                            resolve(resolveData);
                            finished = true;
                        }
                    }, (rejectData) =&gt; {
                        if (!finished) {
                            console.log(`第${index + 1}个promise率先改变状态，Promise.race执行完毕!`);
                            reject(rejectData);
                            finished = true;
                        }
                    });
                })(i)
            }
        })
    }

    static resolve(data: any): Promise {
        return new Promise((resolve, reject) =&gt; {
            resolve(data);
        });
    }

    static reject(data: any): Promise {
        return new Promise((resolve, reject) =&gt; {
            reject(data);
        });
    }
}

function isObject(val: any): val is Record&lt;any, any&gt; {
    return val &amp;&amp; typeof val === &quot;object&quot;;
}

function isFunction(val: any): val is Function {
    return val &amp;&amp; typeof val === &quot;function&quot;;
}

function isPromise(val: any): val is Promise {
    return isObject(val) &amp;&amp; isFunction(val.then);
}

export default Promise;
</code></pre>
<p><strong>2. 测试用例</strong></p>
<pre><code class="language-typescript">import Promise from &quot;../promise&quot;;

let promise = Promise.resolve({name: &quot;zhangsan&quot;, age: 28});
promise.then((resolveData) =&gt; {
    console.log(&quot;then执行成功:&quot;, resolveData);
}, (rejectData) =&gt; {
    console.log(&quot;then执行失败:&quot;, rejectData);
});

let promise2 = Promise.reject({name: &quot;lisi&quot;, age: 29});
promise2.then((resolveData) =&gt; {
    console.log(&quot;then执行成功:&quot;, resolveData);
}, (rejectData) =&gt; {
    console.log(&quot;then执行失败:&quot;, rejectData);
});

export {}
</code></pre>
<h1><a id="catch%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>catch方法实现及代码重构</h1>
<p>1、then方法2个参数均支持可选；2、catch方法实现（内部调用then方法）；</p>
<p><strong>1. 升级Promise类</strong></p>
<pre><code class="language-typescript">import {ResolveType, RejectType, Executor, Status, Fn} from &quot;../types&quot;;

class Promise&lt;T = any&gt; {
    public resolve!: ResolveType;
    public reject!: RejectType;
    public status!: string;
    public resolveValue!: any;
    public rejectValue!: any;
    // 保存成功状态要执行的函数
    public resolveCallbacks: Array&lt;Fn&gt; = [];
    // 保存失败状态要执行的函数
    public rejectCallbacks: Array&lt;Fn&gt; = [];

    constructor(executor: Executor) {
        this.status = Status.PENDING;
        this.resolve = (value) =&gt; {
            if (this.status === Status.PENDING) {
                this.status = Status.FULLFILLED;
                this.resolveValue = value;
                // 执行回调函数，此时 this.resolveValue 已经有值
                this.resolveCallbacks.forEach(callback =&gt; callback());
            }
        };
        this.reject = (value) =&gt; {
            if (this.status === Status.PENDING) {
                this.status = Status.REJECTED;
                this.rejectValue = value;
                // 执行回调函数，此时 this.rejectValue 已经有值
                this.rejectCallbacks.forEach(callback =&gt; callback());
            }
        };

        try {
            executor(this.resolve, this.reject);
        } catch (err: any) {
            // 必须修改状态，否则后面的 this.reject()不会执行.
            this.status = Status.PENDING;
            this.reject(&quot;executor执行出错!&quot;);
            throw new Error(&quot;程序终止!&quot;);
        }
    }

    then(resolveFn?: ResolveType, rejectFn?: RejectType): Promise {
        return new Promise((resolve, reject) =&gt; {
            if (this.status === Status.FULLFILLED) {
                this.processResolve(resolveFn, resolve, reject);
            } else if (this.status === Status.REJECTED) {
                this.processReject(rejectFn, resolve, reject);
            } else {
                //pending状态下先不执行then的回调函数，而是保存起来.
                this.resolveCallbacks.push(() =&gt; {
                    this.processResolve(resolveFn, resolve, reject);
                });
                this.rejectCallbacks.push(() =&gt; {
                    this.processReject(rejectFn, resolve, reject);
                });
            }
        })
    }

    // catch 方法其实很简单，内部直接调用 then 方法即可。
    catch(rejectFn: RejectType): Promise {
        return this.then(undefined, rejectFn);
    }

    processResolve(resolveFn: ResolveType | undefined, resolve: ResolveType, reject: RejectType) {
        if (isFunction(resolveFn)) {
            let result = resolveFn(this.resolveValue);
            if (isPromise(result)) {
                result.then((resolveData) =&gt; {
                    resolve(resolveData);
                }, (rejectData) =&gt; {
                    reject(rejectData);
                });
            } else {
                resolve(result);
            }
        } else {
            resolve(undefined);
        }
    }

    processReject(rejectFn: RejectType | undefined, resolve: ResolveType, reject: RejectType) {
        if (isFunction(rejectFn)) {
            let result = rejectFn(this.rejectValue);
            if (isPromise(result)) {
                result.then((resolveData) =&gt; {
                    resolve(resolveData);
                }, (rejectData) =&gt; {
                    reject(rejectData);
                });
            } else {
                reject(result);
            }
        } else {
            reject(undefined);
        }
    }

    static all(promises: Promise[]) {
        return new Promise((resolve, reject) =&gt; {
            let successResults: Array&lt;any&gt; = [];
            for (let i = 0; i &lt; promises.length; i++) {
                // 使用立即执行函数解决i的问题
                (function (index: number) {
                    let promise = promises[index];
                    promise.then((resolveData) =&gt; {
                        successResults[index] = resolveData;
                        if (index === promises.length - 1) {
                            resolve(successResults);
                        }
                    }, (rejectData) =&gt; {
                        // 1个失败则全部失败
                        console.log(`第${index + 1}个promise执行失败，导致Promise.all执行失败!`);
                        reject(rejectData);
                    });
                })(i)
            }
        })
    }

    static race(promises: Promise[]) {
        return new Promise((resolve, reject) =&gt; {
            let finished: boolean = false;
            for (let i = 0; i &lt; promises.length; i++) {
                // 使用立即执行函数解决i的问题
                (function (index: number) {
                    let promise = promises[index];
                    promise.then((resolveData) =&gt; {
                        if (!finished) {
                            console.log(`第${index + 1}个promise率先改变状态，Promise.race执行完毕!`);
                            resolve(resolveData);
                            finished = true;
                        }
                    }, (rejectData) =&gt; {
                        if (!finished) {
                            console.log(`第${index + 1}个promise率先改变状态，Promise.race执行完毕!`);
                            reject(rejectData);
                            finished = true;
                        }
                    });
                })(i)
            }
        })
    }
}

function isObject(val: any): val is Record&lt;any, any&gt; {
    return val &amp;&amp; typeof val === &quot;object&quot;;
}

function isFunction(val: any): val is Function {
    return val &amp;&amp; typeof val === &quot;function&quot;;
}

function isPromise(val: any): val is Promise {
    return isObject(val) &amp;&amp; isFunction(val.then);
}

export default Promise;
</code></pre>
<p><strong>2. 修改测试类</strong></p>
<pre><code class="language-typescript">import Promise from &quot;../promise&quot;;

let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve(&quot;成功了！&quot;);
        // reject(&quot;失败了！&quot;);
    }, 1000);
    // 同步，实际开发中这种情况很少，Promise设计的初衷就是用来处理异步的，但是我们框架里还是要支持同步的。
    // resolve(&quot;成功了！&quot;);
    // reject(&quot;失败了！&quot;);
});

// 用于测试catch方法
promise.then((resolveData1) =&gt; {
    console.log(&quot;第1个then执行成功:&quot;, resolveData1);
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            // resolve(&quot;第二个异步操作执行成功!&quot;);
            reject(&quot;第二个异步操作执行失败!&quot;);
        }, 1000);
    });
}, (rejectData1) =&gt; {
    console.log(&quot;第1个then执行失败:&quot;, rejectData1);
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            // resolve(&quot;第二个异步操作执行成功!&quot;);
            reject(&quot;第二个异步操作执行失败!&quot;);
        }, 1000);
    });
}).then((resolveData2) =&gt; {
    console.log(&quot;第2个then执行成功:&quot;, resolveData2);
    return &quot;ok2&quot;;
}).catch((err) =&gt; { // catch一般放到末尾，如果放到中间则作用和then是一样的.
    console.log(&quot;执行catch:&quot;, err);
    return &quot;catched&quot;
}).then((resolveData3) =&gt; {
    console.log(&quot;第3个then执行成功:&quot;, resolveData3);
}, (rejectData3) =&gt; {
    console.log(&quot;第3个then执行失败:&quot;, rejectData3);
})
</code></pre>
<h1><a id="%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相关说明</h1>
<p>原生的Promise， 当上一个Promise 对象的状态发生改变后，then、catch 的回调函数会执行，但是它是异步的，会放入到微队列中等待执行。而我们自定义的 Promise 的then、catch 的回调函数执行的时候是同步的，我查阅了一下相关资料，没找到如何模拟进入微队列，只能先这样啦！关于宏任务、微任务这里提供一些参考资料：</p>
<p><a href="https://note.youdao.com/s/AQNTvaS3">https://note.youdao.com/s/AQNTvaS3</a></p>
<p><a href="https://note.youdao.com/s/3tWGPLXT%E3%80%82">https://note.youdao.com/s/3tWGPLXT。</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vue3 源码调试流程]]></title>
    <link href="http://yuanchao.blogs.io/16549143437599.html"/>
    <updated>2022-06-11T10:25:43+08:00</updated>
    <id>http://yuanchao.blogs.io/16549143437599.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD">源码下载</a></li>
<li><a href="#%E6%BA%90%E7%A0%81%E6%89%93%E5%8C%85">源码打包</a></li>
<li><a href="#%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95">源码调试</a></li>
</ul>
<h1><a id="%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>源码下载</h1>
<ol>
<li>
<p>下载地址：<a href="https://github.com/vuejs/core">https://github.com/vuejs/core</a></p>
</li>
<li>
<p>切换 Tags 标签，选择合适的版本下载</p>
</li>
</ol>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206110920957.png" alt="image-20220611091952355" style="zoom:50%;" />
<ol start="3">
<li>安装依赖 pnpm install</li>
</ol>
<h1><a id="%E6%BA%90%E7%A0%81%E6%89%93%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>源码打包</h1>
<ol>
<li>
<p>打开根目录下的 package.json 可以看到内置的脚本</p>
<p>dev:  开发环境下打包，使用的是 esbuild 打包</p>
<p>build:  生产环境下打包，使用的是 rollup 打包</p>
<pre><code class="language-json">&quot;private&quot;: true,
  &quot;version&quot;: &quot;3.2.31&quot;,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;node scripts/dev.js&quot;,
    &quot;build&quot;: &quot;node scripts/build.js&quot;,
}
</code></pre>
</li>
<li>
<p>由于我们主要是开发环境下打包调试，故使用 dev，对应的脚本是 scripts/dev.js，如下所示，重要之处已经添加了注释。</p>
<pre><code class="language-js">// Using esbuild for faster dev builds.
// We are still using Rollup for production builds because it generates
// smaller files w/ better tree-shaking.

// @ts-check
const {build} = require('esbuild')                                            // esbuild 打包
const nodePolyfills = require('@esbuild-plugins/node-modules-polyfill')         // 补丁包（非必须）
const {resolve, relative} = require('path')
const args = require('minimist')(process.argv.slice(2))                         // minimist 解析命令行参数

// 默认为 vue，可以通过命令行传参打包指定的模块，比如：npm run dev reactivity  则只打包 reactivity 模块。
const target = args._[0] || 'vue' 

// 默认为 global，可通过修改根目录下的 package.json 指定打包格式，例如想打包 cjs 模式的包：
// &quot;dev&quot;: &quot;node scripts/dev.js -f cjs&quot;。但如果已经修改到了这里，那上一步指定模块名，也可以这里指定，命令行就无需传参数了
// &quot;dev&quot;: &quot;node scripts/dev.js reactivity -f cjs&quot;，命令行只需要执行 npm run dev 即可。
const format = args.f || 'global' 

const inlineDeps = args.i || args.inline

// 具体哪个模块下的 package.json，它里边有一个自定义属性 buildOptions，后面打包会用到。
const pkg = require(resolve(__dirname, `../packages/${target}/package.json`))

// resolve output 解析输出格式
const outputFormat = format.startsWith('global')
  ? 'iife'
  : format === 'cjs'
  ? 'cjs'
  : 'esm'

// 输出文件后缀
const postfix = format.endsWith('-runtime')
  ? `runtime.``{format.replace(/-runtime``/, '')}`
  : format

// 输出文件完整路径，例如：../packages/reactivity/dist/reactivity.global.js
const outfile = resolve(
  __dirname,
  `../packages/``{target}/dist/``{target}.${postfix}.js`
)const relativeOutfile = relative(process.cwd(), outfile)

// resolve externals
// TODO this logic is largely duplicated from rollup.config.js
let external = []
if (!inlineDeps) {
  // cjs &amp; esm-bundler: external all deps
  if (format === 'cjs' || format.includes('esm-bundler')) {
    external = [
      ...external,
      ...Object.keys(pkg.dependencies || {}),
      ...Object.keys(pkg.peerDependencies || {}),
      // for @vue/compiler-sfc / server-renderer
      'path',
      'url',
      'stream'
    ]
  }

  if (target === 'compiler-sfc') {
    const consolidateDeps = require.resolve('@vue/consolidate/package.json', {paths: [resolve(__dirname, `../packages/${target}/`)]})
    external = [
      ...external,
      ...Object.keys(require(consolidateDeps).devDependencies),
      'fs',
      'vm',
      'crypto',
      'react-dom/server',
      'teacup/lib/express',
      'arc-templates/dist/es5',
      'then-pug',
      'then-jade'
    ]
  }
}

// esbuild 打包 api
build({entryPoints: [resolve(__dirname, `../packages/${target}/src/index.ts`)],    // 入口文件
  outfile,  // 输出文件
  bundle: true,
  external,
  sourcemap: true,
  format: outputFormat,  // 打包格式
  globalName: pkg.buildOptions?.name,
  platform: format === 'cjs' ? 'node' : 'browser',
  plugins:
    format === 'cjs' || pkg.buildOptions?.enableNonBrowserBranches
      ? [nodePolyfills.default()]
      : undefined,
  // 定义一堆全局变量供项目中使用
  define: {
    __COMMIT__: `&quot;dev&quot;`,
    __VERSION__: `&quot;${pkg.version}&quot;`,
    __DEV__: `true`,
    __TEST__: `false`,
    __BROWSER__: String(format !== 'cjs' &amp;&amp; !pkg.buildOptions?.enableNonBrowserBranches),
    __GLOBAL__: String(format === 'global'),
    __ESM_BUNDLER__: String(format.includes('esm-bundler')),
    __ESM_BROWSER__: String(format.includes('esm-browser')),
    __NODE_JS__: String(format === 'cjs'),
    __SSR__: String(format === 'cjs' || format.includes('esm-bundler')),
    __COMPAT__: `false`,
    __FEATURE_SUSPENSE__: `true`,
    __FEATURE_OPTIONS_API__: `true`,
    __FEATURE_PROD_DEVTOOLS__: `false`
  },
  // 监控，修改文件后能即时响应
  watch: {onRebuild(error) {if (!error) console.log(`rebuilt: ${relativeOutfile}`)}}
}).then(() =&gt; {console.log(`watching: ${relativeOutfile}`)})
</code></pre>
</li>
<li>
<p>执行打包命令。由于我们一般用于浏览器下调试，所以 -f 基本不用指定，默认就是 global。</p>
<p>如果整个 vue 一起打包，则直接不用做任何修改 npm run dev 即可。</p>
<p>如果打包指定模块，比如 reactivity，则有 2 种方式。一是直接 npm run dev reactivity ，二是修改根目录下的 package.json <code>&quot;dev&quot;: &quot;node scripts/dev.js reactivity&quot;</code>，然后再执行 npm run dev。</p>
</li>
<li>
<p>打包后文件如下</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206111005999.png" alt="image-20220611100505407" /></p>
</li>
</ol>
<h1><a id="%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>源码调试</h1>
<ol>
<li>
<p>在任意位置新建一个 examples 目录（一般调试哪个模块就在哪个模块下创建目录）</p>
</li>
<li>
<p>在 examples 目录中新建一个 xxx.html ，然后用 script 标签引入前面打包出来的文件即可</p>
</li>
<li>
<p>reactivity 测试举例</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;!-- 引入打包文件 --&gt;
    &lt;script src=&quot;../dist/reactivity.global.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

&lt;script&gt;
    const {readonly, reactive, effect} = VueReactivity
    let person = reactive({name: &quot;张三&quot;, age: 18});
    person = readonly(person);

    effect(() =&gt; {document.body.innerHTML = `name: ``{person.name},  age: ``{person.age}`
    })setTimeout(() =&gt; {
        person.name = &quot;李四&quot;;
        person.age = 20;
    }, 2000)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206111017498.gif" alt="2022-06-11 10.17.11" /></p>
</li>
<li>
<p>断点调试</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206111020195.png" alt="image-20220611102023818" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206111021675.png" alt="image-20220611102113301" /></p>
</li>
<li>
<p>至此我们就可以随便调试源码了。</p>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[城市应用管理Vue框架核心工作原理]]></title>
    <link href="http://yuanchao.blogs.io/16542436863393.html"/>
    <updated>2022-06-03T16:08:06+08:00</updated>
    <id>http://yuanchao.blogs.io/16542436863393.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E5%BC%95%E8%A8%80">引言</a></li>
<li><a href="#%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D">整体介绍</a>
<ul>
<li><a href="#%E5%AE%9A%E5%88%B6%E5%8A%9F%E8%83%BD">定制功能</a></li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84">项目结构</a></li>
<li><a href="#%E5%8D%95%E5%BA%94%E7%94%A8%E7%BB%93%E6%9E%84">单应用结构</a></li>
<li><a href="#%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8">安装使用</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">常用命令</a></li>
<li><a href="#%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE">代理配置</a></li>
<li><a href="#%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA">效果展示</a></li>
</ul>
</li>
<li><a href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">工作原理</a>
<ul>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E6%96%87%E4%BB%B6">路由文件</a></li>
<li><a href="#%E7%99%BB%E5%BD%95%E9%80%BB%E8%BE%91">登录逻辑</a>
<ul>
<li><a href="#%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B">登录流程</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81">核心代码</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8">数据存储</a></li>
</ul>
</li>
<li><a href="#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC">路由跳转</a></li>
<li><a href="#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6">权限控制</a></li>
<li><a href="#%E8%A7%86%E5%9B%BE%E9%AA%A8%E6%9E%B6">视图骨架</a>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84">代码结构</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE">路由配置</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82">网络请求</a>
<ul>
<li><a href="#service%E5%85%B3%E7%B3%BB%E5%9B%BE">service关系图</a></li>
<li><a href="#axiosservice-base-ts">axios/service-base.ts</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B">使用举例</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85">多应用打包</a>
<ul>
<li><a href="#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4">执行命令</a></li>
<li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE">工作流程图</a></li>
<li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AF%A6%E7%BB%86">工作流程详细</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<h1><a id="%E5%BC%95%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>引言</h1>
<p>城市应用管理部门的Vue框架源自中台提供的<a href="http://192.168.101.70:8000/framework/frontend/egova-admin-template-web.git">初始框架</a>，我在此基础上进行了相当多的定制开发。考虑到今后精细化项目都要使用本框架，所以有必要将一些核心的工作原理进行一次梳理，方便后面使用的同学们快速上手。</p>
<h1><a id="%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>整体介绍</h1>
<p>首先整体介绍一下本框架的基本情况，包括：有哪些定制功能，项目结构是什么样子，如何安装使用，如何新增一个项目，调试打包，页面展示效果等等。</p>
<h2><a id="%E5%AE%9A%E5%88%B6%E5%8A%9F%E8%83%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定制功能</h2>
<p>首先列举一下本框架已完成定制开发的功能，让大家有一个大致的了解，主要包括：</p>
<ol>
<li>
<p>支持调用 mis 的接口登录</p>
<p>新增 mislogin 模块，封装 AesTool 加密工具类等</p>
</li>
<li>
<p>支持 mis 岗位权限控制，调用 mis 接口获取导航</p>
<p>按照统一用户中心导航数据结构重新组装数据，最小限度修改权限管理代码</p>
</li>
<li>
<p>支持独立首页配置</p>
<p>新增 home 模块，并新增 hasHomePage 配置项</p>
</li>
<li>
<p>支持头部导航条主模块快捷切换</p>
<p>完善 header 组件，仿老渣土系统增加九宫格快速入口</p>
</li>
<li>
<p>支持头部标题动态显示模块标题</p>
<p>原框架始终显示的是系统标题</p>
</li>
<li>
<p>支持第三方嵌入，绕过登录页面直接登录（url 需携带 token 参数）</p>
<p>Knockout 、React 等项目可以 iframe 的形式嵌入本框架开发的页面，系统自动识别 token 并帮助完成登录、获取导航、获取微服务配置等一系列步骤。</p>
</li>
<li>
<p>支持多应用打包</p>
<p>修改原打包脚本、page.config.js、index.json 等文件，支持多个项目可以使用同一套框架。</p>
</li>
<li>
<p>支持项目单独配置</p>
<p>原框架有2个配置文件，我在此基础上又新增加了1个，用于项目独有配置，与其它项目进行区分。</p>
</li>
<li>
<p>支持使用玲珑能力</p>
<p>按照中台提供的技术文档，搭建使用玲珑的环境</p>
</li>
<li>
<p>支持动态拼接 ajax 请求的 baseUrl</p>
<p>框架涉及 mis 服务、项目微服务、玲珑微服务等多套服务，但我们编写 service 时可以无感，拦截器中通过调用 ServiceUtil 工具类中封装相关方法已经帮助动态拼接。</p>
</li>
<li>
<p>支持全局事件总线实现任意组件间通信</p>
<p>具体实现参考：<a href="https://alidocs.dingtalk.com/i/team/9JOGOLjlap1oz4QL/docs/9JOGOZ0e32gJ3m4Q">https://alidocs.dingtalk.com/i/team/9JOGOLjlap1oz4QL/docs/9JOGOZ0e32gJ3m4Q</a></p>
</li>
</ol>
<h2><a id="%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目结构</h2>
<pre><code class="language-plain_text">┌── config                  # webpack 启动/打包执行脚本
├── src                     # 源代码主要目录
│    ├── application         # 程序启动载入处理逻辑
│    ├── assets              # 可打包资源文件
│    │    ├── images              # 图片资源
│    │    ├── styles              # 样式资源
│    ├── common                 # common
│    │    ├── const               # 公共常量
│    │    ├── hooks               # 自定义钩子
│    │    └── utils              # 工具类
│    ├── components           # 项目中公共组件
│    ├── models               # 项目中模型实体定义
│    ├── pages                   # 项目文件总目录
│    │    ├── admin               # 模板示例项目
│    │    ├── construction          # 渣土精细化项目
│    │    └── xxx...                 # 后续其它项目放这里
│    │    └── index.js            # 多应用打包配置文件
│    ├── services             # 项目中公共的service类
│    ├── settings             # 项目中公共配置
│    ├── store                  # store
│    │    └── modules                  # 按模块使用
│    ├── types                  # d 文件定义
│    ├── views                  # 公共视图，如login、404之类
│
├── node_modules            # 依赖
├── public                  # 静态文件
│    ├── index.html          # 程序启动载入处理逻辑
│    └── favicon.ico          # 程序图标
├── dist                    # 打包文件目录
│    ├── construction        # 打包文件
│    └── construction.zip      # 打包文件压缩包
├── .eslintrc.js           # eslint配置
├── .gitignore            # git 忽略提交配置
├── .stylelintrc.json     # stylelint 配置
├── babel.config.js           # babel 配置
├── dll.config.js         # dll 插件配置
├── package.json              # package info
├── page.config.js        # 页面、应用配置
├── postcss.config.js       # postcss 配置
├── tsconfig.json          # typescript 配置
└── vue.config.js           # vue.config 配置(很重要)
</code></pre>
<h2><a id="%E5%8D%95%E5%BA%94%E7%94%A8%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单应用结构</h2>
<p>以渣土精细化项目举例：</p>
<pre><code class="language-plain_text">┌── pages                   # 项目文件总目录
│    ├── construction        # 渣土精细化项目
│    │    ├── routes             # 路由配置
│    │    ├── settings            # 项目配置 会覆盖公共配置
│    │    ├── views               # 所有页面
│    │    ├── main.ts                # 应用入口启动文件
└─────── index.js           # 多应用打包配置文件
</code></pre>
<p>如果要新建一个项目，只需要按照上面结构创建这些目录，并且修改index.js文件。index.js内容如下，只需要仿照新增一个对象即可。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206030756588.png" alt="01" /></p>
<h2><a id="%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装使用</h2>
<p>首先安装 Vue 官方提供的工具 <a href="https://github.com/vuejs/vue-cli">vue-cli</a></p>
<pre><code class="language-bash">npm install -g @vue/cli

# 建议环境

npm 版本为 6.14.15
node 版本为 14.18.2
@vue/cli 版本为 4.5.16

</code></pre>
<ol>
<li>项目按公司要求统一使用的 ant design 组件库</li>
<li>按照公司 ui 规范写了一套样式风格，diy 开头具体在 <code>_ant.scss</code> 文件中查看每个组件的样式名称，需要添加到自己的样式中，比如</li>
</ol>
<pre><code class="language-js">&lt;a-input class=&quot;diy-input&quot; /&gt;
</code></pre>
<p>如果项目依赖如 <code>axios</code>、<code>lodash</code> 等库，只需按照如下方式导入即可：</p>
<pre><code class="language-js">import axios from &quot;axios&quot;;
import lodash from &quot;lodash&quot;;
</code></pre>
<p>项目使用 stylelint 对样式进行检查，样式代码需要保持规范，建议开发过程中安装并开启 stylelint 插件：<br />
stylelint 配置文件<code>.stylelintrc.json</code>中配置内容有：<br />
<code>&quot;selector-max-id&quot;: 2</code>, // 限定选择器中 id 选择器个数为 2， 建议只用一个 id 选择器<br />
<code>&quot;max-nesting-depth&quot;: 5</code> // 选择器嵌套深度不能超过 5 层， 建议最多不超过 3 层<br />
<code>&quot;selector-max-compound-selectors&quot;: 5</code>, // 复合选择器数量限制为 5<br />
<code>order/properties-order: [...]</code> // 限定属性申明的顺序，大致顺序如下</p>
<ul>
<li>1、定位：<code>position</code> <code>z-index</code> <code>left</code> <code>right</code> <code>top</code> <code>bottom</code> <code>clip</code>等。</li>
<li>2、自身属性：<code>width</code> <code>height</code> <code>min-height</code> <code>max-height</code> <code>min-width</code> <code>max-width</code>等。</li>
<li>3、文字样式：<code>color</code> <code>font-size</code> <code>letter-spacing</code>, <code>color</code> <code>text-align</code>等。</li>
<li>4、背景：<code>background-image</code> <code>border</code>等。</li>
<li>5、文本属性: <code>text-align</code> <code>vertical-align</code> <code>text-wrap</code> <code>text-transform</code> <code>text-indent</code> <code>text-decoration</code> <code>letter-spacing</code> <code>word-spacing</code> <code>white-space</code> <code>text-overflow</code>等。</li>
<li>6、css3 相关属性：<code>content</code>、<code>box-shadow</code>、<code>animation</code>、<code>border-radius</code>、<code>transform</code>等</li>
</ul>
<p><em>插件会按规则自动调整某些 css 代码。例如：插件会自动按设定的属性顺序代码中书写的顺序</em></p>
<h2><a id="%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用命令</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>npm run serve 项目名</td>
<td>以开发模式启动项目</td>
<td>npm run serve construction</td>
</tr>
<tr>
<td>npm run build 项目名</td>
<td>生产打包</td>
<td>npm run build construction</td>
</tr>
<tr>
<td>npm run lint</td>
<td>使用 tslint验证源码</td>
<td>npm run lint</td>
</tr>
<tr>
<td>npm run dll</td>
<td>预打包核心依赖库</td>
<td>npm run dll</td>
</tr>
<tr>
<td>lint:css</td>
<td>使用 stylelint验证样式源码规范性</td>
<td>lint:css</td>
</tr>
<tr>
<td>lint:css-fix</td>
<td>使用 stylelint规范样式源码</td>
<td>lint:css-fix</td>
</tr>
</tbody>
</table>
<h2><a id="%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代理配置</h2>
<p>本框架是前后端分离的项目，可以代理到指定服务。配置在<code>vue.config.js</code>文件中，如下：</p>
<pre><code class="language-js">   devServer: {
        headers: {
            &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;
        },
        host: &quot;0.0.0.0&quot;,
        port: 8100,     // 端口号
        https: false,   // https:{type:Boolean}
        open: true,     // 配置自动启动浏览器
        hot: true,      // 热更新
        proxy: {
            &quot;/api&quot;: {
                target: &quot;http://localhost:8088&quot;,
                changeOrigin: true,
                ws: true,
                pathRewrite: {
                    &quot;^/api&quot;: &quot;/eUrbanMIS&quot;   // 将/api前缀替换为eUrbanMIS，以实际要连的服务为准
                }
            },
            &quot;/construction&quot;: {
                target: &quot;http://192.168.31.25:8088&quot;,  //若需要使用微服务则在proxy中增加微服务配置
                changeOrigin: true,
                ws: true,
                pathRewrite: {
                    &quot;^/construction&quot;: &quot;/construction&quot;
                }
            }
        }
   }
</code></pre>
<p>注意：proxy 中可以配置多个代理服务器，所以如果项目中使用到了微服务，开发调试阶段，可以增加微服务的代理配置。目前登录等接口走mis服务，项目接口走微服务的情况比较常见。</p>
<h2><a id="%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>效果展示</h2>
<p>以渣土精细化项目为例，截取其中几个页面：</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206030801157.png" alt="image-20220603080155127" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206030811891.png" alt="image-20220603081127230" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206030810165.png" alt="image-20220603081042337" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206030807793.png" alt="image-20220603080750016" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206030809856.png" alt="image-20220603080937866" /></p>
<h1><a id="%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>工作原理</h1>
<h2><a id="%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置文件</h2>
<p>原框架本来有2个配置文件，一个在 public/static 目录下，一个在 src/setting 目录下，由于我们要支持多应用所以我在此基础上又新增加了1个，放在 pages/项目目录下，各个配置文件的路径如下所示。</p>
<blockquote>
<p>备注：本文档并不会挨个解释各个配置项有什么作用，请大家自行查阅，基本都有注释。</p>
</blockquote>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031044066.png" alt="image-20220603104456399" /></p>
<p><strong>下面分别说明一下各个配置文件的功能：</strong></p>
<ol>
<li>
<p>public/static 下的配置文件</p>
<p>在 index.html 中以 script 脚本形式引入，主要用于现场可自行修改的配置。为什么要放在 public/static 目录下呢？因为public/static 下的文件编译打包后，不会压缩混淆，原来是什么样打包后还是什么样。非常方便现场自行修改相关配置。在程序运行过程中，它挂载在 window 对象上，可以通过 window.commonSetting 得到相关配置。</p>
</li>
<li>
<p>src/setting 下的配置文件</p>
<p>系统公共配置，另外在里边还要完成几个重要工作：整个项目所有配置项的合并、rem屏幕适配、部署路径及baseUrl解析等。</p>
</li>
<li>
<p>pages/项目 下的配置文件</p>
<p>用于项目独有配置，与其它项目进行区分。比如是否有独立首页等等。</p>
</li>
<li>
<p><strong>同名配置的覆盖顺序：用户配置(public/static/setting)  &gt;  项目配置(src/page/xxx项目/settings)  &gt;  公共配置(src/settings)。</strong></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206150947803.png" alt="image-20220615094749440" /></p>
</li>
</ol>
<h2><a id="%E8%B7%AF%E7%94%B1%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>路由文件</h2>
<p>路由文件放在 pages/项目/routes 目录下，是整个项目的“灵魂”，没有它我们就什么也看不了。如下图所示，这里先给出一个结论，后面会给出具体解释。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031132972.png" alt="image-20220603113222982" /></p>
<p>框架中对路由对象，专门自定义了一个类型——RouteItem。如下所示，前面是类型，后面是具体的路由对象。</p>
<pre><code class="language-typescript">type RouteItem = {
    title?: string;
    meta: {
        icon?: string; // iconfont 图标
        title?: string; // title
        isMenuGroup?: boolean; // 是否为菜单中的父节点
        [key: string]: string | any;
    };
    children?: Array&lt;RouteItem&gt;;
} &amp; RouteConfig;

//首页
const home: RouteItem = {
    name: &quot;home&quot;,
    path: &quot;/home&quot;,
    meta: {
        icon: &quot;icon-home&quot;,
        title: &quot;首页&quot;,
        schemaId: &quot;construction:home&quot;
    },
    component: () =&gt; import(&quot;@/pages/construction/views/home&quot;)
};
</code></pre>
<p>关于路由配置文件，有一个细节要特别注意，下面举例来说明。我们先来对比一下框架内置的项目 admin 项目和渣土精细化项目 construction ，看看这两者的路由配置文件有什么不同？(我只截取了部分路由进行说明)</p>
<ol>
<li>
<p>admin 项目</p>
<pre><code class="language-typescript">import { RouteConfig } from &quot;vue-router&quot;;

type RouteItem = {
    title?: string;
    meta: {
        icon?: string; // iconfont 图标
        title?: string; // title
        isMenuGroup?: boolean; // 是否为菜单中的父节点
        [key: string]: string | any;
    };
    children?: Array&lt;RouteItem&gt;;
} &amp; RouteConfig;

const webpage: RouteItem = {
    name: &quot;webpage&quot;,
    path: &quot;/webpage&quot;,
    meta: {
        icon: &quot;icon-home&quot;,
        title: &quot;首页&quot;
    },
    redirect: &quot;/welcome&quot;,
    component: () =&gt; import(&quot;@/components/layout/main&quot;),
    children: [
        {
            name: &quot;welcome&quot;,
            path: &quot;/welcome&quot;,
            meta: {
                icon: &quot;icon-nav&quot;,
                title: &quot;主页&quot;,
                schemaId: &quot;webpage:index&quot;
            },
            component: () =&gt; import(&quot;@/components/layout/blank/index&quot;),
            redirect: &quot;/welcome/index&quot;,
            children: [
                {
                    name: &quot;welcome_index&quot;,
                    path: &quot;index&quot;,
                    meta: {
                        icon: &quot;icon-nav&quot;,
                        title: &quot;主页&quot;,
                        schemaId: &quot;webpage:index&quot;
                    },
                    component: () =&gt; import(&quot;@/pages/admin/views/welcome&quot;)
                }
            ]
        }
    ]
};

const design: RouteItem = {
    name: &quot;design&quot;,
    path: &quot;/design&quot;,
    meta: {
        icon: &quot;icon-design&quot;,
        title: &quot;设计规范&quot;,
        schemaId: &quot;design&quot;
    },
    component: () =&gt; import(&quot;@/components/layout/main&quot;),
    redirect: &quot;/design/layout&quot;,
    children: [
        {
            name: &quot;design_layout&quot;,
            path: &quot;layout&quot;,
            meta: {
                icon: &quot;icon-folder&quot;,
                title: &quot;布局&quot;,
                schemaId: &quot;design:layout&quot;,
                isMenuGroup: true
            },
            component: () =&gt; import(&quot;@/components/layout/blank/index&quot;),
            redirect: &quot;/design/layout/panel&quot;,
            children: [
                {
                    name: &quot;design_layout_panel&quot;,
                    path: &quot;panel&quot;,
                    meta: {
                        icon: &quot;icon-nav&quot;,
                        title: &quot;查询页面&quot;,
                        schemaId: &quot;design:layout&quot;,
                        isMenuGroup: true
                    },
                    component: () =&gt; import(&quot;@/pages/admin/views/design/layout/panel&quot;)
                },
                {
                    name: &quot;design_layout_panal&quot;,
                    path: &quot;panal&quot;,
                    meta: {
                        icon: &quot;icon-nav&quot;,
                        title: &quot;详情页面&quot;,
                        schemaId: &quot;design:layout&quot;,
                        isMenuGroup: true
                    },
                    component: () =&gt; import(&quot;@/pages/admin/views/design/layout/panal&quot;)
                }
            ]
        }
    ]
};

export const appRouter = {
    name: &quot;app&quot;,
    path: &quot;/&quot;,
    redirect: &quot;/webpage&quot;,
    meta: {},
    component: () =&gt; import(&quot;@/components/layout&quot;),
    children: [webpage, design]  // 前面定义的2个 RouteItem 对象放到了这里。
};

export const routes = [
    appRouter,   // 前面定义的 appRouter 对象放到了这里，最终框架构建路由系统用的就是这个 routes 对象
    {
        name: &quot;login&quot;,
        path: &quot;/login&quot;,
        title: &quot;登录&quot;,
        component: () =&gt; import(&quot;@/views/login/index&quot;)
    },
    {
        name: &quot;401&quot;,
        path: &quot;/401&quot;,
        component: () =&gt; import(&quot;@/views/errors/401&quot;)
    },
    {
        name: &quot;404&quot;,
        path: &quot;/*&quot;,
        component: () =&gt; import(&quot;@/views/errors/404&quot;)
    }
];
</code></pre>
</li>
<li>
<p>construction 项目</p>
<pre><code class="language-typescript">import { RouteConfig } from &quot;vue-router&quot;;
import { ImagePreview, OfficePreview } from &quot;@magic/design-web&quot;;

type RouteItem = {
    title?: string;
    meta: {
        icon?: string; // iconfont 图标
        title?: string; // title
        isMenuGroup?: boolean; // 是否为菜单中的父节点
        [key: string]: string | any;
    };
    children?: Array&lt;RouteItem&gt;;
} &amp; RouteConfig;

//首页
const home: RouteItem = {
    name: &quot;home&quot;,
    path: &quot;/home&quot;,
    meta: {
        icon: &quot;icon-home&quot;,
        title: &quot;首页&quot;,
        schemaId: &quot;construction:home&quot;
    },
    component: () =&gt; import(&quot;@/pages/construction/views/home&quot;)
};

//-----------------------------------不同点1：这里定义的是 RouteItem 数组------------------------------
//违规管理
const violationManage: RouteItem[] = [
    {
        name: &quot;video-monitor&quot;,
        path: &quot;/videomonitor&quot;,
        meta: {
            icon: &quot;icon-videobind&quot;,
            title: &quot;视频监控&quot;,
            schemaId: &quot;construction:video-monitor&quot;
        },
        component: () =&gt; import(&quot;@/pages/construction/views/violation/videomonitor&quot;)
    },
    {
        name: &quot;violation-discover&quot;,
        path: &quot;/discover&quot;,
        meta: {
            icon: &quot;icon-violation-discover&quot;,
            title: &quot;违规发现&quot;,
            schemaId: &quot;construction:violation-discover&quot;
        },
        component: () =&gt; import(&quot;@/components/layout/main&quot;),
        redirect: &quot;/discover/vehiclealarm&quot;,
        children: [
            {
                name: &quot;violation-livelaw&quot;,
                path: &quot;livelaw&quot;,
                meta: {
                    icon: &quot;icon-violation-livelaw&quot;,
                    title: &quot;现场执法&quot;,
                    schemaId: &quot;construction:violation-livelaw&quot;
                },
                component: () =&gt; import(&quot;@/pages/construction/views/violation/livelaw&quot;)
            }
        ]
    }
];

//土方量管理
const earthManage: RouteItem[] = [
    {
        name: &quot;earth-work&quot;,
        path: &quot;/earth&quot;,
        meta: {
            icon: &quot;icon-design&quot;,
            title: &quot;土方量&quot;,
            schemaId: &quot;construction:earth-work&quot;
        },
        component: () =&gt; import(&quot;@/components/layout/main&quot;),
        redirect: &quot;/earth/accept&quot;,
        children: [
            {
                name: &quot;earth-ticket&quot;,
                path: &quot;ticket&quot;,
                meta: {
                    icon: &quot;icon-nav&quot;,
                    title: &quot;准运票记录&quot;,
                    schemaId: &quot;construction:earth-ticket&quot;
                },
                component: () =&gt; import(&quot;@/pages/construction/views/earth/ticket&quot;)
            }
        ]
    }
];

//后台管理(各种配置相关的模块)
const backendManage: RouteItem[] = [
    {
        name: &quot;docking&quot;,
        path: &quot;/docking&quot;,
        meta: {
            icon: &quot;icon-docking&quot;,
            title: &quot;对接配置&quot;,
            schemaId: &quot;construction:docking&quot;
        },
        component: () =&gt; import(&quot;@/components/layout/main&quot;),
        redirect: &quot;/docking/videobind&quot;,
        children: [
            {
                name: &quot;videobind&quot;,
                path: &quot;videobind&quot;,
                meta: {
                    icon: &quot;icon-videobind&quot;,
                    title: &quot;视频监控绑定&quot;,
                    schemaId: &quot;construction:videobind&quot;
                },
                component: () =&gt; import(&quot;@/pages/construction/views/backend/docking/videobind&quot;)
            }
        ]
    }
];

export const appRouter = {
    name: &quot;app&quot;,
    path: &quot;/&quot;,
    redirect: &quot;/home&quot;,
    meta: {},
    component: () =&gt; import(&quot;@/components/layout&quot;),
    children: [home, ...violationManage, ...earthManage, ...backendManage]  // 不同点2，这里通过 ... 展开数组
};

export const routes = [
    appRouter,
    {
        name: &quot;login&quot;,
        path: &quot;/login&quot;,
        title: &quot;登录&quot;,
        component: () =&gt; import(&quot;@/views/mislogin/index&quot;)
    },
    {
        name: &quot;401&quot;,
        path: &quot;/401&quot;,
        component: () =&gt; import(&quot;@/views/errors/401&quot;)
    },
    {
        name: &quot;404&quot;,
        path: &quot;/*&quot;,
        component: () =&gt; import(&quot;@/views/errors/404&quot;)
    }
];
</code></pre>
</li>
</ol>
<p>通过对比，我们可以看到 admin 项目中，定义的是一个个 RouteItem对象， 而渣土精细化项目我定义的是 RouteItem 数组。为什么要这么做呢？我们再对比一下 admin 和 construction 的页面结构。前者我称它为&quot;单模块系统&quot;，后者我称它为&quot;多模块系统&quot;。回到路由配置文件，也就是说像&quot;违规管理&quot;、&quot;土方量管理&quot;、这样的大模块导航，我们没有放到 appRouter 中，当然如果非要放进去也不是完全不可以，但是就需要修改中台框架中原来的很多代码，本着尽量少改动的原则，所以 construction 中采用的是解构 RouteItem[] 的方式。现在再回顾一下开头的结论：简单的单模块系统参考 admin 的路由配置，复杂的多模块系统参考 construction 的路由配置。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031141688.png" alt="image-20220603114154498" /></p>
<h2><a id="%E7%99%BB%E5%BD%95%E9%80%BB%E8%BE%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>登录逻辑</h2>
<p>本文档主要写给城市应用管理部门的同事参考，所以这里的登录主要讨论 mislogin 模块的登录。当然，原框架中还保留原来的 login 模块，它使用的是统一用户中心的登录逻辑，将来如果公司统一切换为统一用户中心登录，我可以很快速的切换回去，并不需要修改太多代码。</p>
<h3><a id="%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>登录流程</h3>
<p>下面是正常登录流程，即在用户登录界面，输入用户名、密码，点击&quot;登录&quot;按钮后执行的逻辑。登录流程参考下图，具体代码位于：<code>src/views/mislogin/index.ts</code>中。之所以这里说正常的登录流程，是因为本框架还支持第三方登录，可以绕过登录界面，直接通过 token 验证完成登录逻辑，后面讲路由跳转工作流程时会谈到。</p>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031334678.png" alt="未命名表单" style="zoom:50%;" />
<h3><a id="%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>核心代码</h3>
<pre><code class="language-typescript">public async login() {
        if (this.logging) {
            return;
        }
        this.logging = true;
        try {
            const browserVersion = WinowUtil.getBrowserInfo();
            const osVersion = WinowUtil.getOSVersion();
            const params = {
                u: this.aesTool.encrypt(this.username),
                p: this.aesTool.encrypt(this.password),
                ip: null,
                browserVersion: decodeURI(browserVersion),
                osVersion: decodeURI(osVersion),
                lock32R: &quot;&quot; //CA认证流程会用到这里暂时不管
            };
            // 调用mis登录接口
            const misLoginRes: any = await this.service.login(params);
            if (!misLoginRes.success) {
                this.loginError(misLoginRes);
                return;
            }
            // 调用mis获取token接口
            const misTokenRes: any = await this.service.getToken({
                username: this.username,
                password: Base64.stringify(Utf8.parse(this.password))
            });
            // 保存城管token后续会使用.
            Cookies.set(&quot;token&quot;, misTokenRes.token, { expires: 7 * 24 * 60 * 60 * 1000 });
            // 调用mis获取人员头像接口
            const misHumanPhotoRes: any = await this.service.getHumanPhoto();
            // 调用mis获取导航权限接口
            const misNavRes: any = await this.service.getHumanNavData({ sysName: commonSetting.sysName });
            // 如果启用了微服务则还需调用额外接口
            let misMSConfigRes: any;
            let msTokenRes: any;
            if (commonSetting.enableMicroServer) {
                // 调用mis获取微服务地址配置项的接口
                misMSConfigRes = await this.service.getMicroServiceUrl();
                // 调用微服务token交换接口
                msTokenRes = await this.service.getMicroServiceToken(misMSConfigRes.data.value, misTokenRes.token);
            }
            this.userInfo = this.buildUserInfo(
                misLoginRes,
                misTokenRes,
                misHumanPhotoRes,
                misNavRes,
                misMSConfigRes,
                msTokenRes
            );
            this.$store.commit(&quot;user/save&quot;, this.userInfo);
            this.$router.push({ path: &quot;/&quot; });
        } catch (error: any) {
            if (error?.response?.status === 401) {
                this.$message.error(error.response.data.error_description);
            } else {
                this.$message.error(&quot;调用服务异常&quot;);
            }
        } finally {
            this.logging = false;
        }
    }
</code></pre>
<h3><a id="%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据存储</h3>
<p>从登录流程图可以看到，在执行路由跳转逻辑之前，有一个数据存储的步骤。这个步骤非常重要，很多重要的信息都需要缓存起来，系统才能正常运行。如下所示，有些数据存储在Cookies中，有些数据存储在 SessonStorage 中。其中 loginFlag 、access_token 等标记非常重要，是系统判断登录与否的关键。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031354488.png" alt="image-20220603135405068" /></p>
<p>例如，下面这个方法用来判断是否已经登录：</p>
<pre><code class="language-typescript">/**
	* 判断是否有本地的 token 和 sso 的 token，只要有一个即可满足
  * @returns
  */    
public static hasToken(): boolean {
   let value = Cookies.get(&quot;access_token&quot;) || Cookies.get(&quot;token&quot;) || &quot;&quot;;
   return value.length &gt; 0;
}    
</code></pre>
<h2><a id="%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>路由跳转</h2>
<p>路由跳转分2种情况，一种是执行完登录流程后跳转，会跳转到路由配置文件里配置的默认页面；二是刷新页面后跳转，会停留在原来的页面。当项目启动后，首先会执行 workbench.ts 里的 onOpen 方法。其中第一个步骤就是初始化路由程序。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031405863.png" alt="image-20220603140547214" /></p>
<p>进入 initializeRouter  内部，里边有一个非常重要的钩子函数，router.beforeEach()，所有的路由跳转都会经过这里，从而使得我们可以在里边完成权限控制、token 登录、刷新配置信息等重要功能。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031410850.png" alt="image-20220603140958625" /></p>
<p>router.beforeEach() 代码如下，重点是 this.toPage()。</p>
<blockquote>
<p>扩展思考：如果我们只是写个Demo，不需要权限控制等等，是不是可以注释掉 this.toPage() 这一行，然后直接 next() 放行呢？</p>
</blockquote>
<pre><code class="language-typescript"> router.beforeEach(async (to: any, from: any, next: any) =&gt; {
      let title = to.meta?.title || to.title;
      if (isNil(title) || title === &quot;&quot;) {
          title = commonSetting.appTitle;
      } else {
          title = ```{title} - ``{commonSetting.appTitle}`;
      }
      window.document.title = title;

      await this.toPage(context, to, from, next);
});


// 下面是 toPage 具体代码，我删除了一些细枝末节，不影响阅读。
private async toPage(context: any, to: any, from: any, next: any) {
        // 1.如果是登录页面，先清除之前登录的标记，再进入登录页面跳转流程
        if (to.name === &quot;login&quot;) {
            // 清除之前登录的标记
            LoginUtil.clearLoginFlag();
            // 进入登录页面跳转流程
            LoginUtil.gotoLogin(to, next);
            return;
        }

        // 处理第三方登录逻辑
        if (CommonUtil.containStr(window.location.href, [&quot;third=&quot;, &quot;token=&quot;], &quot;all&quot;)) {
            LoginUtil.processThirdLogin();
        }

        // 2. 判断是否已登陆，若未登录，则进入登录页面跳转流程
        if (!LoginUtil.hasToken()) {
            let enable = await getSSOEnable();
            if (enable) {
              	.......
            } else {
                // 进入登录页面跳转流程
                LoginUtil.gotoLogin(to, next);  
                return;
            }
        }

        // 3.加载用户相关数据(此处 token 肯定存在)
        // await LoginUtil.loadUserData(context.store); // 统一用户中心使用
        await LoginUtil.loadUserInfo(context.store); // mis服务使用

        // 4. 如果上一步失败，则把 token 作废并跳转至登录页面
        if (!LoginUtil.isLogin()) {
            await LoginUtil.revokeToken();
            LoginUtil.gotoLogin(to, next);
            return;
        }

        // 5. 判断权限
        const appRouter = context.routerOptions.routes?.find((r: any) =&gt; r.name === &quot;app&quot;);
        PermissionUtil.handePermissionBeforeEach([appRouter], to, from, next);
    }
</code></pre>
<p>toPage() 中我修改了2处地方，一是增加了处理第三方登录的逻辑，二是重写了加载用户数据的方法。具体逻辑全部放在 login-util.ts 中，如下所示，注释写得非常清楚，这里就不再展开。需要特别说明一下的是：如果从其它系统嵌入我们的页面，url 中必须携带2个参数，third=true&amp;token=xxxxx。之所以多要了一个 third=true，是为了避免本系统内部跳转时，由于某种原因多了一个 token 参数，让系统误以为是第三方登录，而其实并不是。</p>
<pre><code class="language-typescript"> // 处理第三方登录逻辑
if (CommonUtil.containStr(window.location.href, [&quot;third=&quot;, &quot;token=&quot;], &quot;all&quot;)) {
   LoginUtil.processThirdLogin();
} 
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031417234.png" alt="image-20220603141757065" /></p>
<pre><code class="language-typescript">// 3.加载用户相关数据(此处 token 肯定存在) 
await LoginUtil.loadUserInfo(context.store); // mis服务使用        
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031419880.png" alt="image-20220603141948390" /></p>
<p>下图是模拟第三方登录场景，在浏览器地址栏直接输入url【需携带token参数】，就可以不用输入用户名、密码，直接绕过登录环节进入系统内部。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206021816606.gif" alt="1654164195748097" /></p>
<h2><a id="%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>权限控制</h2>
<p>权限控制这块仍然沿用原框架的逻辑，我没有做太多修改。需要注意的是，权限控制这块实际上是有两层控制，第一层权限控制是后台控制，是 mis 岗位权限设置，第二层控制是前端控制，是在路由配置文件中进行控制。框架中有一个专门的 permission-util.ts 工具类。其中最核心的2个方法是：handePermissionBeforeEach、getPermissions。前者与 workbench.ts 遥相呼应，是在 router.beforeEach() 的回调函数中调用，后者是获取用户具体具备哪些导航权限。</p>
<pre><code class="language-typescript">//------------------------------------------workbench.ts----------------------------------------
// 5. 判断权限
const appRouter = context.routerOptions.routes?.find((r: any) =&gt; r.name === &quot;app&quot;);
PermissionUtil.handePermissionBeforeEach([appRouter], to, from, next);


//------------------------------------------permission-util.ts----------------------------------
public static handePermissionBeforeEach(routes: Array&lt;any&gt;, to: any, from: any, next: any) {
    // 如果账号为admin或者进入的菜单schemaId为空（即不需要进行权限控制）直接放行
    if (Cookies.get(&quot;username&quot;) === &quot;admin&quot; || !(to.meta &amp;&amp; to.meta.schemaId)) {
        next();
        return;
    }
    //重要!!! 获取用户具有的权限。
    const permissions = this.getPermissions();
    if (permissions.has(to.meta.schemaId)) {
        // 如果有权限
        next();
        return;
    } else if (from.path === &quot;/&quot; || from.path === &quot;/401&quot; || from.path === &quot;/login&quot;) {
        // 如果没有即将进入的页面的权限，先进行判断，如果是刚进入 是从/ 路径重定向进入第一个默认页面，而第一个页面刚好没有权限
        // 这时候如果直接重定向到401页面体验会很差，所以这里处理是 如果从 /路径重定向到第一个默认页面，刚好第一个默认页面没有权限，
        // 这个时候去找该用户第一个有权限的页面并进入该页面
        // 如果用户一个权限也没有那么才会进入401,
        // 如果不是从/重定向过来的 如果没有权限 则直接进入401·
        let page = PermissionUtil.getFirstAuthPage(permissions, routes);
        next({ replace: true, name: page });
    } else if ( new Set((routes[0].children || []).map((v: any) =&gt; v.name)).has(to.matched.length &gt; 1 &amp;&amp; 		to.matched[1].name ) &amp;&amp; !this.isSameModel(from, to)) {
        // 前往不同的模块
        const name = to.matched.length &gt; 1 &amp;&amp; to.matched[1].name;
        const route = (routes[0].children || []).filter((v: any) =&gt; v.name === name);
        let page = PermissionUtil.findFirstAuthPage(route);
        next({
            replace: true,
            name: page
        });
    } else {
        next({
            replace: true,
            name: &quot;401&quot;
        });
    }
}


//获取用户具有的导航权限
public static getPermissions(): Set&lt;string&gt; {
    const userInfo: any = JSON.parse(sessionStorage.getItem(&quot;user&quot;) as string);
    if (!userInfo) return new Set([]);
    const { user, applicationPermissions } = userInfo;
    if (!this.permisstionsMap.has(user.id)) {
        let permissionList: Array&lt;string&gt; = [];
        for (const i of applicationPermissions || []) {
            if (!commonSetting.applicationCode || i.application?.code === commonSetting.applicationCode) {
                let appCode = i.application?.code || &quot;&quot;; // appCode 如：construction
                if (!i.resourceMenus) {
                    i.resourceMenus = [];
                }
                // permission 的格式如：construction:violation，冒号前是 appCode，冒号后实际上是 navItemName
                permissionList = permissionList.concat(i.resourceMenus.map((v: any) =&gt; ```{appCode}:``{v.code}`));
            }
        }
        this.permisstionsMap.set(user.id, new Set(permissionList));
    }
    return this.permisstionsMap.get(user.id) as Set&lt;string&gt;;
}
</code></pre>
<p>下面是 permisson 的直观展示，permission的格式如：construction:violation，冒号前是 appCode，冒号后实际上是 navItemName。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031502120.png" alt="image-20220603150247411" /></p>
<p>同时它在路由配置文件里还有一个名称——schemaId，所以说路由配置文件是前端进行权限控制的地方。如果 schemaId 故意设置错误，就可以屏蔽用户查看此模块的权限。</p>
<pre><code class="language-js">{
   name: &quot;video-monitor&quot;,
   path: &quot;/videomonitor&quot;,
   meta: {
     icon: &quot;icon-videobind&quot;,
     title: &quot;视频监控&quot;,
     schemaId: &quot;construction:video-monitor&quot;
   },
  component: () =&gt; import(&quot;@/pages/construction/views/violation/videomonitor&quot;)
},
</code></pre>
<h2><a id="%E8%A7%86%E5%9B%BE%E9%AA%A8%E6%9E%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>视图骨架</h2>
<h3><a id="%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码结构</h3>
<p>视图骨架相关的代码全部在：src/components/layout 下。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206062046385.png" alt="image-20220606204616719" /></p>
<ul>
<li>layout/index：最外层的 router-view</li>
<li>layout/main/index：中间层的 router-view</li>
<li>layout/blank/index：最内层的 router-view</li>
</ul>
<pre><code class="language-html">&lt;!-- layout/index --&gt;
&lt;!DOCTYPE html&gt;
&lt;div class=&quot;v-layout-wrapper&quot;&gt;
    &lt;u-header v-if=&quot;!hideHeader&quot;&gt;&lt;/u-header&gt;  &lt;!--这里还用到了一个公共组件 header --&gt;
    &lt;section class=&quot;u-body&quot;&gt;
        &lt;router-view&gt;&lt;/router-view&gt;     &lt;!-- router-view --&gt;
    &lt;/section&gt;
&lt;/div&gt;

&lt;!-- --------------------------------------------------------------------------------------- --&gt;
&lt;!-- layout/main/index --&gt;
&lt;section class=&quot;v-main-wrapper&quot;&gt;
    &lt;aside v-if=&quot;!hideSideMenu&quot; class=&quot;u-aside&quot;&gt;  &lt;!-- 侧边栏 --&gt;
        &lt;u-menu :menu-list=&quot;menuList&quot; /&gt;
    &lt;/aside&gt;
    &lt;main class=&quot;u-main&quot; :style=&quot;hideSideMenu? 'padding: 0':''&quot;&gt;
        &lt;section class=&quot;u-breadcrumb&quot;&gt;
            &lt;span&gt;当前位置：&lt;/span&gt;
            &lt;a-breadcrumb&gt;  &lt;!-- 面包屑 --&gt;
                &lt;a-breadcrumb-item v-for=&quot;(item, index) in breadCrumbList&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/a-breadcrumb-item&gt;
            &lt;/a-breadcrumb&gt;
        &lt;/section&gt;
        &lt;section class=&quot;u-page&quot;&gt;
            &lt;keep-alive&gt;
                &lt;router-view&gt;&lt;/router-view&gt;   &lt;!-- router-view --&gt;
            &lt;/keep-alive&gt;
        &lt;/section&gt;
    &lt;/main&gt;
&lt;/section&gt;


&lt;!-- --------------------------------------------------------------------------------------- --&gt;
&lt;!-- layout/blank/index --&gt;
&lt;section class=&quot;v-blank-wrapper&quot;&gt;
    &lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;
        &lt;keep-alive :include=&quot;cachePageList&quot;&gt;
            &lt;router-view&gt;&lt;/router-view&gt;   &lt;!-- router-view --&gt;
        &lt;/keep-alive&gt;
    &lt;/transition&gt;
&lt;/section&gt;
</code></pre>
<p>细心的同学可能发现为啥中间层的 router-view 和 最内层的 router-view 重叠了？实际上我也有此疑问。难不成仅仅是为了使用 transition？不过既然人家提供的框架是这样，我们也不必过于在意。</p>
<h3><a id="%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>路由配置</h3>
<p>下面结合路由配置文件（ pages/项目/routes/index.js）来看，视图骨架是如何使用的？</p>
<ol>
<li>
<p>不管是没有独立首页的 admin 还是有独立首页的 construction，<strong>根视图</strong>都配置的 <code>@/components/layout</code>。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206062011908.png" alt="image-20220606201108480" /></p>
</li>
<li>
<p>如&quot;违规发现&quot;这样<strong>有children的顶部导航</strong>，配置的是：<code>@/components/layout/main</code></p>
<p>如&quot;报警处置&quot;这样<strong>有children的侧边栏导航</strong>，配置的是：<code>@/components/layout/blank</code></p>
<p>如&quot;待处置&quot;这样<strong>没有children的具体导航</strong>，配置的是：<code>@/pages/xxxx</code>具体路径。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206062114018.png" alt="202206062040716" /></p>
</li>
</ol>
<h2><a id="%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>网络请求</h2>
<h3><a id="service%E5%85%B3%E7%B3%BB%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>service关系图</h3>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206080745795.png" alt="servcie关系图" /></p>
<h3><a id="axiosservice-base-ts" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>axios/service-base.ts</h3>
<ol>
<li>底层使用 axios 库作为请求框架，在 service-base.ts 中做了一层封装。</li>
<li>在 service-base.ts 中创建 axios 的实例对象，拦截器，以及封装了一些基本的请求方法（get, post 等等）。</li>
<li>axios 的拦截器中做了很多工作，包括动态拼接 baseUrl、拼接 headers、token、签名鉴权等等。需要注意的是，目前 service-base.ts 存在2个拦截器，一个是 axios 全局拦截器，用于拦截诸如玲珑等我们触碰不到的请求。另一个是 Axios 实例拦截器，用于处理项目内自己发送的请求。</li>
</ol>
<pre><code class="language-js">// 全局过滤器(用于拦截我们触摸不到的JS库中发出的axios请求)
axios.interceptors.request.use(
    (config: AxiosRequestConfig) =&gt; {
        // 拼接baseUrl
        if (config.url &amp;&amp; !ServiceUtil.isAbsoluteURL(config.url)) {
            let baseUrl = ServiceUtil.getBaseUrl(config.url);
            config.url = ServiceUtil.combineUrl(config.url, baseUrl);
        }

        // 添加mis的token
        const token = Cookies.get(&quot;token&quot;);
        config.headers.Authorization = &quot;cas csgl-wh:&quot; + token; //部门服务

        return config;
    },
    (error) =&gt; {
        console.error(error);
        return Promise.reject(error);
    }
);

const globalSource: CancelTokenSource = axios.CancelToken.source();

// Axios 实例
const instance = axios.create({
    // baseURL: commonSetting.baseUrl, //在拦截器中配置，这里只能写死，我们需要动态获取
    timeout: 10000,
    cancelToken: globalSource.token,
    validateStatus: (status: number) =&gt; {
        // token 失效
        if (status === 401) {
            Cookies.remove(&quot;access_token&quot;);
            window.location.replace(`${commonSetting.basePath}#/login`);
        }

        return status &gt;= 200 &amp;&amp; status &lt; 300;
    }
});

// Axios 实例拦截器
instance.interceptors.request.use(
    (config: AxiosRequestConfig) =&gt; {
        // 拼接baseUrl
        if (config.url &amp;&amp; !ServiceUtil.isAbsoluteURL(config.url)) {
            let baseUrl = ServiceUtil.getBaseUrl(config.url);
            config.url = ServiceUtil.combineUrl(config.url, baseUrl);
        }

        // mis的token
        const token = Cookies.get(&quot;token&quot;);
        if (token) {
            if (config.method === &quot;get&quot;) {
                config.params = config.params || {};
                config.params.token = token;
            } else if (config.method === &quot;post&quot;) {
                config.data = config.data ? ```{config.data}&amp;token=``{token}` : `token=${token}`;
            }
        }

        // 处理签名鉴权
        if (commonSetting.enableSignature) {
            signatureConfig(config);
        }

        // 微服务的token
        if (commonSetting.enableMicroServer) {
            const access_token = Cookies.get(&quot;access_token&quot;);
            if (access_token) {
                config.headers.Authorization = &quot;Bearer &quot; + access_token;
            }
        }

        return config;
    },
    (error) =&gt; {
        console.error(error);
        return Promise.reject(error);
    }
);



//---------------------------------封装基本请求方法-----------------------------------------
/**
     * 发送post请求
     * @param url 请求地址
     * @param data 发送的参数
     */
    protected _post&lt;T&gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&lt;T&gt; {
        return instance.post(url, qs.stringify(data), config).then((res) =&gt; res.data);
    }

    /**
     * 发送get请求
     * @param url 请求地址
     */
    protected _get&lt;T&gt;(url: string, params: any = {}, config: AxiosRequestConfig = {}): Promise&lt;T&gt; {
        return instance.get(url, { params, ...config }).then((res) =&gt; res.data);
    }
</code></pre>
<h3><a id="%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用举例</h3>
<ol>
<li>
<p>大多数组件目录都包含一个 service.ts，在 service.ts 中编写发送请求的代码；</p>
<pre><code class="language-js">import { service } from &quot;@egova/base-lib&quot;;
import { CommonService } from &quot;@/services&quot;;

export default class Service extends CommonService {
    @service(&quot;query&quot;, { title: &quot;获取所有视频监控类型&quot; })
    public async getMonitorTypeService(params: any): Promise&lt;any&gt; {
        return this._get(&quot;/unity/microconstruction/monitor/getmonitortypelist&quot;, params);
    }

    @service(&quot;save&quot;, { title: &quot;绑定设备&quot; })
    public async saveDeviceService(params: any): Promise&lt;any&gt; {
        return this._post(&quot;/unity/microconstruction/monitor/insertdevicelist&quot;, params);
    }
}
</code></pre>
</li>
<li>
<p>mis请求的一个特殊点。由于mis请求和微服务请求返回的数据结构不同，为了不改变 service-base 中原来的代码，我单独封装了一个 destruct()，用于处理mis的请求，注意对比下面2个请求的写法。</p>
<pre><code class="language-js">import ServiceBase from &quot;./service-base&quot;;

export default class LoginService extends ServiceBase {
    /**
     * 登录【mis请求】
     * @param params
     */
    public async login(params: any): Promise&lt;any&gt; {
        const res = await this._post(&quot;/login/validpassword&quot;, params); 
				//拿到结果先 destruct一下，然后再 return一个 promise 出去
        return Promise.resolve(this.destruct(res));  
    }


    /**
     * 获取微服务前缀【非mis请求】
     */
    public async getMicroServiceToken(microServiceUrl: string, token: string): Promise&lt;any&gt; {
        // 不需要像 mis 那么麻烦，直接 return 出去即可。
        return await this._get(this.combineUrl(&quot;/token/exchange&quot;, microServiceUrl), { token: token });
    }
}


//------------------------------service-base.ts 中 destruct()----------------------------------
 /**
     * 对响应结果进行解构
     * 城管后台接口返回格式相对固定，拿到返回数据后可以调用一下本方法，简化操作。
     * @param res
     * @protected
     */
    protected destruct(res: any): any {
        if (!res) {
            return res;
        }
        if (res.resultInfo) {
            return res.resultInfo;
        }
        if (res.data) {
            return res.data;
        }
        return res;
    }
</code></pre>
</li>
</ol>
<h2><a id="%E5%A4%9A%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多应用打包</h2>
<h3><a id="%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>执行命令</h3>
<p>npm run serve 项目名</p>
<p>npm run build 项目名</p>
<h3><a id="%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>工作流程图</h3>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206062001357.png" alt="多应用打包流程图" /></p>
<h3><a id="%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AF%A6%E7%BB%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>工作流程详细</h3>
<ol>
<li>pages/index.js 中配置对应项目，以对象形式体现。最重要的是指定入口文件 entry，如：<code>src/pages/admin/main.ts</code>。</li>
</ol>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206061915037.png" alt="image-20220606191531214" /></p>
<ol start="2">
<li>
<p>pages/index.js 中export出去的是什么？</p>
<p>中台框架原来的代码 export 出去的就是 admin 这个对象，经过定制修改后，不再 export 固定对对象，而是根据执行的命令行参数动态获取。 例如执行 <code>npm run serve construction</code>  或 <code>npm run build construction </code>，解析得到的 entry 就是 construction，然后调用 getAppConfig() 得到的就是 construction 对应的js对象。</p>
<pre><code class="language-js">function getAppConfig(entry) {
    if (!entry || !appConfig[entry]) {
        return appConfig.default;
    }
    return appConfig[entry];
}

let entry = &quot;admin&quot;;
if (process.argv[3]) {
    if (process.argv[3].indexOf(&quot;/&quot;) &gt; 0) {
        const matches = process.argv[3].match(/^.+\/(\w+)\/main.ts$/);
        entry = matches[1];
    } else {
        entry = process.argv[3];
    }
}

//获取对应的app配置信息
const app = getAppConfig(entry);

module.exports = app;
</code></pre>
</li>
<li>
<p>page.config.js 中引入前面步骤中 export 出来的项目信息，并且动态计算项目名称 projectName，最后一起 export 出去。</p>
<pre><code class="language-js">const path = require(&quot;path&quot;);

function resolvePage(page) {
    let pagesConfig = require(path.resolve(&quot;./src/pages/index.js&quot;));  // 引入第2步export出的内容
    if (!page) return pagesConfig;
    let obj = {};
    obj[page] = pagesConfig[page];
    return obj;
}

let pages = resolvePage(process.env.page);
// 根据命令行参数计算项目名称 projectName。
let projectName = &quot;admin&quot;;
if (process.argv[3]) {
    if (process.argv[3].indexOf(&quot;/&quot;) &gt; 0) {
        const matches = process.argv[3].match(/^.+\/(\w+)\/main.ts$/);
        projectName = matches[1];
    } else {
        projectName = process.argv[3];
    }
}

//.............................一些逻辑............................
// 启动和打包脚本中会使用这里 export 出的内容。
module.exports = {
    pages: pages,
    plugin: plugin,
    projectName: projectName
};
</code></pre>
</li>
<li>
<p>执行 config/start.js 或 config/update.js 脚本</p>
<p>前面所有步骤都是为最后一步做铺垫，可以看到不管是 start.js 还是 update.js 中都要使用 page.config.js 中 export 出的东西。其实主要就是 pages 和 projectName 这两个数据。</p>
<pre><code class="language-js">// config/start.js
const cp = require(&quot;child_process&quot;);
const { pages } = require(&quot;../page.config&quot;);   // 引入项目配置

class Process {
	
}


// config/update.js
const cp = require(&quot;child_process&quot;);
const os = require(&quot;os&quot;);
const { promisify } = require(&quot;util&quot;);
const chalk = require(&quot;chalk&quot;);
const config = require(&quot;../vue.config&quot;);
const path = require(&quot;path&quot;);
const fs = require(&quot;fs&quot;);
const readdir = promisify(fs.readdir);
const compressing = require(&quot;compressing&quot;);
const { projectName } = require(&quot;../page.config&quot;);  // 引入项目配置

class Update {
  
}
</code></pre>
<p>以 start.js 为例， <code>npm run serve construction</code>  实际上会执行分支语句 <code>this.run_vue_cli()</code>。在方法内部会开启一个进程执行 <code>vue-cli-service</code>，即：<code>this.run_process(&quot;vue-cli-service&quot;, params)</code>  ，注意，这个脚本是 vue 内置的。this.entry 是什么？很显然，就是我们在 pages/index.js 中配置的项目入口文件 <code>src/pages/construction/main.ts</code>。 也就是说我们最后执行的命令相当于： <code>vue-cli-service src/pages/construction/main.ts</code>。</p>
<p><strong>总结：所谓多应用启动或多应用打包并没有多高大上，本质上就是入口文件不要写死，而是动态获取，只要你做到了根据命令行参数动态获取入口文件，那就是多应用。</strong></p>
<pre><code class="language-js">switch (command) {
            case &quot;serve&quot;:
                this.run_vue_cli();
                break;
            case &quot;build&quot;:
                this.run_vue_cli();
                this.run_update();
                break;
            case &quot;check&quot;:
                this.run_http_server();
                break;
        }

//-----------------------------------------------------------------------------
// params 举例：[ 'serve', 'src/pages/construction/main.ts' ]
run_vue_cli() {
        const params = this.entry ? [this.command, this.entry] : [this.command];
        this.webpack_process = this.run_process(&quot;vue-cli-service&quot;, params);
    }
</code></pre>
<ol start="5">
<li>
<p>最后我们看一下入口文件中到底做了什么？答案：启动应用程序。</p>
<blockquote>
<p>具体怎么启动需要研究 base-lib 包，不再本文档讨论范围，感兴趣的同学自行研究。</p>
</blockquote>
<pre><code class="language-js">import { routes } from &quot;./routes&quot;;
import modules from &quot;@/store&quot;;
import { Application } from &quot;@egova/base-lib&quot;;

import ApplicationContext from &quot;@/application/context&quot;;

// 获取应用上下文
let context = new ApplicationContext(routes, modules);

// 启动应用程序
Application.start(context);
</code></pre>
</li>
</ol>
</li>
</ol>
<h1><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h1>
<p>屈指算来，自部门推行Vue新框架以来差不多有两三个月了，在使用它处理现场需求的过程中，我们的框架也在逐步完善，可以看到很多实用的功能正在源源不断的加入进去，第三方登录啊，玲珑啊，多应用打包啊...，一切都是为了打造更好的产品，提升用户体验，增加部门乃至整个公司的前端产品的竞争力。然而毕竟时间尚短，加之我一个人精力有限，所以肯定还存在许多需要优化的地方，希望后期更多的小伙伴们加入进来，群策群力，让 urban-manage-vue 变得越来越完善，前端开发越来越轻松。最后，祝大家端午节快乐！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vue3.0学习笔记]]></title>
    <link href="http://yuanchao.blogs.io/16540461699027.html"/>
    <updated>2022-06-01T09:16:09+08:00</updated>
    <id>http://yuanchao.blogs.io/16540461699027.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#vue3%E7%AE%80%E4%BB%8B">Vue3简介</a>
<ul>
<li><a href="#vue3%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88">Vue3带来了什么</a>
<ul>
<li><a href="#%E6%80%A7%E8%83%BD%E7%9A%84%E6%8F%90%E5%8D%87">性能的提升</a></li>
<li><a href="#%E6%BA%90%E7%A0%81%E7%9A%84%E5%8D%87%E7%BA%A7">源码的升级</a></li>
<li><a href="#%E6%8B%A5%E6%8A%B1typescript">拥抱TypeScript</a></li>
<li><a href="#%E6%96%B0%E7%9A%84%E7%89%B9%E6%80%A7">新的特性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BAvue3-0%E5%B7%A5%E7%A8%8B">创建Vue3.0工程</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8vue-cli%E5%88%9B%E5%BB%BA">使用 vue-cli 创建</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8vite%E5%88%9B%E5%BB%BA">使用 vite 创建</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8composition-api">常用 Composition API</a>
<ul>
<li><a href="#%E6%8B%89%E5%BC%80%E5%BA%8F%E5%B9%95%E7%9A%84setup">拉开序幕的setup</a></li>
<li><a href="#ref%E5%87%BD%E6%95%B0">ref函数</a></li>
<li><a href="#reactive%E5%87%BD%E6%95%B0">reactive函数</a></li>
<li><a href="#vue3-0%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86">Vue3.0中的响应式原理</a>
<ul>
<li><a href="#vue2-x%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F">vue2.x的响应式</a></li>
<li><a href="#vue3-0%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F">Vue3.0的响应式</a></li>
</ul>
</li>
<li><a href="#reactive%E5%AF%B9%E6%AF%94ref">reactive对比ref</a></li>
<li><a href="#setup%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9">setup的两个注意点</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%91%E8%A7%86">计算属性与监视</a>
<ul>
<li><a href="#computed%E5%87%BD%E6%95%B0">computed函数</a></li>
<li><a href="#watch%E5%87%BD%E6%95%B0">watch函数</a></li>
<li><a href="#watcheffect%E5%87%BD%E6%95%B0">watchEffect函数</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">生命周期</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89hook%E5%87%BD%E6%95%B0">自定义hook函数</a></li>
<li><a href="#toref">toRef</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E5%AE%83composition-api">其它 Composition API</a>
<ul>
<li><a href="#shallowreactive%E4%B8%8E-shallowref">shallowReactive 与 shallowRef</a></li>
<li><a href="#readonly%E4%B8%8E-shallowreadonly">readonly 与 shallowReadonly</a></li>
<li><a href="#toraw%E4%B8%8E-markraw">toRaw 与 markRaw</a></li>
<li><a href="#customref">customRef</a></li>
<li><a href="#provide%E4%B8%8E-inject">provide 与 inject</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A4%E6%96%AD">响应式数据的判断</a></li>
</ul>
</li>
<li><a href="#composition-api%E7%9A%84%E4%BC%98%E5%8A%BF">Composition API 的优势</a>
<ul>
<li><a href="#options-api%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">Options API 存在的问题</a></li>
<li><a href="#composition-api%E7%9A%84%E4%BC%98%E5%8A%BF">Composition API 的优势</a></li>
</ul>
</li>
<li><a href="#%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6">新的组件</a>
<ul>
<li><a href="#fragment">Fragment</a></li>
<li><a href="#teleport">Teleport</a></li>
<li><a href="#suspense">Suspense</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a>
<ul>
<li><a href="#%E5%85%A8%E5%B1%80api%E7%9A%84%E8%BD%AC%E7%A7%BB">全局API的转移</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%94%B9%E5%8F%98">其他改变</a></li>
</ul>
</li>
</ul>
<h2><a id="vue3%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3简介</h2>
<ul>
<li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li>
<li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a></li>
<li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li>
</ul>
<h2><a id="vue3%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3带来了什么</h2>
<h3><a id="%E6%80%A7%E8%83%BD%E7%9A%84%E6%8F%90%E5%8D%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>性能的提升</h3>
<ul>
<li>
<p>打包大小减少41%</p>
</li>
<li>
<p>初次渲染快55%, 更新渲染快133%</p>
</li>
<li>
<p>内存减少54%</p>
<p>......</p>
</li>
</ul>
<h3><a id="%E6%BA%90%E7%A0%81%E7%9A%84%E5%8D%87%E7%BA%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>源码的升级</h3>
<ul>
<li>
<p>使用Proxy代替defineProperty实现响应式</p>
</li>
<li>
<p>重写虚拟DOM的实现和Tree-Shaking</p>
<p>......</p>
</li>
</ul>
<h3><a id="%E6%8B%A5%E6%8A%B1typescript" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拥抱TypeScript</h3>
<ul>
<li>Vue3可以更好的支持TypeScript</li>
</ul>
<h3><a id="%E6%96%B0%E7%9A%84%E7%89%B9%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>新的特性</h3>
<ol>
<li>
<p>Composition API（组合API）</p>
<ul>
<li>setup配置</li>
<li>ref与reactive</li>
<li>watch与watchEffect</li>
<li>provide与inject</li>
<li>......</li>
</ul>
</li>
<li>
<p>新的内置组件</p>
<ul>
<li>Fragment</li>
<li>Teleport</li>
<li>Suspense</li>
</ul>
</li>
<li>
<p>其他改变</p>
<ul>
<li>新的生命周期钩子</li>
<li>data 选项应始终被声明为一个函数</li>
<li>移除keyCode支持作为 v-on 的修饰符</li>
<li>......</li>
</ul>
</li>
</ol>
<h1><a id="%E5%88%9B%E5%BB%BAvue3-0%E5%B7%A5%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建Vue3.0工程</h1>
<h2><a id="%E4%BD%BF%E7%94%A8vue-cli%E5%88%9B%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 vue-cli 创建</h2>
<p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p>
<pre><code class="language-bash">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上
vue --version
## 安装或者升级你的@vue/cli
npm install -g @vue/cli
## 创建
vue create vue_test
## 启动
cd vue_test
npm run serve
</code></pre>
<h2><a id="%E4%BD%BF%E7%94%A8vite%E5%88%9B%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 vite 创建</h2>
<p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p>
<p>vite官网：<a href="https://vitejs.cn">https://vitejs.cn</a></p>
<ul>
<li>什么是vite？—— 新一代前端构建工具。</li>
<li>优势如下：
<ul>
<li>开发环境中，无需打包操作，可快速的冷启动。</li>
<li>轻量快速的热重载（HMR）。</li>
<li>真正的按需编译，不再等待整个应用编译完成。</li>
</ul>
</li>
<li>传统构建 与 vite构建对比图</li>
</ul>
<p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" /></p>
<pre><code class="language-bash">## 创建工程
npm init vite-app &lt;project-name&gt;
## 进入工程目录
cd &lt;project-name&gt;
## 安装依赖
npm install
## 运行
npm run dev
</code></pre>
<h1><a id="%E5%B8%B8%E7%94%A8composition-api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用 Composition API</h1>
<p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p>
<h2><a id="%E6%8B%89%E5%BC%80%E5%BA%8F%E5%B9%95%E7%9A%84setup" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拉开序幕的setup</h2>
<ol>
<li>
<p>理解：Vue3.0中一个新的配置项，值为一个函数。</p>
</li>
<li>
<p>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</p>
</li>
<li>
<p>组件中所用到的：数据、方法等等，均要配置在setup中。</p>
</li>
<li>
<p>setup函数的两种返回值：</p>
<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li>
</ol>
</li>
<li>
<p>注意点：</p>
<ol>
<li>尽量不要与Vue2.x配置混用
<ul>
<li>Vue2.x配置（data、methos、computed...）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed...）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
</ol>
</li>
<li>
<p>示例代码</p>
<pre><code class="language-js">&lt;script&gt;
// import {h} from 'vue'
export default {
  name: 'App',
  // vue3是向下兼容的，vue文件里还可以使用 data、methods 等
  data() {
    return {
      sex:'男',
      a:100
    }
  },
  methods: {
    sayWelcome(){
      alert('欢迎来到尚硅谷学习')
    },
    test1(){
      console.log(this.sex)
      console.log(this.name)
      console.log(this.age)
      console.log(this.sayHello)
    }
  },

  //setup里的数据和方法template里都能识别到
  setup(){
    //数据
    let name = '张三'
    let age = 18
    let a = 200

    //方法
    function sayHello(){
      alert(`我叫``{name}，我``{age}岁了，你好啊！`)
    }
    function test2(){
      console.log(name)
      console.log(age)
      console.log(sayHello)
      console.log(this.sex)
      console.log(this.sayWelcome)
    }

    //返回一个对象（常用）
    return {
      name,
      age,
      sayHello,
      test2,
      a
    }

    //返回一个函数（渲染函数）
    // return ()=&gt; h('h1','尚硅谷')
  }
}
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h2><a id="ref%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ref函数</h2>
<ul>
<li>
<p>作用: 定义一个响应式的数据</p>
</li>
<li>
<p>语法: <code>const xxx = ref(initValue)</code></p>
<ul>
<li>
<p>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</p>
</li>
<li>
<p>JS中操作数据： <code>xxx.value</code></p>
</li>
<li>
<p>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;{{xxx}}&lt;/div&gt;</code></p>
</li>
<li>
<p>RefImpl 如下：</p>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205300856268.png" alt="image-20220530085646330" style="zoom:75%;" />
</li>
</ul>
</li>
<li>
<p>备注：</p>
<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠\(Object.defineProperty()\)的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。reactive函数中封装了Proxy的处理逻辑。</li>
<li>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205300903127.png" alt="image-20220530090259312" style="zoom:75%;" />
</li>
</ul>
</li>
</ul>
<p>​</p>
<h2><a id="reactive%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>reactive函数</h2>
<ul>
<li>
<p>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</p>
</li>
<li>
<p>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></p>
</li>
<li>
<p>reactive定义的响应式数据是“深层次的”。</p>
</li>
<li>
<p>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</p>
</li>
<li>
<p>不需要像 ref 定义的响应式变量那样 variable.value 的方式取值，直接使用 variable 即可。</p>
<pre><code class="language-js">// 基本数据类型，只能使用 ref
let name = ref('张三')
let age = ref(18)

// 引用类型数据，可以使用 ref 和 reactive，但有区别，前者要通过 .value 取值，引用类型时 ref 内部也是使用reactive
let job = reactive({
   type:'前端工程师',
   salary:'30K'
})
let hobbies = reactive([&quot;篮球&quot;, &quot;乒乓球&quot;])


function changeInfo(){
   // 基本类型 .value 取值
	 name.value = '李四'
   age.value = 48
  
   // 引用类型，不需要value
   job.type = 'UI设计师'
   job.salary = '60K'
   hobbies[0] = &quot;象棋&quot;
} 
</code></pre>
</li>
</ul>
<h2><a id="vue3-0%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3.0中的响应式原理</h2>
<h3><a id="vue2-x%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>vue2.x的响应式</h3>
<ul>
<li>
<p>实现原理：</p>
<ul>
<li>
<p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li>
<p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<pre><code class="language-js">Object.defineProperty(data, 'count', {
    get () {}, 
    set () {}
})

let p = {}
Object.defineProperty(p,'name',{
		configurable:true,
				get(){ //有人读取name时调用
					return person.name
		},
		set(value){ //有人修改name时调用
				console.log('有人修改了name属性，我发现了，我要去更新界面！')
				person.name = value
		}
})
			
Object.defineProperty(p,'age',{
	get(){ //有人读取age时调用
			eturn person.age
	},
	set(value){ //有人修改age时调用
			console.log('有人修改了age属性，我发现了，我要去更新界面！')
			person.age = value
	}
})
</code></pre>
</li>
</ul>
</li>
<li>
<p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h3><a id="vue3-0%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3.0的响应式</h3>
<ul>
<li>
<p>实现原理:</p>
<ul>
<li>
<p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p>
</li>
<li>
<p>通过Reflect（反射）:  对源对象的属性进行操作。</p>
</li>
<li>
<p>MDN文档中描述的Proxy与Reflect：</p>
<ul>
<li>
<p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
</li>
<li>
<p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
<pre><code class="language-js">const p = new Proxy(person,{
		/有人读取p的某个属性时调用
		get(target,propName){
				console.log(`有人读取了p身上的${propName}属性`)
  			// return target[propName]
				return Reflect.get(target,propName)  //Vue3中使用了Reflect处理真正的数据，效果是一样的。
		},
		//有人修改p的某个属性、或给p追加某个属性时调用
		set(target,propName,value){
			console.log(`有人修改了p身上的${propName}属性，我要去更新界面了！`)
      // target[propName] = value;
			Reflect.set(target,propName,value)
		},
		//有人删除p的某个属性时调用
			deleteProperty(target,propName){
			console.log(`有人删除了p身上的${propName}属性，我要去更新界面了！`)
      // return delete target[propName];
			return Reflect.deleteProperty(target,propName)
		}
})

// Proxy 的基本用法
new Proxy(data, {
	// 拦截读取属性值
    get (target, prop) {
    	return Reflect.get(target, prop)
    },
    // 拦截设置属性值或添加新属性
    set (target, prop, value) {
    	return Reflect.set(target, prop, value)
    },
    // 拦截删除属性
    deleteProperty (target, prop) {
    	return Reflect.deleteProperty(target, prop)
    }
})

proxy.name = 'tom'   
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a id="reactive%E5%AF%B9%E6%AF%94ref" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>reactive对比ref</h2>
<ul>
<li>
<p>从定义数据角度对比：</p>
<ul>
<li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li>
<li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li>
<li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li>
</ul>
</li>
<li>
<p>从原理角度对比：</p>
<ul>
<li>ref通过\(Object.defineProperty()\)的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li>
</ul>
</li>
<li>
<p>从使用角度对比：</p>
<ul>
<li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li>
<li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li>
</ul>
</li>
</ul>
<h2><a id="setup%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>setup的两个注意点</h2>
<ul>
<li>
<p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li>
<p>setup的参数</p>
<ul>
<li>
<p>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</p>
</li>
<li>
<p>context：上下文对象</p>
<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
<pre><code class="language-js">// Person.vue 组件
&lt;template&gt;
  &lt;h1&gt;一个人的信息&lt;/h1&gt;
  &lt;h2&gt;姓名：{{person.name}}&lt;/h2&gt;
  &lt;h2&gt;年龄：{{person.age}}&lt;/h2&gt;
  &lt;h3&gt;兴趣爱好: {{person.hobbies}}&lt;/h3&gt;
  &lt;slot name=&quot;hello&quot;&gt;&lt;/slot&gt;
  &lt;button @click=&quot;changeInfo&quot;&gt;修改人的信息&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
import {reactive} from 'vue'

export default {
  name: 'App',
  props:[&quot;school&quot;],
  emits: [&quot;changeInfo&quot;], // 这里不加的话控制台会有警告
  setup(props, context){
    console.log(props)
    console.log(context)
    console.log(context.slots)
    //数据
    let person = reactive({
      name: &quot;张三&quot;,
      age: 18,
      hobbies: [&quot;篮球&quot;, &quot;乒乓球&quot;]
    })

    //方法
    function changeInfo(){
      person.name = &quot;李四&quot;
      person.age = 29
      person.hobbies[0] = &quot;象棋&quot;
      // 触发事件
      context.emit(&quot;changeInfo&quot;, &quot;我修改用户信息了&quot;)
    }

    return {
      person,
      changeInfo
    }
  }
}
&lt;/script&gt;


// App.vue
&lt;template&gt;
  &lt;!-- 绑定自定义事件、slot内容、传递 props --&gt;
  &lt;Person school=&quot;清华&quot; @changeInfo=&quot;handleChange&quot;&gt;
    &lt;template v-slot:hello&gt;
      &lt;span&gt;尚硅谷&lt;/span&gt;
    &lt;/template&gt;
  &lt;/Person&gt;
&lt;/template&gt;

&lt;script&gt;
import Person from &quot;./components/Person&quot;
export default {
  name: 'App',
  components:{
    Person
  },
  setup(){
    function handleChange(msg){
      console.log(msg)
    }

    return {
      handleChange
    }
  }
}
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2><a id="%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%91%E8%A7%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算属性与监视</h2>
<h3><a id="computed%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>computed函数</h3>
<ul>
<li>
<p>与Vue2.x中computed配置功能一致</p>
</li>
<li>
<p>写法</p>
<pre><code class="language-js">import {computed} from 'vue'

setup(){
    ...
	//计算属性——简写
    let fullName = computed(()=&gt;{
        return person.firstName + '-' + person.lastName
    })
    //计算属性——完整
    let fullName = computed({
        get(){
            return person.firstName + '-' + person.lastName
        },
        set(value){
            const nameArr = value.split('-')
            person.firstName = nameArr[0]
            person.lastName = nameArr[1]
        }
    })
}
</code></pre>
</li>
</ul>
<h3><a id="watch%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>watch函数</h3>
<ul>
<li>
<p>与Vue2.x中watch配置功能一致</p>
</li>
<li>
<p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个引用类型属性时：deep配置有效。</li>
</ul>
<pre><code class="language-js">//情况一：监视ref定义的响应式数据
watch(sum,(newValue,oldValue)=&gt;{
	console.log('sum变化了',newValue,oldValue)
},{immediate:true})  // 第三个参数是可选的

//情况二：监视多个ref定义的响应式数据
watch([sum,msg],(newValue,oldValue)=&gt;{
  // newValue 和 oldValue 变成数组，顺序与[sum,msg]保持一致
	console.log('sum或msg变化了',newValue,oldValue)  
}) 

/* 情况三：监视reactive定义的响应式数据
			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！
			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 
*/
watch(person,(newValue,oldValue)=&gt;{
	console.log('person变化了',newValue,oldValue)
},{immediate:true,deep:false}) //此处的deep配置不再奏效

//情况四：监视reactive定义的响应式数据中的某个属性
watch(()=&gt;person.job,(newValue,oldValue)=&gt;{
	console.log('person的job变化了',newValue,oldValue)
},{immediate:true,deep:true}) 

//情况五：监视reactive定义的响应式数据中的某些属性
watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;{
	console.log('person的job变化了',newValue,oldValue)
},{immediate:true,deep:true})

//特殊情况
watch(()=&gt;person.job,(newValue,oldValue)=&gt;{
    console.log('person的job变化了',newValue,oldValue)
},{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效
</code></pre>
</li>
<li>
<p>watch监视ref数据</p>
</li>
</ul>
<pre><code class="language-js">&lt;script&gt;
	import {ref,reactive,watch} from 'vue'
	export default {
		name: 'Demo',
		setup(){
			//数据
			let sum = ref(0);       // 这里是用ref定义基本类型数据，sum是一个RefImpl对象，sum.value是一个常量值.
			let msg = ref('你好啊');
			let person = ref({      // 这里是用ref定义引用类型数据，person也是RefImpl对象，但person.value是Proxy对象.
				name:'张三',
				age:18,
				job:{
					j1:{
						salary:20
					}
				}
			})

			console.log(person)

      // 这里不能用sum.value，因为sum是基本数据类型，sum.value 是一个常量值，不能被监视.
			watch(sum,(newValue,oldValue)=&gt;{
				console.log('sum的值变化了',newValue,oldValue)
			})

      // 如果不开启 deep:true，则这里必须监视 person.value 才能监测到name、age等数据的变化，
      // person是一个引用类型数据，person.value 是Proxy对象，是ref函数内部调用reactive函数生成的。
      watch(person.value,(newValue,oldValue)=&gt;{
        console.log('person的值变化了',newValue,oldValue)
      })

      // 如果开启了 deep:true，则这里可以直接监视person
			watch(person,(newValue,oldValue)=&gt;{
				console.log('person的值变化了',newValue,oldValue)
			},{deep:true})


			//返回一个对象（常用）
			return {
				sum,
				msg,
				person
			}
		}
	}
&lt;/script&gt;
</code></pre>
<h3><a id="watcheffect%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>watchEffect函数</h3>
<ul>
<li>
<p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li>
<p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中<strong>用到哪个属性，那就监视哪个属性</strong>。</p>
</li>
<li>
<p>watchEffect有点像computed：</p>
<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
<pre><code class="language-js">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。
watchEffect(()=&gt;{
    const x1 = sum.value
    const x2 = person.age
    const x3 = person.job.salary
    console.log('watchEffect配置的回调执行了')
})
</code></pre>
</li>
</ul>
<h2><a id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生命周期</h2>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206010950892.png" alt="image-20220601095010005" /></p>
<ul>
<li>
<p>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：</p>
<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>
<p>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：</p>
<ul>
<li><code>beforeCreate</code>===&gt;<code>setup()</code></li>
<li><code>created</code>=======&gt;<code>setup()</code></li>
<li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>=======&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> =======&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li>
</ul>
</li>
<li>
<p>组合式API生命周期验证</p>
<pre><code class="language-js">// Student.vue
&lt;template&gt;
  &lt;h1&gt;学生信息&lt;/h1&gt;
  &lt;h2&gt;姓名：{{ student.name }}&lt;/h2&gt;
  &lt;h2&gt;年龄：{{ student.age }}&lt;/h2&gt;
  &lt;h3&gt;兴趣爱好: {{ student.hobbies }}&lt;/h3&gt;
  &lt;button @click=&quot;changeInfo&quot;&gt;修改人的信息&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
import {reactive, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted} from 'vue'

export default {
  name: 'Student',
  setup(props, context) {
    let student = reactive({
      name: &quot;张三&quot;,
      age: 18,
      hobbies: [&quot;篮球&quot;, &quot;乒乓球&quot;],
    });

    const changeInfo = ()=&gt;{
      student.name = &quot;李四&quot;
      student.age = 22
      student.hobbies[0] = &quot;象棋&quot;
    }

    const destroy = () =&gt; {
      console.log(context)
    }

    //通过组合式API的形式去使用生命周期钩子
    onBeforeMount(() =&gt; {
      console.log('---onBeforeMount---')
    })
    onMounted(() =&gt; {
      console.log('---onMounted---')
    })
    onBeforeUpdate(() =&gt; {
      console.log('---onBeforeUpdate---')
    })
    onUpdated(() =&gt; {
      console.log('---onUpdated---')
    })
    onBeforeUnmount(() =&gt; {
      console.log('---onBeforeUnmount---')
    })
    onUnmounted(() =&gt; {
      console.log('---onUnmounted---')
    })

    return {
      student,
      changeInfo
    }
  }
}
&lt;/script&gt;


// App.vue 中通过 v-if 创建和销毁Student组件，从而让Student组件可以响应onBeforeUnmount和unmount生命周期函数。
&lt;template&gt;
  &lt;Student v-if=&quot;show&quot;/&gt;
  &lt;hr/&gt;
  &lt;button @click=&quot;toggle&quot;&gt;显示/隐藏&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
import {ref} from 'vue'
import Student from &quot;./components/Student&quot;

export default {
  name: 'App',
  components: {
    Person, Student
  },
  setup() {
    const show = ref(true);

    function toggle() {
      show.value = !show.value;
    }

    return {
      show,
      toggle
    }
  }
}
&lt;/script&gt;
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205310920909.png" alt="image-20220531092036051" /></p>
</li>
</ul>
<h2><a id="%E8%87%AA%E5%AE%9A%E4%B9%89hook%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义hook函数</h2>
<ul>
<li>
<p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>
</li>
<li>
<p>类似于vue2.x中的mixin。</p>
</li>
<li>
<p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
</li>
<li>
<p>获取鼠标点击位置坐标的案例</p>
<pre><code class="language-js">// 自定义 usePoint hook 函数
import {onBeforeUnmount, onMounted, reactive} from &quot;vue&quot;;

export default function () {
    // 鼠标“打点”相关的数据
    const point = reactive({
        x: 0,
        y: 0
    })

    // 鼠标“打点”相关的方法
    function savePoint(event) {
        point.x = event.pageX
        point.y = event.pageY
        console.log(`x坐标: ``{point.x}, y坐标: ``{point.y}`)
    }

    // 鼠标“打点”相关的生命周期钩子
    onMounted(() =&gt; {
        window.addEventListener(&quot;click&quot;, savePoint)
    })

    onBeforeUnmount(() =&gt; {
        window.removeEventListener(&quot;click&quot;, savePoint)
    })

    // 必须要把hooks里定义的响应式变量return出去，外部才可以使用.
    return point
}

//--------------------------------------------------------------------------------
// Test1组件 使用到了 usePoint
&lt;template&gt;
  &lt;h3&gt;Test1组件&lt;/h3&gt;
  &lt;h3&gt;x坐标：{{ point.x }}，y坐标：{{ point.y }}&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
import usePoint from &quot;../hooks/usePoint&quot;;

export default {
  name: 'Test1',
  setup() {
    const point = usePoint();

    return {
      point
    }
  }
}
&lt;/script&gt;

//--------------------------------------------------------------------------------
// Test2组件 使用到了 usePoint
&lt;template&gt;
  &lt;h3&gt;Test2组件&lt;/h3&gt;
  &lt;h3&gt;x坐标：{{ point.x }}，y坐标：{{ point.y }}&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
import usePoint from &quot;../hooks/usePoint&quot;;

export default {
  name: 'Test2',
  setup() {
    const point = usePoint();

    return {
      point
    }
  }
}
&lt;/script&gt;

//--------------------------------------------------------------------------------
// App.vue 引用Test1和Test2组件
&lt;template&gt;
  &lt;Test1/&gt;
  &lt;hr/&gt;
  &lt;Test2/&gt;
&lt;/template&gt;

&lt;script&gt;
import Test1 from &quot;./components/Test1&quot;
import Test2 from &quot;./components/Test2&quot;

export default {
  name: 'App',
  components: {
    Test1, Test2
  }
}
&lt;/script&gt;
</code></pre>
<p>当点击屏幕任意位置时，Test1组件和Test2组件都输出对应坐标，所以控制台每次点击后都输出2遍。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205311152504.gif" alt="2022-05-31 11.52.08" /></p>
</li>
</ul>
<h2><a id="toref" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>toRef</h2>
<ul>
<li>
<p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p>
</li>
<li>
<p>语法：<code>const name = toRef(person,'name')</code></p>
</li>
<li>
<p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p>
</li>
<li>
<p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p>
</li>
<li>
<p>对比使用 toRef / toRefs 与不使用的区别。</p>
<pre><code class="language-js">// 不使用toRef(s)时，模板中需要使用 person.xxx
&lt;template&gt;
  &lt;h1&gt;一个人的信息&lt;/h1&gt;
  &lt;h2&gt;姓名：{{ person.name }}&lt;/h2&gt;
  &lt;h2&gt;年龄：{{ person.age }}&lt;/h2&gt;
  &lt;h3&gt;薪水: {{ person.job.j1.salary }}&lt;/h3&gt;
  &lt;button @click=&quot;person.name=person.name+'*'&quot;&gt;修改姓名&lt;/button&gt;
  &lt;button @click=&quot;person.age++&quot;&gt;修改年龄&lt;/button&gt;
  &lt;button @click=&quot;person.job.j1.salary++&quot;&gt;修改薪水&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
import {reactive} from 'vue'

export default {
  name: 'Person',
  setup() {
    //数据
    let person = reactive({
      name: &quot;张三&quot;,
      age: 18,
      job: {
        j1: {
          salary: 20
        }
      }
    })

    return {
      person,
    }
  }
}
&lt;/script&gt;

//----------------------------------------------------------------------------------------------
// 使用toRef(s)时，模板中可以省略 person.
&lt;template&gt;
  &lt;h1&gt;一个人的信息&lt;/h1&gt;
  &lt;h2&gt;姓名：{{ name }}&lt;/h2&gt;
  &lt;h2&gt;年龄：{{ age }}&lt;/h2&gt;
  &lt;h3&gt;薪水: {{ job.j1.salary }}&lt;/h3&gt;
  &lt;button @click=&quot;name=name+'*'&quot;&gt;修改姓名&lt;/button&gt;
  &lt;button @click=&quot;age++&quot;&gt;修改年龄&lt;/button&gt;
  &lt;button @click=&quot;job.j1.salary++&quot;&gt;修改薪水&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
import {reactive, toRef, toRefs} from 'vue'

export default {
  name: 'Person',
  setup() {
    //数据
    let person = reactive({
      name: &quot;张三&quot;,
      age: 18,
      job: {
        j1: {
          salary: 20
        }
      }
    })

    // toRef 只能处理单个属性
    console.log(toRef(person, &quot;name&quot;));
    // toRefs 可以批量处理对象上的所有属性
    console.log(toRefs(person));

    return {
      person,
      ...toRefs(person)    // toRefs得到的是一个key与person相同、value均为响应式对象的键值对，故这里通过...展开。
    }
  }
}
&lt;/script&gt;
</code></pre>
<p>下面是 toRef 和 toRefs 输出结果，其中 ObjectRefImpl 就是响应式对象。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205312243758.png" alt="image-20220531224350506" /></p>
</li>
</ul>
<p>​		<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205312247199.gif" alt="2022-05-31 22.45.40" style="zoom:50%;" /></p>
<h1><a id="%E5%85%B6%E5%AE%83composition-api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其它 Composition API</h1>
<h2><a id="shallowreactive%E4%B8%8E-shallowref" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>shallowReactive 与 shallowRef</h2>
<ul>
<li>
<p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>
</li>
<li>
<p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li>
<p>什么时候使用?</p>
<ul>
<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li>
<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h2><a id="readonly%E4%B8%8E-shallowreadonly" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>readonly 与 shallowReadonly</h2>
<ul>
<li>
<p>readonly: 让一个响应式数据变为只读的（深只读）。</p>
</li>
<li>
<p>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</p>
</li>
<li>
<p>应用场景: 不希望数据被修改时。</p>
</li>
<li>
<p>示例代码</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;h4&gt;当前求和为：{{sum}}&lt;/h4&gt;
  &lt;button @click=&quot;sum++&quot;&gt;点我++&lt;/button&gt;
  &lt;hr&gt;
  &lt;h2&gt;姓名：{{name}}&lt;/h2&gt;
  &lt;h2&gt;年龄：{{age}}&lt;/h2&gt;
  &lt;h2&gt;薪资：{{job.j1.salary}}K&lt;/h2&gt;
  &lt;button @click=&quot;name+='~'&quot;&gt;修改姓名&lt;/button&gt;
  &lt;button @click=&quot;age++&quot;&gt;增长年龄&lt;/button&gt;
  &lt;button @click=&quot;job.j1.salary++&quot;&gt;涨薪&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
import {ref,reactive,toRefs,readonly,shallowReadonly} from 'vue'
export default {
  name: 'Person',
  setup(){
    let sum = ref(0)
    let person = reactive({
      name:'张三',
      age:18,
      job:{
        j1:{
          salary:20
        }
      }
    })

    // 对引用类型数据的响应式数据，readonly是深只读，shallowReadonly是浅只读.
    // person = readonly(person)
    person = shallowReadonly(person)
    
    // 对基本类型数据的响应式数据，readonly和shallowReadonly效果一样.
    // sum = readonly(sum)
    sum = shallowReadonly(sum)

    //返回一个对象（常用）
    return {
      sum,
      ...toRefs(person)
    }
  }
}
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h2><a id="toraw%E4%B8%8E-markraw" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>toRaw 与 markRaw</h2>
<ul>
<li>
<p>toRaw：</p>
<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>(只能作用于reactive生成的响应式对象，ref生成的不可以)。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>
<p>markRaw：</p>
<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>
<li>应用场景:
<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>示例代码</p>
<pre><code class="language-js">&lt;template&gt;
	&lt;h4&gt;当前求和为：{{sum}}&lt;/h4&gt;
	&lt;button @click=&quot;sum++&quot;&gt;点我++&lt;/button&gt;
	&lt;hr&gt;
	&lt;h2&gt;姓名：{{name}}&lt;/h2&gt;
	&lt;h2&gt;年龄：{{age}}&lt;/h2&gt;
	&lt;h2&gt;薪资：{{job.j1.salary}}K&lt;/h2&gt;
	&lt;h3 v-show=&quot;person.car&quot;&gt;座驾信息：{{person.car}}&lt;/h3&gt;
	&lt;button @click=&quot;name+='~'&quot;&gt;修改姓名&lt;/button&gt;
	&lt;button @click=&quot;age++&quot;&gt;增长年龄&lt;/button&gt;
	&lt;button @click=&quot;job.j1.salary++&quot;&gt;涨薪&lt;/button&gt;
	&lt;button @click=&quot;showRawPerson&quot;&gt;输出最原始的person&lt;/button&gt;
	&lt;button @click=&quot;addCar&quot;&gt;给人添加一台车&lt;/button&gt;
	&lt;button @click=&quot;person.car.name+='!'&quot;&gt;换车名&lt;/button&gt;
	&lt;button @click=&quot;changePrice&quot;&gt;换价格&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
	import {ref,reactive,toRefs,toRaw,markRaw} from 'vue'
	export default {
		name: 'Demo',
		setup(){
			//数据
			let sum = ref(0)
			let person = reactive({
				name:'张三',
				age:18,
				job:{
					j1:{
						salary:20
					}
				}
			})

			function showRawPerson(){
				const p = toRaw(person)
				console.log(p)
        p.age++  // 这里修改p.age并不会引起页面更新,因为p不是响应式的
			}

			function addCar(){
				let car = {name:'奔驰',price:40}
        // 使用markRaw后，car不再是响应式，如果 person.car = car，则car会变成响应式对象，并且是深度的。
				person.car = markRaw(car)
			}

			function changePrice(){
				person.car.price++  // person.car.price确实变了，但是页面不会更新，因为person.car不是响应式
				console.log(person.car.price) 
			}

			//返回一个对象（常用）
			return {
				sum,
				person,
				...toRefs(person),
				showRawPerson,
				addCar,
				changePrice
			}
		}
	}
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h2><a id="customref" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>customRef</h2>
<ul>
<li>
<p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
<pre><code class="language-js">//自定义一个myRef基本套路
function myRef(value){
	return customRef((track,trigger)=&gt;{
		return {
			get(){
				track();  //告诉Vue这个value值是需要被“追踪”的
				return value;
			},
			set(newValue){
				value = newValue;
				trigger(); //告诉Vue去更新界面
			}
		}
	})
}			
</code></pre>
</li>
<li>
<p>实现防抖效果：</p>
<pre><code class="language-js">&lt;template&gt;
	&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;
	&lt;h3&gt;{{keyword}}&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
	import {ref,customRef} from 'vue'
	export default {
		name:'Demo',
		setup(){
			// let keyword = ref('hello') //使用Vue准备好的内置ref
			//自定义一个myRef
			function myRef(value,delay){
				let timer
				//通过customRef去实现自定义
				return customRef((track,trigger)=&gt;{
					return{
						get(){
							track() //告诉Vue这个value值是需要被“追踪”的
							return value
						},
						set(newValue){
							clearTimeout(timer)
							timer = setTimeout(()=&gt;{
								value = newValue
								trigger() //告诉Vue去更新界面
							},delay)
						}
					}
				})
			}
			let keyword = myRef('hello',500) //使用程序员自定义的ref
			return {
				keyword
			}
		}
	}
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h2><a id="provide%E4%B8%8E-inject" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>provide 与 inject</h2>
<img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" />
<ul>
<li>
<p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p>
</li>
<li>
<p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li>
<p>具体写法：</p>
<ol>
<li>
<p>祖组件中：</p>
<pre><code class="language-js">setup(){
	......
    let car = reactive({name:'奔驰',price:'40万'})
    provide('car',car)
    ......
}
</code></pre>
</li>
<li>
<p>后代组件中：</p>
<pre><code class="language-js">setup(props,context){
	......
    const car = inject('car')
    return {car}
	......
}
</code></pre>
</li>
</ol>
</li>
<li>
<p>示例代码（类似于React中的Context传递数据的写法）</p>
<pre><code class="language-js">// App.vue 数据提供者
&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;button @click=&quot;change&quot;&gt;修改&lt;/button&gt;
    &lt;h3&gt;我是App组件（祖），{{ name }}--{{ price }}W&lt;/h3&gt;
    &lt;Child/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import {reactive, toRefs, provide} from 'vue'
import Child from './components/Child.vue'

export default {
  name: 'App',
  components: {Child},
  setup() {
    let car = reactive({name: '奔驰', price: 40})
    provide('car', car) //给自己的后代组件传递数据

    function change() {
      car.name += &quot;*&quot;
      car.price++
    }

    return {...toRefs(car), change}
  }
}
&lt;/script&gt;

&lt;style&gt;
.app {
  background-color: gray;
  padding: 10px;
}
&lt;/style&gt;

//----------------------------------------------------------------------------------------
// Child.vue 中间节点，本例并不需要使用数据，但是可以拿到provide的数据
&lt;template&gt;
  &lt;div class=&quot;child&quot;&gt;
    &lt;h3&gt;我是Child组件（子）&lt;/h3&gt;
    &lt;Son/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import {inject} from 'vue'
import Son from './Son.vue'

export default {
  name: 'Child',
  components: {Son},
  setup() {
    // 所有后代组件中都可以拿到App中provide的数据，并且它还是响应式的
    let car = inject('car')
    console.log(car, 'Child-----')
  }
}
&lt;/script&gt;

&lt;style&gt;
.child {
  background-color: skyblue;
  padding: 10px;
}
&lt;/style&gt;

//----------------------------------------------------------------------------------------
// Son.vue 使用provide的数据
&lt;template&gt;
  &lt;div class=&quot;son&quot;&gt;
    &lt;h3&gt;我是Son组件（孙），{{ car.name }}--{{ car.price }}&lt;/h3&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import {inject} from 'vue'

export default {
  name: 'Son',
  setup() {
    // 所有后代组件中都可以拿到App中provide的数据，并且它还是响应式的
    let car = inject('car')
    return {car}
  }
}
&lt;/script&gt;

&lt;style&gt;
.son {
  background-color: orange;
  padding: 10px;
}
&lt;/style&gt;
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206010614579.gif" alt="2022-06-01 06.10.21" /></p>
</li>
</ul>
<h2><a id="%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A4%E6%96%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>响应式数据的判断</h2>
<ul>
<li>
<p>isRef: 检查一个值是否为一个 ref 对象</p>
</li>
<li>
<p>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</p>
</li>
<li>
<p>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</p>
</li>
<li>
<p>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</p>
</li>
<li>
<p>示例代码</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;h3&gt;我是App组件&lt;/h3&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import {ref, reactive, readonly, isRef, isReactive, isReadonly, isProxy} from 'vue'

export default {
  name: 'App',
  setup() {
    let sum = ref(0);
    let car = reactive({name: '奔驰', price: 40})
    let car2 = readonly(car);

    console.log(&quot;-------------------判断 sum-----------------------&quot;)
    console.log(isRef(sum))
    console.log(isReactive(sum))
    console.log(isReadonly(sum))
    console.log(isProxy(sum))

    console.log(&quot;-------------------判断 car-----------------------&quot;)
    console.log(isRef(car))
    console.log(isReactive(car))
    console.log(isReadonly(car))
    console.log(isProxy(car))

    console.log(&quot;-------------------判断 car2-----------------------&quot;)
    console.log(isRef(car2))
    console.log(isReactive(car2))
    console.log(isReadonly(car2))
    console.log(isProxy(car2))

    return {}
  }
}
&lt;/script&gt;
</code></pre>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206010751704.png" alt="image-20220601075108328" style="zoom:50%;" />
</li>
</ul>
<h1><a id="composition-api%E7%9A%84%E4%BC%98%E5%8A%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Composition API 的优势</h1>
<h2><a id="options-api%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Options API 存在的问题</h2>
<p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p>
<div style="width:600px;height:370px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" />
</div>
<div style="width:300px;height:370px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> 
</div>
<h2><a id="composition-api%E7%9A%84%E4%BC%98%E5%8A%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Composition API 的优势</h2>
<p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p>
<div style="width:500px;height:340px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>
<div style="width:430px;height:340px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205310936693.png" alt="image-20220531093600235" style="zoom:50%;" />
<h1><a id="%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>新的组件</h1>
<h2><a id="fragment" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fragment</h2>
<ul>
<li>
<p>在Vue2中: 组件必须有一个根标签</p>
</li>
<li>
<p>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</p>
</li>
<li>
<p>好处: 减少标签层级, 减小内存占用</p>
</li>
</ul>
<h2><a id="teleport" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Teleport</h2>
<ul>
<li>
<p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p>
<pre><code class="language-js">&lt;!-- 移动的位置：html, body, #hello等等，teleport能够将它包裹的html片段移动到指定的位置 --&gt;
&lt;teleport to=&quot;移动位置&quot;&gt;
	&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;
		&lt;div class=&quot;dialog&quot;&gt;
			&lt;h3&gt;我是一个弹窗&lt;/h3&gt;
			&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/teleport&gt;
</code></pre>
</li>
<li>
<p>自定义弹框示例</p>
<pre><code class="language-js">&lt;template&gt;
	&lt;div&gt;
		&lt;button @click=&quot;isShow = true&quot;&gt;点我弹个窗&lt;/button&gt;
    &lt;!-- 使用 teleport 将弹框内容移动到body中，以免影响其它组件的布局 --&gt;
		&lt;teleport to=&quot;body&quot;&gt;
			&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;
				&lt;div class=&quot;dialog&quot;&gt;
					&lt;h3&gt;我是一个弹窗&lt;/h3&gt;
					&lt;h4&gt;一些内容&lt;/h4&gt;
					&lt;h4&gt;一些内容&lt;/h4&gt;
					&lt;h4&gt;一些内容&lt;/h4&gt;
					&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;
				&lt;/div&gt;
			&lt;/div&gt;
		&lt;/teleport&gt;
	&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
	import {ref} from 'vue'
	export default {
		name:'Dialog',
		setup(){
			let isShow = ref(false)
			return {isShow}
		}
	}
&lt;/script&gt;

&lt;style&gt;
	.mask{
		position: absolute;
		top: 0;bottom: 0;left: 0;right: 0;
		background-color: rgba(0, 0, 0, 0.5);
	}
	.dialog{
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%,-50%);
		text-align: center;
		width: 300px;
		height: 300px;
		background-color: green;
	}
&lt;/style&gt;
</code></pre>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206010829044.png" alt="image-20220601082906439" style="zoom:75%;" />
</li>
</ul>
<h2><a id="suspense" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Suspense</h2>
<ul>
<li>
<p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li>
<p>使用步骤：</p>
<ul>
<li>
<p>异步引入组件</p>
<pre><code class="language-js">import {defineAsyncComponent} from 'vue'
const Child = defineAsyncComponent(()=&gt;import('./components/Child.vue'))
</code></pre>
</li>
<li>
<p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>
<pre><code class="language-js">&lt;template&gt;
	&lt;div class=&quot;app&quot;&gt;
		&lt;h3&gt;我是App组件&lt;/h3&gt;
		&lt;Suspense&gt;
			&lt;template v-slot:default&gt;
				&lt;Child/&gt;
			&lt;/template&gt;
			&lt;template v-slot:fallback&gt;
				&lt;h3&gt;加载中.....&lt;/h3&gt;
			&lt;/template&gt;
		&lt;/Suspense&gt;
	&lt;/div&gt;
&lt;/template&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p>示例代码</p>
</li>
</ul>
<pre><code class="language-js">// App.vue 使用了异步组件，以便模拟延时加载效果
&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;h3&gt;我是App组件&lt;/h3&gt;
    &lt;!-- 使用Suspense需要准备2个内容，分别对应 default、fallback 这2个插槽 --&gt;
    &lt;Suspense&gt;
      &lt;template v-slot:default&gt;
        &lt;Child/&gt;
      &lt;/template&gt;
      &lt;template v-slot:fallback&gt;
        &lt;h3&gt;稍等，加载中...&lt;/h3&gt;
      &lt;/template&gt;
    &lt;/Suspense&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// import Child from './components/Child'//静态引入组件
import {defineAsyncComponent} from 'vue'

const Child = defineAsyncComponent(() =&gt; import('./components/Child')) //异步引入组件
export default {
  name: 'App',
  components: {Child},
}
&lt;/script&gt;

&lt;style&gt;
.app {
  background-color: gray;
  padding: 10px;
}
&lt;/style&gt;

//--------------------------------------------------------------------------------------
&lt;template&gt;
  &lt;div className=&quot;child&quot;&gt;
    &lt;h3&gt;我是Child组件&lt;/h3&gt;
    {{ sum }}
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import {ref} from 'vue'

export default {
  name: 'Child',
  // 正常来讲，setup是不允许异步的，但是如果它的使用者（App.vue）是使用异步引入的方式的话，那么就可以用async修饰
  async setup() {
    let sum = ref(0)
    let p = new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        resolve({sum})
      }, 3000)
    })
    return await p
  }
}
&lt;/script&gt;

&lt;style&gt;
.child {
  background-color: skyblue;
  padding: 10px;
}
&lt;/style&gt;
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206010906029.gif" alt="2022-06-01 08.52.25" /></p>
<h1><a id="%E5%85%B6%E4%BB%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他</h1>
<h2><a id="%E5%85%A8%E5%B1%80api%E7%9A%84%E8%BD%AC%E7%A7%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全局API的转移</h2>
<ul>
<li>
<p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li>
<p>例如：注册全局组件、注册全局指令等。</p>
<pre><code class="language-js">//注册全局组件
Vue.component('MyButton', {
  data: () =&gt; ({
    count: 0
  }),
  template: '&lt;button @click=&quot;count++&quot;&gt;Clicked {{ count }} times.&lt;/button&gt;'
})

//注册全局指令
Vue.directive('focus', {
  inserted: el =&gt; el.focus()
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li>
<p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong style="color:#DD5145">移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h2><a id="%E5%85%B6%E4%BB%96%E6%94%B9%E5%8F%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他改变</h2>
<ul>
<li>
<p>data选项应始终被声明为一个函数。</p>
</li>
<li>
<p>过度类名的更改：</p>
<ul>
<li>
<p>Vue2.x写法</p>
<pre><code class="language-css">.v-enter,
.v-leave-to {
  opacity: 0;
}
.v-leave,
.v-enter-to {
  opacity: 1;
}
</code></pre>
</li>
<li>
<p>Vue3.x写法</p>
<pre><code class="language-css">.v-enter-from,
.v-leave-to {
  opacity: 0;
}

.v-leave-from,
.v-enter-to {
  opacity: 1;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li>
<p>父组件中绑定事件</p>
<pre><code class="language-js">&lt;my-component
  v-on:close=&quot;handleComponentEvent&quot;
  v-on:click=&quot;handleNativeClickEvent&quot;
/&gt;
</code></pre>
</li>
<li>
<p>子组件中声明自定义事件</p>
<p>子组件的 emits 选型中配置了的事件，表示是自定义事件，没有配置的如本例的 v-on:click=&quot;handleNativeClickEvent&quot; 中的click事件，由于没有配置在 emits 中配置，故Vue会认为它是原生的事件。</p>
<pre><code class="language-js">&lt;script&gt;
  export default {
    emits: ['close']
  }
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li>
<p>......</p>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[前端屏幕适配解决方案总结]]></title>
    <link href="http://yuanchao.blogs.io/16538056802330.html"/>
    <updated>2022-05-29T14:28:00+08:00</updated>
    <id>http://yuanchao.blogs.io/16538056802330.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%88%86%E8%BE%A8%E7%8E%87%E6%B1%87%E6%80%BB">常用分辨率汇总</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88">常用屏幕适配方案</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%99%BE%E5%88%86%E6%AF%94%E5%8D%95%E4%BD%8D">使用百分比单位%</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%8F%A3%E5%8D%95%E4%BD%8Dviewport">使用视口单位(Viewport)</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B">使用案例</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8rem%E5%8D%95%E4%BD%8D">使用rem单位</a>
<ul>
<li><a href="#remresponse-js">remResponse.js</a></li>
<li><a href="#px%E4%B8%8Erem%E6%8D%A2%E7%AE%97%E5%85%B3%E7%B3%BB">px与rem换算关系</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8media%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2">使用@media媒体查询</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8postcss-pxtorem">使用 postcss-pxtorem</a>
<ul>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE">配置</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li>
</ul>
</li>
<li><a href="#js%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9">JS动态修改</a></li>
</ul>
</li>
<li><a href="#%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E7%BB%BC%E5%90%88%E6%96%B9%E6%A1%88">屏幕适配综合方案</a></li>
</ul>
<h1><a id="%E5%B8%B8%E7%94%A8%E5%88%86%E8%BE%A8%E7%8E%87%E6%B1%87%E6%80%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用分辨率汇总</h1>
<p>下面列出一些电脑分辨率，其中我们重点关注 <code>1920 * 1080、1366 * 768、1440 * 900</code>。其中前2个是 windows 系统中常用高、低分辨率，1440 是macpro常用分辨率。但是，公司项目中经常有一些其它的分辨率的适配，比如大屏宽屏，以及前段时间有个现场的 1280 * 960，所以个人建议开发时重点自测前3个，项目上如有特殊需求，再挨个满足。</p>
<ul>
<li>
<p>1024*600 （常见8.9寸电脑使用）</p>
</li>
<li>
<p>1024*768 （常用10.4、12.1、14.1、15寸电脑使用）4:3</p>
</li>
<li>
<p>1280*800  （常见10.8、12.1、15.4寸电脑使用）16:10</p>
</li>
<li>
<p>1280*854 （不常见）16:9</p>
</li>
<li>
<p>1280*1024（常用14.1、15寸电脑使用）5:4</p>
</li>
<li>
<p><strong>1366*768（常见15.2寸电脑使用）15:10 （主流）</strong></p>
</li>
<li>
<p><strong>1440*900 （仅苹果17寸电脑使用）16:10</strong></p>
</li>
<li>
<p>1440*1050（常用15、16.1寸电脑使用）4:3</p>
</li>
<li>
<p>1600 * 900  16:9 (非主流)</p>
</li>
<li>
<p>1600*1024（不常见）14:9</p>
</li>
<li>
<p>1600*1200（常用15、16.1寸电脑使用）4:3</p>
</li>
<li>
<p>1680*1050（常见15.4、20寸电脑使用）16:10</p>
</li>
<li>
<p><strong>1920*1080 16:9 （主流）</strong></p>
</li>
<li>
<p>1920*1200（常见20寸电脑使用）16:10</p>
</li>
</ul>
<h1><a id="%E5%B8%B8%E7%94%A8%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用屏幕适配方案</h1>
<h2><a id="%E4%BD%BF%E7%94%A8%E7%99%BE%E5%88%86%E6%AF%94%E5%8D%95%E4%BD%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用百分比单位%</h2>
<p>如：下面是绝对布局水平垂直居中的常用css片段。重点关注 .child css类的写法，parent中是为了截图效果写死了width、height。使用百分比后，无论 .parent 的 width、height 如何变化，.child 元素都是水平垂直居中的。</p>
<pre><code class="language-css">.parent{
  position: relative;
  width: 400px;
  height: 400px;
  background: #0000ff;
}

.child{
  position: absolute;
  width: 50%;
  height: 50%;
  left: 50%;
  top: 50%;
  transform: translate3d(-50%, -50%, 0);
  background: #ff00ff;
}
</code></pre>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205291138029.png" alt="image-20220529113737110" style="zoom:50%;" />
<h2><a id="%E4%BD%BF%E7%94%A8%E8%A7%86%E5%8F%A3%E5%8D%95%E4%BD%8Dviewport" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用视口单位(Viewport)</h2>
<h3><a id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本概念</h3>
<p>在PC端，视口指的是浏览器的可视区域，即window.innerWidth/window.innerHeight大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。</p>
<p>在移动端，它涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。</p>
<p>根据<a href="https://drafts.csswg.org/css-values-3/#viewport-relative-lengths">CSS3规范</a>，视口单位主要包括以下4个：</p>
<p>**vw：**1vw等于视口宽度的1%</p>
<p>**vh：**1vh等于视口高度的1%</p>
<p>**vmin：**选取vw和vh中最小的那个</p>
<p>**vmax：**选取vw和vh中最大的那个</p>
<p>注意：vh / vw 指的是相对于视口的高度和宽度，而不是父元素的（CSS百分比是相对于包含它的最近的父元素的高度和宽度）。1vh 等于1/100的视口高度，1vw 等于1/100的视口宽度。</p>
<p>比如：浏览器高度950px，宽度为1920px, 1 vh = 950px/100 = 9.5 px，1vw = 1920px/100 =19.2 px。</p>
<p>vmax相对于视口的宽度或高度中较大的那个，其中最大的那个被均分为100单位的vmax。</p>
<p>vmin相对于视口的宽度或高度中较小的那个，其中最小的那个被均分为100单位的vmin。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205291150730.png" alt="image-20220529114210518" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205291150337.png" alt="image-20220529114238458" /></p>
<h3><a id="%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用案例</h3>
<p>下面 body 中有2个 div，分别占据视口宽度的一半。无论你怎么缩放浏览器，它都是自适应的。 width: 50vw 表示视口宽度的一半，因为整个视口宽度是 100vw，同样的道理对于 vh。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205291154772.png" alt="image-20220529115411367" /></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- 注意：vue、react 等项目的 public/index.html 中几乎都包含下面这段 --&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;VW&amp;VH&lt;/title&gt;
&lt;/head&gt;
&lt;style&gt;
    * {
        padding: 0;
        margin: 0
    }

    .left {
        float: left;
        width: 50vw;
        height: 20vh;
        background-color: blue;
        text-align: center;
        line-height: 20vh;
        font-size: 3rem
    }

    .right {
        float: right;
        width: 50vw;
        height: 20vh;
        background-color: green;
        text-align: center;
        line-height: 20vh;
        font-size: 3rem
    }
&lt;/style&gt;

&lt;body&gt;
    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>关于 vw 、vh 的浏览器兼容性，请自行查询 <a href="https://caniuse.com/">can i use</a>。</p>
<h2><a id="%E4%BD%BF%E7%94%A8rem%E5%8D%95%E4%BD%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用rem单位</h2>
<p>使用rem单位取代px是公司前端项目中使用比较广泛、也比较稳定的屏幕适配方案。它使用起来也非常简单。封装一个remResponse.js文件，然后直接在程序入口处(如：index.html 或 main.jsp)中以script标签的形式引入即可。实际开发中设计稿的宽度一般都是1920px。</p>
<h3><a id="remresponse-js" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>remResponse.js</h3>
<pre><code class="language-js">// remResponse.js
window.webSetting = {
    // 设计稿屏幕宽度
    designWidth: 1920,
    limitWidth: 1366
};

function initFontSize() {
    var baseWidth = document.documentElement.clientWidth &gt;= window.webSetting.limitWidth ? document.documentElement.clientWidth : window.webSetting.limitWidth;
    var rath = window._screenRath = baseWidth / window.webSetting.designWidth;
    document.documentElement.style.fontSize = (rath * 100) + &quot;px&quot;;
}

initFontSize();
window.addEventListener(&quot;resize&quot;, initFontSize);


//index.html 中引入
 &lt;script type=&quot;text/javascript&quot; src=&quot;./main/remResponse.js&quot;&gt;&lt;/script&gt;

//main.jsp 中引入
&lt;script type=&quot;text/javascript&quot; src=&quot;&lt;c:url value='/view/adlet-manage/main/remResponse.js'/&gt;&quot;&gt;&lt;/script&gt;
</code></pre>
<h3><a id="px%E4%B8%8Erem%E6%8D%A2%E7%AE%97%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>px与rem换算关系</h3>
<ol>
<li><strong>px转rem</strong></li>
</ol>
<p>​		rem尺寸 = 实际尺寸[px]   /  html根元素fontSize[px]</p>
<p>​		rem尺寸 = 实际尺寸[px]   / ( (屏幕实际宽度 /  设计稿宽度)  * 100) [px]</p>
<p>​		rem尺寸 = 实际尺寸[px]   /  (ratio * 100)  [px]</p>
<blockquote>
<p>注意：rem的本义就是一个相对单位，相对于根元素的意思(rootElement)，由于我们实际开发中常常将根元素的fontSize定位整数</p>
<p>100px，故当开发所用显示器的分辨率与设计稿相同时，直接用  actualSize /  100 即可快速得出rem数值。</p>
</blockquote>
<ol start="2">
<li><strong>rem转px</strong></li>
</ol>
<p>​		实际尺寸[px]  =   rem尺寸 * html根元素fontSize[px]</p>
<p>​		实际尺寸[px]  =   rem尺寸 *  ratio * 100  [px]</p>
<p>​		实际尺寸[px]  =   rem尺寸 * (屏幕实际宽度 /  设计稿宽度)  * 100 [px]</p>
<blockquote>
<p>注意：rem转px相对简单一些，由于我们实际开发中，我们的remResponse.js文件中通常都会保存一个 window.<em>screenRatio，故通</em></p>
<p>常我们只需要使用：rem尺寸 * window._screenRatio * 100 即可。</p>
</blockquote>
<h2><a id="%E4%BD%BF%E7%94%A8media%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用@media媒体查询</h2>
<p>简单使用示例（同一个css文件中）：</p>
<pre><code class="language-css">/*&gt;=1366的设备*/
@media (min-width: 1366px) {
   	body{font-size: 24px;}
}  

/*&gt;=1440的设备*/
@media (min-width: 1440px) {
   	body{font-size: 25px !important;}
} 

/*&gt;=1920的设备*/
@media (min-width: 1920px) {
   	body{font-size: 33px;}
} 
</code></pre>
<p>这样在不同分辨率下，body 的font-size 就会自动适配，表现出不同的大小。</p>
<p>如果项目中需要大量使用，也可以拆分出多个css文件，但维护起来要特别小心，每修改一个样式或调整样式结构，都要查看下其它文件中有没有同名样式，需不需要同步调整。如下所示，就拆分出了 高、中、低 3个样式文件。</p>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205291430407.png" alt="image-20220529122831756" style="zoom:30%;" />
<p><span style="color:red">点评：个人不是很推荐将它作为主方案，由于维护上的麻烦，还是将作为辅助方案比较好，否则容易产生bug。</span></p>
<h2><a id="%E4%BD%BF%E7%94%A8postcss-pxtorem" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 postcss-pxtorem</h2>
<p>关于如何使用，参考文档：<a href="https://www.npmjs.com/package/postcss-pxtorem">https://www.npmjs.com/package/postcss-pxtorem</a>   文档写的非常简练，没有多余的废话，我这里就不复制粘贴了，只拣几个重要的说。</p>
<h3><a id="%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装</h3>
<p>postcss 是一个广泛使用的css预处理工具库，postcss-pxtorem 需要配合它使用，所以通常一起安装。</p>
<pre><code class="language-plain_text">npm install postcss postcss-pxtorem --save-dev
</code></pre>
<p>但是我写文档之前安装试了一下，启动Vue会报错，<span style="color:red">PostCSS plugin postcss-pxtorem requires PostCSS 8</span>，检查了 package.json 文件，postcss 的版本已经是 8.x，所以这个报错就有点无厘头了，网上搜索一番，原来是 postcss-pxtorem 的版本高了（现在默认下载下来是 6.x），在 package.json 中降到 5.1.1即可。</p>
<pre><code class="language-json">&quot;devDependencies&quot;: {
   &quot;postcss&quot;: &quot;^8.4.14&quot;,
   &quot;postcss-pxtorem&quot;: &quot;^5.1.1&quot;,
}
</code></pre>
<h3><a id="%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置</h3>
<p>很多像postcss这样的预处理工具，配置文件都支持2种形式：.xxxrc.js 或 xxx.config.js。这里即：.postcssrc.js 或 postcss.config.js，无论使用哪一种，效果都是一样的。不过要注意的是，<strong>配置文件路径和src平级</strong>。当然这不是重点，重点是如何配置，同样参考<a href="https://github.com/cuth/postcss-pxtorem">官方文档</a>。</p>
<pre><code class="language-js">// 最简单的配置
module.exports = {
    plugins: {
        autoprefixer: {}, 
        &quot;postcss-pxtorem&quot;: {
            rootValue: 100,    // 表示根元素font-size设置为100px
            propList: [&quot;*&quot;],   // 表示所有css属性存在px单位的都需要转换
        },
    }
};

//------------------------------------------------------------------------------------------------

// 其它配置举例
module.exports = {
    plugins: {
        autoprefixer: { overrideBrowserslist: &quot;last 5 version&quot; }, 
        &quot;postcss-pxtorem&quot;: {
    				rootValue: 100,        // 表示根元素font-size设置为100px
    				unitPrecision: 5,      // 表示最多有5位小数点
    				propList: ['font', 'font-size', 'line-height', 'letter-spacing'],   //表示哪些css属性需要转换
    				exclude: /node_modules/i   // 排除 node_modules 下的文件，支持函数写法 exclude: function(file){...}
				}
      },
    }
};
</code></pre>
<h3><a id="%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用</h3>
<p>需要指出的是，postcss-pxtorem 只是一个转换工具，即将项目中的 px 单位转换为 rem 单位，它本身并没有屏幕适配功能，它只是一个转换器。具备屏幕适配功能的是 rem 单位本身。例如在我的示例项目中定义了如下样式：</p>
<pre><code class="language-css">&lt;style lang=&quot;css&quot;&gt;
  h1{
    font-size: 20px;
  }
&lt;/style&gt;
</code></pre>
<p>同时我在 main.js 中需改如下（实际开发肯定不是这样干的）：</p>
<pre><code class="language-js">new Vue({
  el:'#app',
  render: h =&gt; h(App),
  store,
  mounted(){
    document.documentElement.style.fontSize = &quot;100px&quot;;   // 设置根元素font-size大小为100px
  }
})
</code></pre>
<p>控制台查看实际效果为：</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205291327067.png" alt="image-20220529132658655" /></p>
<p>综上所述，如果我们开发中定义样式时，如果本来就严格使用 rem 作为尺寸单位，那么 postcss-pxtorem  感觉就没什么用了。</p>
<h2><a id="js%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JS动态修改</h2>
<p>如果前面所有方案都不解决问题，那么还有最后一招——JS动态修改。包括：</p>
<p>1、用js强行将px单位转换为 rem单位，只要了解 px 和 rem 的转换关系，这一点就很简单；</p>
<p>2、用js判断当前分辨率的，通过 if...else...设置不同的尺寸大小。</p>
<p>下面两个实际案例选自渣土系统。</p>
<p>案例1：</p>
<pre><code class="language-js">// 这是 remResponse.js 文件中的代码片段
window.webSetting = {
    // 设计稿屏幕宽度
    designWidth: 1920,
    limitWidth: 1366
};
let baseWidth = document.documentElement.clientWidth &gt;= window.webSetting.limitWidth ? document.documentElement.clientWidth : window.webSetting.limitWidth;
let ratio = window._screenRatio = baseWidth / window.webSetting.designWidth;


// 项目中其它地方，这里用的原生js，当然还可以使用jquery.
var element = document.getElementById(&quot;xxxId&quot;);
// 20：表示在设计稿(1920)分辨率下该元素字体大小为20px;
// 100：表示在设计稿(1920)分辨率下根元素字体大小为100px；
// window._screenRatio：表示当前分辨率下宽度与设计稿宽度的比率，故100*window._screenRatio表示当前分辨率下根元素的字体大小；
element.style.fontSize = 20 * (100 * window._screenRatio);
</code></pre>
<p>案例2：</p>
<pre><code class="language-js">model.addVehicle = function () {
     var data = {};
          
     // 适应不同分辨率。 由于比较简单，故这里没有使用 if...else...，直接用三元表达式。
     // 由于 panal.js 是公司早期的js库，没有使用rem单位，故这里我们认为的判断下分辨率，然后给与不同宽度。
     // 1920 是设计稿宽度，document.documentElement.clientWidth &gt;= 1920 ? 1600 : 1200 的意思就是如果屏幕分辨率
     // 大于等于1920，width的值就给1600px，反之就给 1200px。
     var width = document.documentElement.clientWidth &gt;= 1920 ? 1600 : 1200;
     var height = document.documentElement.clientWidth &gt;= 1920 ? 880 : 600;
     var top = document.documentElement.clientWidth &gt;= 1920 ? 90 : 60;
     var pPanal = panal.getInstance(&quot;view/construction_v3/approve/company/vehicleinfo&quot;, {
         width: width,
         height: height - top,
         op: top,
         title: &quot;车辆信息&quot;,
         minBtn: false,
         titleShow: true,
         resizable: false,
         margin: 0,
         onClose: function (data, uploadersObj) {}
      }, {});
};
</code></pre>
<h1><a id="%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E7%BB%BC%E5%90%88%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>屏幕适配综合方案</h1>
<p>我们搭建一个前端新项目时，务必要考虑好屏幕适配方案，一定要把它作为一个基础工作做在前面，千万不要等到项目进行了一半或者已经上线后，突然发现有屏幕适配缺陷，然后才去考虑怎么适配（公司早期项目就有不少这样的情况，让后来维护的人忍不住想打人，经常修改好这里另外一个地方就蹦出来1个bug，并且bug还算在维护人的头上），这样前期测试的页面又要重新测试修改，并且极易出现bug。</p>
<p>根据我个人的开发经验，推荐屏幕适配方案如下：</p>
<ol>
<li>
<p>开发时严格使用rem作为尺寸单位时：</p>
<p><span style="color: red; font-weight: 600">remReponse（主） + @media（辅助） + JS动态修改（兜底）</span></p>
</li>
<li>
<p>开发时不太注意细节rem、px可能混合存在，或者通篇都是 px 单位时</p>
<p><span style="color: red; font-weight: 600">remReponse（主） + postcss-pxtorem（辅助）+ @media（辅助） + JS动态修改（兜底）</span></p>
</li>
<li>
<p>编写CSS样式时，布局尽量使用自适应布局，尺寸大小尽量使用百分比、vw、vh 这样的相对单位。</p>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[全局事件总线实现Vue任意组件间通信]]></title>
    <link href="http://yuanchao.blogs.io/16537934787603.html"/>
    <updated>2022-05-29T11:04:38+08:00</updated>
    <id>http://yuanchao.blogs.io/16537934787603.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E5%9C%BA%E6%99%AF">场景</a></li>
<li><a href="#vuex%E7%9A%84%E7%BC%BA%E7%82%B9">Vuex的缺点</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6">自定义事件</a></li>
<li><a href="#%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF">全局事件总线</a>
<ul>
<li><a href="#%E6%80%9D%E8%80%83%E5%BC%95%E5%85%A5">思考引入</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">使用方法</a></li>
<li><a href="#%E6%89%A9%E5%B1%951-vuecomponent">扩展1-VueComponent</a></li>
<li><a href="#%E6%89%A9%E5%B1%952-pubsub-js%E5%BA%93">扩展2-pubsub-js库</a></li>
<li><a href="#%E6%89%A9%E5%B1%953%E5%AF%B9%E6%AF%94-knockout">扩展3-对比 Knockout</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<h1><a id="%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>场景</h1>
<p>我们先来看下面这两个常见的开发场景。</p>
<p>场景1：父组件中引用了A、B两个子组件，父组件与子组件相互通信畅通无阻，但是A和B这两个兄弟组件之间却没办法直接通信，一定要借助父组件中转。</p>
<p>场景2：父组件中引入了子组件，子组件中又引入子组件(站在父组件的角度相当于孙子组件)，层层嵌套，但是孙组件往下，与父组件没法直接通信。</p>
<p>但是，实际开发中，兄弟组件、父孙组件之间经常存在交互，需要进行通信。从而衍生出了一些状态管理工具，常见的如：Vuex、Redux、Redux-thunk、Dva等等。这些叫得上名字的无疑都是很优秀的工具，能够解决上述场景遇到的问题，但这不是我们今天讨论的技术要点，我们今天要使用另外一个黑科技——全局事件总线。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205271508724.png" alt="image-20220527150820540" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205271530993.png" alt="image-20220527153001602" /></p>
<h1><a id="vuex%E7%9A%84%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vuex的缺点</h1>
<p>在引入全局事件总线之前，先讨论下Vuex到底有哪些缺点。试想如果Vuex毫无缺点的话，那么我们也就没必要讨论其它技术了，毕竟它是Vue团队官方出品，算是一种通用解决方案。</p>
<p>Vuex（包括Redux）等状态管理库的缺点：</p>
<ol>
<li>学习成本较高，需要学习相关文档才能上手，并且存在很多实用细节，容易踩坑。</li>
<li>增加编码量，无形中要新增很多文件，增加代码量，这对很多一线开发者尤其不能容忍。</li>
<li>存在版本不兼容问题，Vue2.x需要使用Vuex3.x，而Vue3.x则需要使用Vuex4.x，两者不兼容。</li>
</ol>
<p>值得注意的是，这里并不是要否定Vuex解决问题的能力，对于大中型项目，使用Vuex仍然是Vue项目的首选，但是正因为存在这样一些小问题，才鼓励我们去寻找更多的辅助解决方案。在真正进入正题之前，我们还要复习一个前置知识点——自定义事件。</p>
<h1><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义事件</h1>
<p>但凡写过自定义组件的同学，应该都使用或接触过 \(emit 这个api。它的基本套路是：在自定义组件中触发(\)emit)一个事件，然后在组件使用者中捕获这个事件，一般用于子组件向父组件传递数据。下面是最常见的写法：</p>
<pre><code class="language-js">// 子组件
&lt;h1&gt;Hello World&lt;/h1&gt;
&lt;button @click=&quot;onClick&quot;&gt;点我触发事件&lt;/button&gt;
......
methods:{
	onClick(){
		this.$emit(&quot;childEvent&quot;, data);  // 触发一个事件
	}
}

// 父组件 Parent 监听子组件触发的事件
&lt;Child @childEvent=&quot;handleEvent&quot;&gt;&lt;/Child&gt;
......
methods:{
	handleEvent(data){
		// 一些逻辑
	}
}
</code></pre>
<p>但是实际上，父组件里边还有另外一种写法：</p>
<pre><code class="language-js">// 子组件
&lt;h1&gt;Hello World&lt;/h1&gt;
&lt;button @click=&quot;onClick&quot;&gt;点我触发事件&lt;/button&gt;
......
methods:{
	onClick(){
		this.$emit(&quot;childEvent&quot;, data);  // 触发一个事件
	}
}

// 父组件 Parent 使用 ref
&lt;Child ref=&quot;child&quot;&gt;&lt;/Child&gt;
......
mounted(){
  // 父组件渲染完成后绑定子组件事件
  this.$refs.child.$on('childEvent',this.handleEvent);
},
beforeDestroy(){
  // 父组件销毁时解绑子组件事件
  this.$refs.child.$off('childEvent');
},  
methods:{
	handleEvent(data){
		// 一些逻辑
	}
}
</code></pre>
<p>下面这种写法，相信很多同学都没见过，包括我在内也是第一次见到。从语法角度看，显然第一种更加直观，那么为什么要引入第二种写法呢？因为今天的主角全局事件总线（GlobalEventBus）用的就是这种。</p>
<p><strong>这一部分知识点，我们记住2点后面会用到：</strong></p>
<p><strong>1、谁触发的事件就监听谁？（如：Child 组件触发的事件，我们就监听 Child）</strong></p>
<p><strong>2、this.\(refs.child.\)on()、 this.\(refs.child.\)off() 语法</strong></p>
<h1><a id="%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全局事件总线</h1>
<h2><a id="%E6%80%9D%E8%80%83%E5%BC%95%E5%85%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>思考引入</h2>
<p>我们先来思考一下，一个App中可以有无数个组件，换做我们要实现任意组件通信应该怎么做？显然，功夫不能下在组件里边。我们必须要跳出组件自身，选择一个身份超然的东西来做，而且它至少要满足3个要求：1、整个App中只有唯一一个，即单例；2、App内所有组件都可以访问到它；3、它要有 \(emit、\)on、$off 等方法。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205290951619.png" alt="image-20220529095143792" /></p>
<p>假设我们找到了这样一个东西，那么是不是可以在任意组件内部，当组件需要向外传递数据时，就调用这个东西的 \(emit 方法触发事件，在需要接收数据的地方调用它的 \)on 来实现呢（还记得谁触发监听谁吗）？这不就和前面的自定义事件一模一样了嘛。</p>
<p>相信很多同学看到这里，心里已经有答案了，这个东西就是Vue的实例。一个App中有且仅有一个Vue实例对象，并且它身上的确有 \(emit、\)on、$off 等方法。<a href="https://cn.vuejs.org/v2/api/#vm-on">参考官网</a>：</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205290920396.png" alt="image-20220529092045807" /></p>
<h2><a id="%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用方法</h2>
<p>了解了原理，接下来就要进行编码了。我们将这个全局对象的名字命名为 $bus，当然也可以起其它的名字。网络上都用这个，我查了一下 bus 除了公共汽车外，还有一个”总线“的意思，也算是涨姿势了。我们将它挂在 Vue 的原型对象上，并且挂载的时机选择 beforeCreate 生命周期钩子函数中，函数内部的 this 就是Vue 的实例对象。</p>
<p><strong>Vue + js 项目：</strong></p>
<pre><code class="language-js">// main.js 
import Vue from 'vue'
import App from './App.vue'
//关闭Vue的生产提示
Vue.config.productionTip = false

//创建vm
new Vue({
	el:'#app',
	render: h =&gt; h(App),
	beforeCreate() {
		Vue.prototype.$bus = this //安装全局事件总线
	},
})

// -----------------------------------------------------------------------------
// 组件内部使用————学生组件 Student
&lt;template&gt;
	&lt;div class=&quot;student&quot;&gt;
		&lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;
		&lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;
		&lt;button @click=&quot;sendStudentName&quot;&gt;把学生名给School组件&lt;/button&gt;
	&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
	export default {
		name:'Student',
		data() {
			return {
				name:'张三',
				sex:'男',
			}
		},
		methods: {
			sendStudentName(){
				this.$bus.$emit('hello',this.name);  // 触发事件
			}
		},
	}
&lt;/script&gt;

// -----------------------------------------------------------------------------
// 组件内部使用————学校组件 School
&lt;template&gt;
	&lt;div class=&quot;school&quot;&gt;
		&lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;
		&lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
	&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
	export default {
		name:'School',
		data() {
			return {
				name:'尚硅谷',
				address:'北京',
			}
		},
		mounted() {
      // 监听 Student 组件触发的事件
			this.$bus.$on('hello',(data)=&gt;{
				console.log('我是School组件，收到了数据',data)
			})
		},
		beforeDestroy() {
      // 有素养的程序员都做好善后工作
			this.$bus.$off('hello')
		},
	}
&lt;/script&gt;
</code></pre>
<p><strong>Vue + ts 项目：以公司Vue框架为例</strong></p>
<pre><code class="language-js">// 在 workbench.ts 中安装事件总线
protected createWorkspace(context: ApplicationContext): Vue {
        let router = context.router;
        let store = context.store;
        let locale = zhCN;
        // 设置中文
        moment.locale(&quot;zh-cn&quot;);

        return new Vue({
            el: &quot;#app&quot;,
            router: router,
            store: store,
            beforeCreate() {
                Vue.prototype.$bus = this; // 安装全局事件总线
            },
            data: {
                locale
            },
            methods: {
              .........
            },
            template: `
                &lt;a-config-provider
                    :locale=&quot;locale&quot;
                    :transformCellText=&quot;transformCellText&quot;
                &gt;
                    &lt;div id=&quot;app&quot;&gt;
                        &lt;router-view /&gt;
                    &lt;/div&gt;
                &lt;/a-config-provider&gt;
            `
        }).$mount(&quot;#app&quot;);
    }

//----------------------------------------------------------------------------------------
// 在 VideoLayout 组件中触发，ts 中有类型判断，故这里需要 (this as any).$bus.xxx
public initPlayDevices(originDevices: Array&lt;Device&gt;) {
        // 如果实际设备数量大余允许数量则截取为允许数
        if (originDevices.length &gt; this.playType) {
            originDevices = originDevices.slice(0, this.playType);
            // 通过事件总线通知兄弟组件
            (this as any).$bus.$emit(EventName.play_type_changed, originDevices);
        }
       ....................
}

//----------------------------------------------------------------------------------------
// 设备列表组件中监听事件拿到数据.
public mounted() {
   (this as any).$bus.$on(EventName.play_type_changed, (playDevices: Array&lt;Device&gt; = []) =&gt; {
      ...........
   });
}

public beforeDestroy() {
   (this as any).$bus.$off(EventName.play_type_changed);
}
</code></pre>
<p>在公司的项目中，为了避免自定义事件名称重复，我特意创建了一个 event-name.ts 文件，用于存储自定义事件的名称。希望大家今后开发中，由全局事件总线触发的事件，尽量不要直接在组件里边写死事件名称，而是先到这里边定义一下。</p>
<pre><code class="language-js">// // 用于存储所有事件总线触发的事件的名称，切记事件名称要唯一，不可重复.
// 具体格式推荐：&quot;路由path_符合语义的事件名称&quot;，以 videomonitor_play_type_changed 为例：
// videomonitor 为视频监控模块的path，play_type_changed 是自定义的事件名称，表示播放类型改变事件.

enum EventName {
    play_type_changed = &quot;videomonitor_play_type_changed&quot;
}

export default EventName;
</code></pre>
<h2><a id="%E6%89%A9%E5%B1%951-vuecomponent" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展1-VueComponent</h2>
<p>有细心的同学可能会问，beforeCreate 中我们是将 this 赋值给了 Vue.prototype.\(bus ，也就是说Vue的实例对象上可以使用 vm.\)bus， 这点我没有疑问，但是在组件内部的 this.\(bus 中的 this 好像不是Vue的实例，而是 VueComponet 的实例呀，这也可以吗？这里需要解释一下，虽然 \)bus 是定义在 Vue 的原型对象上的，但是 VueComponet 和 Vue 之间存在一个重要的内置关系，即：<code>VueComponent.prototype.__proto__ = Vue.prototype </code>  ，所以虽然 VueComponent 的实例上确实没有  $bus，但是并不影响它使用，因为它的父亲身上有这些方法。</p>
<p>参考下面的关系图：</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205290931085.png" alt="VueComponent" /></p>
<p>如果不了解 prototype、<strong>proto</strong> 概念的同学可以去了解下。JS原型链相关知识是学习前端框架或者自己写一个框架经常要用到的东西，非常重要!!!</p>
<h2><a id="%E6%89%A9%E5%B1%952-pubsub-js%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展2-pubsub-js库</h2>
<p>我们引入全局事件总线功能的目的是为了解决文档开头说的几个场景。但是它并不是唯一的解决方案，网上还有一个订阅与发布解决方案，使用起来也差不多，不过需要使用第三方库 <a href="https://www.npmjs.com/package/pubsub-js">pubsub-js</a>。</p>
<p>使用步骤：</p>
<ol>
<li>
<p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li>
<p>引入: <code>import pubsub from 'pubsub-js'</code></p>
</li>
<li>
<p>接收数据：A组件想接收数据，则在A组件中订阅消息</p>
<pre><code class="language-js">// 组件A
methods(){
  handleEvent(data){......}
}
......
mounted() {
  this.pid = pubsub.subscribe('hello',this.handleEvent) //订阅消息
}
  
// 组件B
pubsub.publish('hello',data)  // 发布消息
</code></pre>
</li>
<li>
<p>提供数据：<code>pubsub.publish('xxx',数据)</code></p>
</li>
<li>
<p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code> 去取消订阅</p>
</li>
</ol>
<h2><a id="%E6%89%A9%E5%B1%953%E5%AF%B9%E6%AF%94-knockout" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展3-对比 Knockout</h2>
<p>对比一下 knockout 和扩展2中的 pubsub-js 库，不难发现这些技术都大同小异，基本思路都是一致的，可见这些框架整来整取也都是你借鉴我我借鉴你，没什么大不了的。</p>
<pre><code class="language-js">// 触发事件
app.trigger(&quot;app:construction:choose:site&quot;, data);

// 监听事件（监听之前先移除一下可能存在的同名事件）
app.off(&quot;app:construction:choose:site&quot;);
app.on(&quot;app:construction:choose:site&quot;, function (data) {
    ........
});
</code></pre>
<h1><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h1>
<p>对于全局事件总线，我们要有一个明确的定位。它可以作为Vue项目中的一种辅助通信手段，但不能代替官方方案以及Vuex。虽然它能够在任意组件间通信，但是不推荐到处使用。简单的父子组件通信就用官方语法即可。而对于非常复杂的通信，比如几十个组件共享状态，还是老老实实使用 Vuex，否则你就需要写几十遍 \(emit、\)on、$off 等代码，这就失去了简化开发的终极目的，同时也可能让代码变得难以维护。当然，对于少量无法直接通信的组件（比如兄弟组件、爷孙组件），显然使用全局事件总线更加方便、代码量更少，这也是撰写此篇文档的初衷。最后，与诸君共勉，共同学习！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vue2.0全家桶学习笔记]]></title>
    <link href="http://yuanchao.blogs.io/16537815300766.html"/>
    <updated>2022-05-29T07:45:30+08:00</updated>
    <id>http://yuanchao.blogs.io/16537815300766.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E8%84%9A%E6%89%8B%E6%9E%B6%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>脚手架文件结构</h2>
<pre><code class="language-plain_text">├── node_modules 
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件
</code></pre>
<h2><a id="%E5%85%B3%E4%BA%8E%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84vue" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于不同版本的Vue</h2>
<ol>
<li>vue.js与vue.runtime.xxx.js的区别：
<ol>
<li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li>
<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li>
</ol>
</li>
<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li>
</ol>
<h2><a id="vue-config-js%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>vue.config.js配置文件</h2>
<ol>
<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>
<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li>
</ol>
<h2><a id="ref%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ref属性</h2>
<ol>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：
<ol>
<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
</li>
</ol>
<h2><a id="props%E9%85%8D%E7%BD%AE%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>props配置项</h2>
<ol>
<li>
<p>功能：让组件接收外部传过来的数据</p>
</li>
<li>
<p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p>
</li>
<li>
<p>接收数据：</p>
<ol>
<li>
<p>第一种方式（只接收）：<code>props:['name'] </code></p>
</li>
<li>
<p>第二种方式（限制类型）：<code>props:{name:String}</code></p>
</li>
<li>
<p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
<pre><code class="language-js">props:{
	name:{
	type:String, //类型
	required:true, //必要性
	default:'老王' //默认值
	}
}
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>
</blockquote>
</li>
</ol>
<h2><a id="mixin%E6%B7%B7%E5%85%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mixin(混入)</h2>
<ol>
<li>
<p>功能：可以把多个组件共用的配置提取成一个混入对象</p>
</li>
<li>
<p>使用方式：</p>
<p>第一步定义混合：</p>
<pre><code class="language-plain_text">{
    data(){....},
    methods:{....}
    ....
}
</code></pre>
<p>第二步使用混入：</p>
<p>​	全局混入：<code>Vue.mixin(xxx)</code><br />
​	局部混入：<code>mixins:['xxx']	</code></p>
</li>
</ol>
<h2><a id="%E6%8F%92%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>插件</h2>
<ol>
<li>
<p>功能：用于增强Vue</p>
</li>
<li>
<p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li>
<p>定义插件：</p>
<pre><code class="language-js">对象.install = function (Vue, options) {
    // 1. 添加全局过滤器
    Vue.filter(....)

    // 2. 添加全局指令
    Vue.directive(....)

    // 3. 配置全局混入(合)
    Vue.mixin(....)

    // 4. 添加实例方法
    Vue.prototype.$myMethod = function () {...}
    Vue.prototype.$myProperty = xxxx
}
</code></pre>
</li>
<li>
<p>使用插件：<code>Vue.use()</code></p>
</li>
</ol>
<h2><a id="scoped%E6%A0%B7%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>scoped样式</h2>
<ol>
<li>作用：让样式在局部生效，防止冲突。</li>
<li>写法：<code>&lt;style scoped&gt;</code></li>
</ol>
<h2><a id="%E6%80%BB%E7%BB%93todolist%E6%A1%88%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结TodoList案例</h2>
<ol>
<li>
<p>组件化编码流程：</p>
<p>​	(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p>
<p>​	(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p>
<p>​			1).一个组件在用：放在组件自身即可。</p>
<p>​			2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p>
<p>​	(3).实现交互：从绑定事件开始。</p>
</li>
<li>
<p>props适用于：</p>
<p>​	(1).父组件 ==&gt; 子组件 通信</p>
<p>​	(2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）</p>
</li>
<li>
<p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p>
</li>
<li>
<p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p>
</li>
</ol>
<h2><a id="webstorage" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>webStorage</h2>
<ol>
<li>
<p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p>
</li>
<li>
<p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>
</li>
<li>
<p>相关API：</p>
<ol>
<li>
<p><code>xxxxxStorage.setItem('key', 'value');</code><br />
该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p>
</li>
<li>
<p><code>xxxxxStorage.getItem('person');</code></p>
<p>​		该方法接受一个键名作为参数，返回键名对应的值。</p>
</li>
<li>
<p><code>xxxxxStorage.removeItem('key');</code></p>
<p>​		该方法接受一个键名作为参数，并把该键名从存储中删除。</p>
</li>
<li>
<p><code> xxxxxStorage.clear()</code></p>
<p>​		该方法会清空存储中的所有数据。</p>
</li>
</ol>
</li>
<li>
<p>备注：</p>
<ol>
<li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li>
<li>LocalStorage存储的内容，需要手动清除才会消失。</li>
<li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li>
<li><code>JSON.parse(null)</code>的结果依然是null。</li>
</ol>
</li>
</ol>
<h2><a id="%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>组件的自定义事件</h2>
<ol>
<li>
<p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></p>
</li>
<li>
<p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p>
</li>
<li>
<p>绑定自定义事件：</p>
<ol>
<li>
<p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p>
</li>
<li>
<p>第二种方式，在父组件中：</p>
<pre><code class="language-js">&lt;Demo ref=&quot;demo&quot;/&gt;
......
mounted(){
   this.$refs.xxx.$on('atguigu',this.test)
}
</code></pre>
</li>
<li>
<p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>
</li>
</ol>
</li>
<li>
<p>触发自定义事件：<code>this.$emit('atguigu',数据)</code></p>
</li>
<li>
<p>解绑自定义事件<code>this.$off('atguigu')</code></p>
</li>
<li>
<p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p>
</li>
<li>
<p>注意：通过<code>this.$refs.xxx.$on('atguigu',回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p>
</li>
</ol>
<h2><a id="%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%EF%BC%88globaleventbus%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全局事件总线（GlobalEventBus）</h2>
<ol>
<li>
<p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li>
<p>安装全局事件总线：</p>
<pre><code class="language-js">new Vue({
	......
	beforeCreate() {
		Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
	},
    ......
}) 
</code></pre>
</li>
<li>
<p>使用事件总线：</p>
<ol>
<li>
<p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<pre><code class="language-js">methods(){
  demo(data){......}
}
......
mounted() {
  this.$bus.$on('xxxx',this.demo)
}
</code></pre>
</li>
<li>
<p>提供数据：<code>this.$bus.$emit('xxxx',数据)</code></p>
</li>
</ol>
</li>
<li>
<p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2><a id="%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83%EF%BC%88pubsub%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息订阅与发布（pubsub）</h2>
<ol>
<li>
<p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li>
<p>使用步骤：</p>
<ol>
<li>
<p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li>
<p>引入: <code>import pubsub from 'pubsub-js'</code></p>
</li>
<li>
<p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p>
<pre><code class="language-js">methods(){
  demo(data){......}
}
......
mounted() {
  this.pid = pubsub.subscribe('xxx',this.demo) //订阅消息
}
</code></pre>
</li>
<li>
<p>提供数据：<code>pubsub.publish('xxx',数据)</code></p>
</li>
<li>
<p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
</li>
</ol>
</li>
</ol>
<h2><a id="nexttick" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>nextTick</h2>
<ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li>
</ol>
<h2><a id="vue%E5%B0%81%E8%A3%85%E7%9A%84%E8%BF%87%E5%BA%A6%E4%B8%8E%E5%8A%A8%E7%94%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue封装的过度与动画</h2>
<ol>
<li>
<p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li>
<p>图示</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205281931811.png" alt="image-20220528193130785" /></p>
</li>
<li>
<p>写法：</p>
<ol>
<li>
<p>准备好样式：</p>
<ul>
<li>元素进入的样式：
<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：
<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li>
<p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p>
<pre><code class="language-vue">&lt;transition name=&quot;hello&quot;&gt;
	&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;
&lt;/transition&gt;
</code></pre>
</li>
<li>
<p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
</ol>
</li>
<li>
<p>示例代码【使用Css3动画、使用过渡transition、使用第三方库 animate.css】</p>
<pre><code class="language-vue">&lt;!-- 使用动画 animation --&gt;
&lt;template&gt;
	&lt;div&gt;
		&lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;
		&lt;transition name=&quot;hello&quot; appear&gt;
			&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;
		&lt;/transition&gt;
	&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
	export default {
		name:'Test',
		data() {
			return {
				isShow:true
			}
		},
	}
&lt;/script&gt;

&lt;style scoped&gt;
	h1{
		background-color: orange;
	}

	.hello-enter-active{
		animation: atguigu 0.5s linear;
	}

	.hello-leave-active{
		animation: atguigu 0.5s linear reverse;
	}

	@keyframes atguigu {
		from{
			transform: translateX(-100%);
		}
		to{
			transform: translateX(0px);
		}
	}
&lt;/style&gt;


&lt;!-- 使用过渡 transition --&gt;
&lt;template&gt;
	&lt;div&gt;
		&lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;
		&lt;transition-group name=&quot;hello&quot; appear&gt;
			&lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;
			&lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;
		&lt;/transition-group&gt;
	&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
	export default {
		name:'Test',
		data() {
			return {
				isShow:true
			}
		},
	}
&lt;/script&gt;

&lt;style scoped&gt;
	h1{
		background-color: orange;
	}
	/* 进入的起点、离开的终点 */
	.hello-enter,.hello-leave-to{
		transform: translateX(-100%);
	}
	.hello-enter-active,.hello-leave-active{
		transition: 0.5s linear;
	}
	/* 进入的终点、离开的起点 */
	.hello-enter-to,.hello-leave{
		transform: translateX(0);
	}

&lt;/style&gt;


&lt;!-- 使用第三方动画库 animate.css --&gt;
&lt;template&gt;
	&lt;div&gt;
		&lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;
		&lt;transition-group
			appear
			name=&quot;animate__animated animate__bounce&quot;
			enter-active-class=&quot;animate__swing&quot;
			leave-active-class=&quot;animate__backOutUp&quot;
		&gt;
			&lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;
			&lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;
		&lt;/transition-group&gt;
	&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  // 官网：https://animate.style/
	import 'animate.css'

	export default {
		name:'Test',
		data() {
			return {
				isShow:true
			}
		},
	}
&lt;/script&gt;

&lt;style scoped&gt;
	h1{
		background-color: orange;
	}


&lt;/style&gt;
</code></pre>
</li>
</ol>
<h2><a id="vue%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>vue脚手架配置代理</h2>
<h3><a id="%E6%96%B9%E6%B3%95%E4%B8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方法一</h3>
<p>​	在vue.config.js中添加如下配置：</p>
<pre><code class="language-js">devServer:{
  proxy:&quot;http://localhost:5000&quot;
}
</code></pre>
<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3><a id="%E6%96%B9%E6%B3%95%E4%BA%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方法二</h3>
<p>​	编写vue.config.js配置具体代理规则：</p>
<pre><code class="language-js">module.exports = {
	devServer: {
      proxy: {
      '/api1': {// 匹配所有以 '/api1'开头的请求路径
        target: 'http://localhost:5000',// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: {'^/api1': ''}
      },
      '/api2': {// 匹配所有以 '/api2'开头的请求路径
        target: 'http://localhost:5001',// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: {'^/api2': ''}
      }
    }
  }
}
/*
   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080
   changeOrigin默认值为true
*/
</code></pre>
<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2><a id="%E6%8F%92%E6%A7%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>插槽</h2>
<ol>
<li>
<p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。</p>
</li>
<li>
<p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li>
<p>使用方式：</p>
<ol>
<li>
<p>默认插槽：</p>
<pre><code class="language-vue">父组件中：
        &lt;Category&gt;
           &lt;div&gt;html结构1&lt;/div&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
               &lt;!-- 定义插槽 --&gt;
               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
</code></pre>
</li>
<li>
<p>具名插槽：</p>
<pre><code class="language-vue">父组件中：
        &lt;Category&gt;
            &lt;template slot=&quot;center&quot;&gt;
              &lt;div&gt;html结构1&lt;/div&gt;
            &lt;/template&gt;

            &lt;template v-slot:footer&gt;
               &lt;div&gt;html结构2&lt;/div&gt;
            &lt;/template&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
               &lt;!-- 定义插槽 --&gt;
               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;
               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
</code></pre>
</li>
<li>
<p>作用域插槽：</p>
<ol>
<li>
<p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p>
</li>
<li>
<p>具体编码：</p>
<pre><code class="language-vue">父组件中：
		&lt;Category&gt;
      &lt;!--1.这里必须使用template，不可省略否则报错--&gt;
      &lt;!--2.这里用scope或slot-scope都可以，slot-scope新一点--&gt;
			&lt;template scope=&quot;scopeData&quot;&gt;
				&lt;!-- 生成的是ul列表 --&gt;
				&lt;ul&gt;
					&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;{{g}}&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/template&gt;
		&lt;/Category&gt;

		&lt;Category&gt;
			&lt;template slot-scope=&quot;scopeData&quot;&gt;
				&lt;!-- 生成的是h4标题 --&gt;
				&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;{{g}}&lt;/h4&gt;
			&lt;/template&gt;
		&lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
		
        &lt;script&gt;
            export default {
                name:'Category',
                props:['title'],
                //数据在子组件自身
                data() {
                    return {
                        games:['红色警戒','穿越火线','劲舞团','超级玛丽']
                    }
                },
            }
        &lt;/script&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2><a id="vuex" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vuex</h2>
<h3><a id="1%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.概念</h3>
<p>​		在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3><a id="2%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.何时使用？</h3>
<p>​		多个组件需要共享数据时</p>
<h3><a id="3%E6%90%AD%E5%BB%BA-vuex%E7%8E%AF%E5%A2%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.搭建vuex环境</h3>
<ol>
<li>
<p>创建文件：<code>src/store/index.js</code></p>
<pre><code class="language-js">//引入Vue核心库
import Vue from 'vue'
//引入Vuex
import Vuex from 'vuex'
//应用Vuex插件
Vue.use(Vuex)

//准备actions对象——响应组件中用户的动作
const actions = {}
//准备mutations对象——修改state中的数据
const mutations = {}
//准备state对象——保存具体的数据
const state = {}

//创建并暴露store
export default new Vuex.Store({
	actions,
	mutations,
	state
})
</code></pre>
</li>
<li>
<p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<pre><code class="language-js">......
//引入store
import store from './store'
......

//创建vm
new Vue({
	el:'#app',
	render: h =&gt; h(App),
	store
})
</code></pre>
</li>
</ol>
<h3><a id="4%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.基本使用</h3>
<ol>
<li>
<p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code>。注意：action函数第1个参数context 是一个minStore（即不完整的store），它包含dispatch、commit等方法。</p>
<pre><code class="language-js">//引入Vue核心库
import Vue from 'vue'
//引入Vuex
import Vuex from 'vuex'
//引用Vuex
Vue.use(Vuex)

const actions = {
    //响应组件中加的动作。context 是一个minStore（即不完整的store），它包含dispatch、commit等方法。
	jia(context,value){
		// console.log('actions中的jia被调用了',miniStore,value)
		context.commit('JIA',value)
	},
}

const mutations = {
    //执行加
	JIA(state,value){
		// console.log('mutations中的JIA被调用了',state,value)
		state.sum += value
	}
}

//初始化数据
const state = {
   sum:0
}

//创建并暴露store
export default new Vuex.Store({
	actions,
	mutations,
	state,
})
</code></pre>
</li>
<li>
<p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li>
<p>组件中修改vuex中的数据：<code>$store.dispatch('action中的方法名',数据)</code> 或 <code>$store.commit('mutations中的方法名',数据)</code></p>
<blockquote>
<p>备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3><a id="5-getters%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.getters的使用</h3>
<ol>
<li>
<p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>
</li>
<li>
<p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<pre><code class="language-js">......

const getters = {
	bigSum(state){
		return state.sum * 10
	}
}

//创建并暴露store
export default new Vuex.Store({
	......
	getters
})
</code></pre>
</li>
<li>
<p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3><a id="6%E5%9B%9B%E4%B8%AA-map%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6.四个map方法的使用</h3>
<ol>
<li>
<p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<pre><code class="language-js">computed: {
    //借助mapState生成计算属性：sum、school、subject（对象写法）
     ...mapState({sum:'sum',school:'school',subject:'subject'}),
         
    //借助mapState生成计算属性：sum、school、subject（数组写法）
    ...mapState(['sum','school','subject']),
},
</code></pre>
</li>
<li>
<p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<pre><code class="language-js">computed: {
    //借助mapGetters生成计算属性：bigSum（对象写法）
    ...mapGetters({bigSum:'bigSum'}),

    //借助mapGetters生成计算属性：bigSum（数组写法）
    ...mapGetters(['bigSum'])
},
</code></pre>
</li>
<li>
<p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<pre><code class="language-js">methods:{
    //靠mapActions生成：incrementOdd、incrementWait（对象形式）
    ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'})

    //靠mapActions生成：incrementOdd、incrementWait（数组形式）
    ...mapActions(['jiaOdd','jiaWait'])
}
</code></pre>
</li>
<li>
<p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<pre><code class="language-js">methods:{
    //靠mapActions生成：increment、decrement（对象形式）
    ...mapMutations({increment:'JIA',decrement:'JIAN'}),
    
    //靠mapMutations生成：JIA、JIAN（对象形式）
    ...mapMutations(['JIA','JIAN']),
}
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3><a id="7%E6%A8%A1%E5%9D%97%E5%8C%96%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7.模块化+命名空间</h3>
<ol>
<li>
<p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li>
<p>修改<code>store.js</code></p>
<pre><code class="language-javascript">const countAbout = {
  namespaced:true,//开启命名空间
  state:{x:1},
  mutations: { ... },
  actions: { ... },
  getters: {
    bigSum(state){
       return state.sum * 10
    }
  }
}

const personAbout = {
  namespaced:true,//开启命名空间
  state:{ ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    countAbout,
    personAbout
  }
})
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中读取state数据：</p>
<pre><code class="language-js">//方式一：自己直接读取
this.$store.state.personAbout.list
//方式二：借助mapState读取：
...mapState('countAbout',['sum','school','subject']),
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中读取getters数据：</p>
<pre><code class="language-js">//方式一：自己直接读取
this.$store.getters['personAbout/firstPersonName']
//方式二：借助mapGetters读取：
...mapGetters('countAbout',['bigSum'])
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中调用dispatch</p>
<pre><code class="language-js">//方式一：自己直接dispatch
this.$store.dispatch('personAbout/addPersonWang',person)
//方式二：借助mapActions：
...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'})
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中调用commit</p>
<pre><code class="language-js">//方式一：自己直接commit
this.$store.commit('personAbout/ADD_PERSON',person)
//方式二：借助mapMutations：
...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'}),
</code></pre>
</li>
</ol>
<h2><a id="%E8%B7%AF%E7%94%B1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>路由</h2>
<ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<h3><a id="1%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.基本使用</h3>
<ol>
<li>
<p>安装vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li>
<p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li>
<p>编写router配置项:</p>
<pre><code class="language-js">//引入VueRouter
import VueRouter from 'vue-router'
//引入Luyou 组件
import About from '../components/About'
import Home from '../components/Home'

//创建router实例对象，去管理一组一组的路由规则
const router = new VueRouter({
	routes:[
		{
			path:'/about',
			component:About
		},
		{
			path:'/home',
			component:Home
		}
	]
})

//暴露router
export default router
</code></pre>
</li>
<li>
<p>实现切换（active-class可配置高亮样式）</p>
<pre><code class="language-vue">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
</code></pre>
</li>
<li>
<p>指定展示位置</p>
<pre><code class="language-vue">&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
</li>
</ol>
<h3><a id="2%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.几个注意点</h3>
<ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3><a id="3%E5%A4%9A%E7%BA%A7%E8%B7%AF%E7%94%B1%EF%BC%88%E5%A4%9A%E7%BA%A7%E8%B7%AF%E7%94%B1%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.多级路由（多级路由）</h3>
<ol>
<li>
<p>配置路由规则，使用children配置项：</p>
<pre><code class="language-js">routes:[
	{
		path:'/about',
		component:About,
	},
	{
		path:'/home',
		component:Home,
		children:[ //通过children配置子级路由
			{
				path:'news', //此处一定不要写：/news
				component:News
			},
			{
				path:'message',//此处一定不要写：/message
				component:Message
			}
		]
	}
]
</code></pre>
</li>
<li>
<p>跳转（要写完整路径）：</p>
<pre><code class="language-vue">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
</code></pre>
</li>
</ol>
<h3><a id="4%E8%B7%AF%E7%94%B1%E7%9A%84-query%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.路由的query参数</h3>
<ol>
<li>
<p>传递参数</p>
<pre><code class="language-vue">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;
				
&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;
&lt;router-link 
	:to=&quot;{
		path:'/home/message/detail',
		query:{
		   id:666,
       title:'你好'
		}
	}&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
<li>
<p>接收参数：</p>
<pre><code class="language-js">$route.query.id
$route.query.title
</code></pre>
</li>
</ol>
<h3><a id="5%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.命名路由</h3>
<ol>
<li>
<p>作用：可以简化路由的跳转。</p>
</li>
<li>
<p>如何使用</p>
<ol>
<li>
<p>给路由命名：</p>
<pre><code class="language-js">{
	path:'/demo',
	component:Demo,
	children:[
		{
			path:'test',
			component:Test,
			children:[
				{
          name:'hello' //给路由命名
					path:'welcome',
					component:Hello,
				}
			]
		}
	]
}
</code></pre>
</li>
<li>
<p>简化跳转：</p>
<pre><code class="language-vue">&lt;!--简化前，需要写完整的路径 --&gt;
&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化后，直接通过名字跳转 --&gt;
&lt;router-link :to=&quot;{name:'hello'}&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化写法配合传递参数 --&gt;
&lt;router-link 
	:to=&quot;{
		name:'hello',
		query:{
		   id:666,
            title:'你好'
		}
	}&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h3><a id="6%E8%B7%AF%E7%94%B1%E7%9A%84-params%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6.路由的params参数</h3>
<ol>
<li>
<p>配置路由，声明接收params参数</p>
<pre><code class="language-js">{
	path:'/home',
	component:Home,
	children:[
		{
			path:'news',
			component:News
		},
		{
			component:Message,
			children:[
				{
					name:'xiangqing',
					path:'detail/:id/:title', //使用占位符声明接收params参数
					component:Detail
				}
			]
		}
	]
}
</code></pre>
</li>
<li>
<p>传递参数</p>
<pre><code class="language-vue">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;
				
&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;
&lt;router-link 
	:to=&quot;{
		name:'xiangqing',
		params:{
		   id:666,
       title:'你好'
		}
	}&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
<blockquote>
<p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p>
</blockquote>
</li>
<li>
<p>接收参数：</p>
<pre><code class="language-js">$route.params.id
$route.params.title
</code></pre>
</li>
</ol>
<h3><a id="7%E8%B7%AF%E7%94%B1%E7%9A%84-props%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7.路由的props配置</h3>
<p>​	作用：让路由组件更方便的收到参数</p>
<pre><code class="language-js">{
	name:'xiangqing',
	path:'detail/:id',
	component:Detail,

	//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件
	// props:{a:900}

	//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件
	// props:true
	
	//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件
	props(route){
		return {
			id:route.query.id,
			title:route.query.title
		}
	}
}
</code></pre>
<h3><a id="8-router-link%E7%9A%84-replace%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>8.<code>&lt;router-link&gt;</code>的replace属性</h3>
<ol>
<li>
<p>作用：控制路由跳转时操作浏览器历史记录的模式</p>
</li>
<li>
<p>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></p>
</li>
<li>
<p>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></p>
<pre><code class="language-html">&lt;div&gt;
	&lt;ul class=&quot;nav nav-tabs&quot;&gt;
		&lt;li&gt;
			&lt;router-link replace class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;router-link replace class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;
			&lt;/li&gt;
	&lt;/ul&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;
</code></pre>
</li>
</ol>
<h3><a id="9%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>9.编程式路由导航</h3>
<ol>
<li>
<p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li>
<p>具体编码：</p>
<pre><code class="language-js">//$router的两个API
this.$router.push({
	name:'xiangqing',
		params:{
			id:xxx,
			title:xxx
		}
})

this.$router.replace({
	name:'xiangqing',
		params:{
			id:xxx,
			title:xxx
		}
})
this.$router.forward() //前进
this.$router.back() //后退
this.$router.go() //可前进也可后退
</code></pre>
</li>
</ol>
<h3><a id="10%E7%BC%93%E5%AD%98%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>10.缓存路由组件</h3>
<ol>
<li>
<p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li>
<p>具体编码：</p>
<pre><code class="language-vue">&lt;!-- 缓存所有路由组件 --&gt;
&lt;keep-alive&gt;
	&lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;

&lt;!-- 缓存一个路由组件 注意：include的值是组件名不是路由名 --&gt;
&lt;keep-alive include=&quot;News&quot;&gt;
	&lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;

&lt;!-- 缓存多个路由组件 --&gt;
&lt;keep-alive :include=&quot;['News','Message']&quot;&gt;
	&lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
</code></pre>
</li>
</ol>
<h3><a id="11%E4%B8%A4%E4%B8%AA%E6%96%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>11.两个新的生命周期钩子</h3>
<ol>
<li>
<p>作用：<strong>路由组件所独有的两个钩子</strong>，用于捕获路由组件的激活状态。</p>
</li>
<li>
<p>具体名字：</p>
<p><code>activated</code>路由组件被激活时触发。</p>
<p><code>deactivated</code>路由组件失活时触发。</p>
</li>
<li>
<p>场景，当某个页面被 vue-router 缓存 <keep-alive> 时，除第一次挂载外，之后再进入组件不会触发mounted 等钩子函数，但是我们的逻辑又必须在进入页面后执行，这时就可以用到。</p>
<pre><code class="language-js">activated() {
	console.log('News组件被激活了')
	this.timer = setInterval(() =&gt; {
		console.log('@')
		this.opacity -= 0.01
		if(this.opacity &lt;= 0) this.opacity = 1
	},16)
},
deactivated() {
	console.log('News组件失活了')
	clearInterval(this.timer)
},
</code></pre>
</li>
</ol>
<h3><a id="12%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>12.路由守卫</h3>
<ol>
<li>
<p>作用：对路由进行权限控制</p>
</li>
<li>
<p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li>
<p>全局守卫: 全局守卫一般写在创建完 router 示例后设置。</p>
<pre><code class="language-js">//全局前置守卫：初始化时执行、每次路由切换前执行
router.beforeEach((to,from,next)=&gt;{
	console.log('beforeEach',to,from)
	if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
		if(localStorage.getItem('school') === 'atguigu'){ //权限控制的具体规则
			next() //放行
		}else{
			alert('暂无权限查看')
			// next({name:'guanyu'})
		}
	}else{
		next() //放行
	}
})

//全局后置守卫：初始化时执行、每次路由切换后执行
router.afterEach((to,from)=&gt;{
	console.log('afterEach',to,from)
	if(to.meta.title){ 
		document.title = to.meta.title //修改网页的title
	}else{
		document.title = 'vue_test'
	}
})
</code></pre>
</li>
<li>
<p>独享守卫: 独享守卫写在单个路由对象里边，作为它的一个扩展方法。</p>
<pre><code class="language-js">{
		name:'xinwen',
		path:'news',
		component:News,
		meta:{isAuth:true,title:'新闻'},
		beforeEnter: (to, from, next) =&gt; {
			 console.log('独享路由守卫',to,from)
			 if(to.meta.isAuth){ //判断是否需要鉴权
				 if(localStorage.getItem('school')==='atguigu'){
					  next()
					}else{
						alert('学校名不对，无权限查看！')
					}
				}else{
						next()
				}
		}
},
</code></pre>
</li>
<li>
<p>组件内守卫：组件内守卫顾名思义应写在组件里边。</p>
<pre><code class="language-js">//进入守卫：通过路由规则，进入该组件时被调用
beforeRouteEnter (to, from, next) {
},
//离开守卫：通过路由规则，离开该组件时被调用
beforeRouteLeave (to, from, next) {
}


&lt;template&gt;
	&lt;h2&gt;我是About的内容&lt;/h2&gt;
&lt;/template&gt;

&lt;script&gt;
	export default {
		name:'About',
		mounted() {
			// console.log('%%%',this.$route)
		},

		//通过路由规则，进入该组件时被调用，即 router 文件中配置了路由的组件。
		beforeRouteEnter (to, from, next) {
			console.log('About--beforeRouteEnter',to,from)
			if(to.meta.isAuth){ //判断是否需要鉴权
				if(localStorage.getItem('school')==='atguigu'){
					next()
				}else{
					alert('学校名不对，无权限查看！')
				}
			}else{
				next()
			}
		},

		//通过路由规则，离开该组件时被调用，即 router 文件中配置了路由的组件。
		beforeRouteLeave (to, from, next) {
			console.log('About--beforeRouteLeave',to,from)
			next()
		}
	}
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h3><a id="13%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>13.路由器的两种工作模式</h3>
<ol>
<li>
<p>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</p>
</li>
<li>
<p>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</p>
</li>
<li>
<p>hash模式：</p>
<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>
<p>history模式：</p>
<ol>
<li>地址干净，美观 。</li>
<li>兼容性和hash模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>
</ol>
<pre><code class="language-js">// 设置 mode 路由模式
const router =  new VueRouter({
   mode:'history',
   routes:[
      {
         name:'guanyu',
         path:'/about',
         component:About,
         meta:{isAuth:true,title:'关于'}
      }]
   }
)
</code></pre>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TS 基础补充及实用技能]]></title>
    <link href="http://yuanchao.blogs.io/16537420437298.html"/>
    <updated>2022-05-28T20:47:23+08:00</updated>
    <id>http://yuanchao.blogs.io/16537420437298.html</id>
    <content type="html"><![CDATA[
<h2><a id="ts%E5%AE%9A%E4%B9%89%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E3%80%81-6%E5%A4%A7%E4%BC%98%E5%8A%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TS  定义、环境搭建、6大优势</h2>
<p><strong>定义：</strong> 融合了面向对象后端的思想的超级版的 javaScript  语言。</p>
<p><strong>环境搭建</strong></p>
<pre><code class="language-powershell">npm init -y 

yarn  add typescript -D

tsc --init
</code></pre>
<p><strong>优势：</strong></p>
<p><strong>优势1：编译时静态类型检测</strong>：函数或方法传参或变量赋值不匹配时，会出现编译错误提示 ，规避了开发期间的大量低级错误，省时，省力。</p>
<p><strong>优势2：能自动提示</strong>：变量类型、变量属性，不用来回切换文件或不小心写错导致的编码隐患。</p>
<p><strong>优势3：</strong> <strong>引入了泛型</strong>：让大中项目，前端框架底层源码具备了高可扩展性这个巨大的优势，同时也有类型安全检查的优势。</p>
<p><strong>优势4</strong>： <strong>强大的 d.ts 声明文件</strong>：声明文件像一个书的目录一样，清晰直观展示了依赖库文件的接口，type类型，类，函数，变量等声明。</p>
<p><strong>优势5：轻松编译成 JS 文件</strong>：即使 TS 文件有错误，绝大多数情况也能编译出 JS 文件。</p>
<p><strong>优势6：灵活性高：</strong> 尽管 TS 是一门 强类型检查语言，但也提供了 any 类型 和 as any 断言，这提供了 TS的灵活度。</p>
<h2><a id="tsconfig-json%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>tsconfig.json 常用配置详解</h2>
<pre><code class="language-js">{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es2020&quot;, // 指定 TS 编译成 JS 后的js版本
    &quot;module&quot;: &quot;commonjs&quot;, // TS 编译成 JS 后采用的模块规范 commonjs amd cmd  es等         
    &quot;lib&quot;: [&quot;DOM&quot;,&quot;ES2020&quot;], /*  指定 TS 编码期间可以使用的库文件版本 比如：ES5就不支持Set集合 */
    &quot;outDir&quot;: &quot;./dist&quot;, //     指定 TS 文件编译成 JS 后的输出目录                 /* Redirect output structure to the directory. */
    &quot;rootDir&quot;: &quot;./src&quot;, // 指定 TS 文件源码目录
    &quot;strict&quot;: true, // 启用严格检查模式
    &quot;strictNullChecks&quot;:false,// null 和 undefined即是值，也是类型, null 和 undefined 值 只能赋值给 any ,unknown和它们各自的类型
    &quot;noImplicitAny&quot;: true, // 一般是指表达式或函数参数上有隐含的 any类型时报错
    &quot;experimentalDecorators&quot;: true, /* 启用ES7装饰器实验开启选项 */
    &quot;emitDecoratorMetadata&quot;: true, /* 启用装饰器元数据开启选项 */
    &quot;declaration&quot;: true, // 指定 TS 文件编译后生成相应的.d.ts文件
    &quot;removeComments&quot;: false, // TS 文件编译后删除所有的注释
    
    &quot;baseUrl&quot;: &quot;src&quot;, /* 工作根目录  解析非相对模块的基地址*/
    &quot;paths&quot;: {
        &quot;@/datatype/*&quot;: [&quot;datatype/*&quot;],
        &quot;@/131/*&quot;: [&quot;131/*&quot;],
        &quot;@/132/*&quot;: [&quot;132/*&quot;]
      },    
    // 有些依赖库底层 为了兼容CommonJs规范、AMD规范这二者的规范中相互兼容，
    // 使用了 export =，将二者规范统一。
    // &quot;esModuleInterop&quot;:true表示允许依赖库中出现export = 这种兼容规范导出的格式，
    //  TS 可以用import from导入 
    &quot;esModuleInterop&quot;: true,  
  },
  &quot;include&quot;: [ // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题
    &quot;./src/**/*.ts&quot; // 匹配src下所有的ts文件
, &quot;src/datatype/typepsenumts&quot;  ],
   &quot;exclude&quot;: [
    &quot;./src/**/test&quot;,
    &quot;./src/**/premit&quot;, 
  ]
}
</code></pre>
<h2><a id="%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型注解和类型推断</h2>
<pre><code class="language-typescript">// 类型注解——ts 在编写代码期间就能确定变量的类型。
let price:number = 3

type UserType = {name: string, age: number};
let user: UserType = {name: &quot;zhangsan&quot;, 30};

// 类型推断
let price = 3;
let user =  {name: &quot;zhangsan&quot;, 30};
</code></pre>
<h2><a id="any%E5%92%8C-unknown%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>any 和 unknown 的两个区别</h2>
<pre><code class="language-typescript">// 任何类型都可以赋值给any
let value: any;
value = &quot;zhangsan&quot;;
value = 123;
value = true;

// any 也可以给任何类型
let name: string = value;
let age: number = value;
let married: boolean = value;
</code></pre>
<pre><code class="language-typescript">// 任何类型都可以赋值给unknown
let value: unknown;
value = &quot;zhangsan&quot;;
value = 123;
value = true;

// unknown 不可以赋值给除自身外的任何类型
let name: string = value;      //报错
let age: number = value;       //报错
let married: boolean = value;  //报错
let hello: unknown = value;    //正常
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205110920764.png" alt="image-20220511092008962" /></p>
<h2><a id="%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数和函数类型</h2>
<ol>
<li>
<p>函数返回值可以自动推导</p>
<pre><code class="language-typescript">// 函数test没有显示指定返回值类型，但可以自动推导
function test(name: string, age: number) {
    console.log(`name: ``{name}, age: ``{age}`);
    return 20
}

let res = test(&quot;zhangsan&quot;, 30);
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205110925081.png" alt="image-20220511092540821" /></p>
</li>
<li>
<p>函数类型也可以自动推导</p>
<pre><code class="language-typescript">let func = function (name: string, age: number): number {
    console.log(`name: ``{name}, age: ``{age}`);
    return 20;
}

// func 会自动推导为函数类型
func(&quot;zhangsan&quot;, 30);


// 也可以显示指定类型，这样参数和返回值就不能胡乱写了。
// 函数类型定义方式
let func1: (name: string, age: number) =&gt; number = function (name: string, age: number): number {
    console.log(`name: ``{name}, age: ``{age}`);
    return 20
}

func1(&quot;zhangsan&quot;, 30);

// 接口定义方式
let func2: { (name: string, age: number): number } = function (name: string, age: number): number {
    console.log(`name: ``{name}, age: ``{age}`);
    return 20
}

func2(&quot;zhangsan&quot;, 30);
</code></pre>
</li>
</ol>
<h2><a id="string%E5%92%8C-string%E7%9A%84%E6%AF%94%E8%BE%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>string 和 String 的比较</h2>
<h2><a id="bigint%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>BigInt 使用场景</h2>
<p><strong>1. number 的极限值运算</strong></p>
<pre><code class="language-js">// 获取最大的整数值，此处 max 的类型被推断为 number 类型。
const max = Number.MAX_SAFE_INTEGER;
console.log(max)
const maxBigOne = max + 1
console.log(maxBigOne)
const maxBigtwo = max + 2
console.log(maxBigtwo)

// 输出true，表示结果相同
console.log(maxBigOne === maxBigtwo);
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205110939821.png" alt="image-20220511093911515" /></p>
<p><strong>2.  使用 BigInt</strong></p>
<pre><code class="language-typescript">// 方法1：
// 第一步：
// 修改 tsconfig.json 选项——&quot;lib&quot;: [&quot;DOM&quot;,&quot;ES2020&quot;] + &quot;target&quot;: &quot;es5&quot;

//第二步：此处max被推断为 bigint 类型。
const max = BigInt(Number.MAX_SAFE_INTEGER);
console.log(max)
const maxBigOne = max + BigInt(1)
console.log(maxBigOne)
const maxBigtwo = max + BigInt(2)
console.log(maxBigtwo)
// 输出false
console.log(maxBigOne === maxBigtwo)

// 方法2：
// 第一步：
// 修改 tsconfig.json 选项——&quot;lib&quot;: [&quot;DOM&quot;,&quot;ES2020&quot;] + &quot;target&quot;: &quot;es2020&quot;

//第二步：此处max被推断为 bigint 类型。
const max = BigInt(Number.MAX_SAFE_INTEGER);
console.log(max)
const maxBigOne = max + 1n
console.log(maxBigOne)
const maxBigtwo = max + 2n
console.log(maxBigtwo)
// 输出false
console.log(maxBigOne === maxBigtwo)
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205110939531.png" alt="image-20220511093955301" /></p>
<h2><a id="%E7%9C%8B%E4%BC%BC%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%96%E5%80%BC%E4%B8%BA%E4%BD%95%E6%80%BB%E6%8A%9B%E9%94%99%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>看似简单的取值为何总抛错？</h2>
<p>经典案例1：<a href="https://note.youdao.com/s/2HqTAjMK">https://note.youdao.com/s/2HqTAjMK</a></p>
<pre><code class="language-typescript">let user = {name: &quot;zhangsan&quot;, age: 28}
let key = &quot;name&quot;;
// 报错
user[key] = &quot;lisi&quot;;

// let key = &quot;name&quot;; TS可以推断 key 为字符串类型，但是编译期间并不能推断出其值为&quot;name&quot;，因为我们这里使用的是 let ，let变量在代码中是可以修改的，所以只有到了运行期间，TS才知道 key 的值究竟是不是&quot;name&quot;。由于编译期间只能推断 key 变量的类型是string，而string的可能性太多了，故认为 user[key] 是字符串索引签名形式，除非 user 上真的有字符串索引签名，不然编译就会报错。
</code></pre>
<p>经典案例2：</p>
<pre><code class="language-typescript">let user: object = {name: &quot;zhangsan&quot;, age: 28}
// 报错
user.name = &quot;lisi&quot;

// user 显示声明为object，而 object 类型上本身是没有 name 属性的，故报错。解决办法2个：

// 方法一：不显示声明为 object 类型, ts 自动帮我们推导为对象字面量类型。
let user = {name: &quot;zhangsan&quot;, age: 28}
user.name = &quot;lisi&quot;

// 方法二：使用 Record&lt;string, any&gt;
let user: Record&lt;string, any&gt; = {name: &quot;zhangsan&quot;, age: 28};
user.name = &quot;lisi&quot;
</code></pre>
<h2><a id="%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AFnever%E8%83%BD%E8%A2%AB%E7%9B%B4%E6%8E%A5%E6%8E%A8%E5%AF%BC%E5%87%BA%E6%9D%A5%E8%80%8C%E4%B8%8D%E7%94%A8%E5%AE%9A%E4%B9%89%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么场景 never 能被直接推导出来而不用定义？</h2>
<pre><code class="language-js">
// dataFlowAnalysisWithNever 方法穷尽了 DataFlow 的所有可能类型。 
// 通过这个示例，我们可以得出一个结论：使用 never 避免出现未来扩展新的类没有对应类型的实现，目的就是写出类型绝对安全的代码。
type DataFlow = string | number
function dataFlowAnalysisWithNever(dataFlow: DataFlow) {
    if (typeof dataFlow === &quot;string&quot;) {
        console.log(&quot;字符串类型：&quot;, dataFlow.length);
    } else if (typeof dataFlow === &quot;number&quot;) {
        console.log(&quot;数值类型：&quot;, dataFlow.toFixed(2));
    } else {
      	// dataFlow 在这里是 never 
        let nothings = dataFlow;
    }
}

dataFlowAnalysisWithNever(&quot;免税店&quot;)


export { }
</code></pre>
<h2><a id="%E6%B7%B1%E5%85%A5%E6%8E%8C%E6%8F%A1%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>深入掌握枚举</h2>
<ol>
<li>枚举的定义    2. 枚举分类    3. 枚举取值方式  4. 枚举底层   5. 枚举应用</li>
</ol>
<h3><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么要用枚举?</h3>
<p>解决多次 if /switch 判断中值的语义化的问题</p>
<ol>
<li>常量解决       2. 常量解决带来的局限性</li>
</ol>
<p><strong>1. 常量解决</strong></p>
<pre><code class="language-js">const Status = {
  MANAGER_ADUIT_FAIL: -1,
  NO_ADUIT: 0,
  MANAGER_ADUIT_SUCCESS: 1,
  FINAL_ADUIT_SUCCESS: 2
}
// 审核类
class MyAduit {

  getAduitStatus(status: number): void {
    if (status === Status.NO_ADUIT) {
      console.log(&quot;没有审核&quot;);
    } else if (status === Status.MANAGER_ADUIT_SUCCESS) {
      console.log(&quot;经理审核通过&quot;);
    } else if (status === Status.FINAL_ADUIT_SUCCESS) {
      console.log(&quot;财务审核通过&quot;);
    }
  }
}

const aduit = new MyAduit();
aduit.getAduitStatus(Status.MANAGER_ADUIT_FAIL);
export { }
</code></pre>
<p><strong>2. 常量解决带来的局限性</strong></p>
<p>方法参数不能定义为具体类型，只能初级使用 number，string 基本类型替代，降低了代码的可读性和可维护性。</p>
<h3><a id="%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>枚举的定义</h3>
<p>定义:用来存放一组固定的常量的序列</p>
<h3><a id="%E6%9E%9A%E4%B8%BE%E5%88%86%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>枚举分类</h3>
<pre><code class="language-js">// 字符串枚举
enum EnumAuditStatus {
    MANAGER_ADUIT_FAIL = &quot;项目经理审核失败&quot;,
    NO_ADUIT = &quot;没有审核&quot;,
    MANAGER_ADUIT_SUCCESS = &quot;项目经理审核成功&quot;,
    FINAL_ADUIT_SUCCESS = &quot;财务审核成功&quot;,
}

//  字符串枚举
enum WeekEnd {
  Monday = &quot;Monday&quot;,
  Tuesday = &quot;Tuesday&quot;,
  Wensday = &quot;Wensday&quot;,
  ThirsDay = &quot;ThirsDay&quot;,
  Friday = &quot;Friday&quot;,
  Sarturday = &quot;Sarturday&quot;,
  Sunday = &quot;Sunday&quot;
}

</code></pre>
<pre><code class="language-js">// 数字枚举
enum EnumAuditStatus {
  MANAGER_ADUIT_FAIL = -1,//第一个常量值设置为-1
  NO_ADUIT, // 第二个常量值自动递增1 就为0
  MANAGER_ADUIT_SUCCESS,// // // 第二个常量值自动递增2 就为1
  FINAL_ADUIT_SUCCESS // // // 第二个常量值自动递增3 就为2
}

// 数字枚举
enum Week {
  Monday = 1,
  Tuesday,
  Wensday,
  ThirsDay,
  Friday,
  Sarturday,
  Sunday
}
</code></pre>
<h3><a id="%E6%9E%9A%E4%B8%BE%E5%8F%96%E5%80%BC%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>枚举取值方式</h3>
<pre><code class="language-js">export enum EnumAuditStatus {
  MANAGER_ADUIT_FAIL = -1,//第一个常量值设置为-1
  NO_ADUIT, // 第二个常量值自动递增1 就为0
  MANAGER_ADUIT_SUCCESS,// // // 第二个常量值自动递增2 就为1
  FINAL_ADUIT_SUCCESS // // // 第二个常量值自动递增3 就为2
}

// 取值方式1：枚举取值 根据枚举中常量名来取出常量值
console.log(&quot;EnumAuditStatus.FINAL_ADUIT_SUCCESS&quot;, EnumAuditStatus.FINAL_ADUIT_SUCCESS);  // 输出2

// 取值方式2：枚举反向取值 根据枚举中常量值来取出常量名
console.log(&quot;EnumAuditStatus[0]&quot;, EnumAuditStatus[0]);  // 输出 NO_ADUIT
console.log(&quot;EnumAuditStatus[1]&quot;, EnumAuditStatus[1]);  // 输出 MANAGER_ADUIT_SUCCESS
</code></pre>
<h3><a id="%E6%9E%9A%E4%B8%BE%E5%BA%95%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>枚举底层</h3>
<h4><a id="%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE%E5%BA%95%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数字类型枚举底层</h4>
<pre><code class="language-js">// 数字类型的枚举，是一个双向映射的对象。
var Week;
(function (Week) {
    Week[Week[&quot;Monday&quot;] = 1] = &quot;Monday&quot;;
    Week[Week[&quot;Tuesday&quot;] = 2] = &quot;Tuesday&quot;;
    Week[Week[&quot;Wensday&quot;] = 3] = &quot;Wensday&quot;;
    Week[Week[&quot;ThirsDay&quot;] = 4] = &quot;ThirsDay&quot;;
    Week[Week[&quot;Friday&quot;] = 5] = &quot;Friday&quot;;
    Week[Week[&quot;Sarturday&quot;] = 6] = &quot;Sarturday&quot;;
    Week[Week[&quot;Sunday&quot;] = 7] = &quot;Sunday&quot;;
})(Week || (Week = {}));
</code></pre>
<h4><a id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%9A%E4%B8%BE%E5%BA%95%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符串枚举底层</h4>
<pre><code class="language-js">// 字符串类型的枚举，是一个普通的key-value映射的对象。
var WeekEnd;
(function (WeekEnd) {
    WeekEnd[&quot;Monday&quot;] = &quot;Monday&quot;;
    WeekEnd[&quot;Tuesday&quot;] = &quot;Tuesday&quot;;
    WeekEnd[&quot;Wensday&quot;] = &quot;Wensday&quot;;
    WeekEnd[&quot;ThirsDay&quot;] = &quot;ThirsDay&quot;;
    WeekEnd[&quot;Friday&quot;] = &quot;Friday&quot;;
    WeekEnd[&quot;Sarturday&quot;] = &quot;Sarturday&quot;;
    WeekEnd[&quot;Sunday&quot;] = &quot;Sunday&quot;;
})(WeekEnd || (WeekEnd = {}));
</code></pre>
<h3><a id="%E6%9E%9A%E4%B8%BE%E5%A5%BD%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>枚举好处</h3>
<p>枚举带来的好处:</p>
<ol>
<li>
<p>有默认值和可以自增值，节省编码时间</p>
</li>
<li>
<p>语义更清晰，可读性增强,</p>
</li>
</ol>
<p>因为枚举是一种值类型的数据类型，方法参数可以明确参数类型为枚举类型</p>
<h3><a id="%E6%9E%9A%E4%B8%BE%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>枚举应用</h3>
<pre><code class="language-js">export enum EnumAuditStatus {
  MANAGER_ADUIT_FAIL = -1,//第一个常量值设置为-1
  NO_ADUIT, // 第二个常量值自动递增1 就为0
  MANAGER_ADUIT_SUCCESS,// // // 第二个常量值自动递增2 就为1
  FINAL_ADUIT_SUCCESS // // // 第二个常量值自动递增3 就为2
}


interface Expense {
  id: number,
  events: string,
  time: Date,
  enumAuditStatus: EnumAuditStatus
}

class ExpenseService {
  addExpense(expense: Expense) { }
}
let expenseService = new ExpenseService();

// 审核类
class MyAduit {
  getAduitStatus(status: EnumAuditStatus): void {
    let mystatus: EnumAuditStatus = 10;//定义枚举类型的变量
    let mystatus2: EnumAuditStatus = mystatus;
    mystatus2 = mystatus2 + 1;
    console.log(&quot;mystatus:&quot;, mystatus);//10
    console.log(&quot;mystatus2&quot;, mystatus2);//11

    if (status === EnumAuditStatus.NO_ADUIT) {//NO_ADUIT=0
      console.log(&quot;没有审核&quot;);
    } else if (status === EnumAuditStatus.MANAGER_ADUIT_SUCCESS) {
      console.log(&quot;经理审核通过&quot;);
      let expense: Expense = {
        id: 1,
        events: &quot;飞机票报销&quot;,
        time: new Date(),
        enumAuditStatus: status
      }
      expenseService.addExpense(expense)
    } else if (status === EnumAuditStatus.FINAL_ADUIT_SUCCESS) {
      console.log(&quot;财务审核通过&quot;);
    } else {
      console.log(&quot;审核失败&quot;);
    }
  }
}

const aduit = new MyAduit();
aduit.getAduitStatus(EnumAuditStatus.FINAL_ADUIT_SUCCESS);
export { }
</code></pre>
<h2><a id="%E6%8E%A5%E5%8F%A3interface" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口(interface)</h2>
<h3><a id="%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E5%AE%9E%E7%8E%B0%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口的定义、实现、应用场景</h3>
<p><strong>定义</strong></p>
<p>是为一系列同类对象或同类别的类提供属性定义和方法声明但没有任何赋值和实现的数据类型。</p>
<p><strong>接口实现</strong></p>
<pre><code class="language-typescript">interface Product {
    id: number;
    name: string;
    price: number;
    count: number;
}

function calTotal(product: Product) {
    console.log(&quot;product总价：&quot;, product.price * product.count);
}

calTotal({id: 100, name: &quot;电脑&quot;, price: 5000, count: 10})
</code></pre>
<p><strong>应用场景</strong></p>
<p>1  提供方法的对象类型的参数时使用</p>
<p>2 为多个同类别的类提供统一的方法和属性声明</p>
<h3><a id="%E6%8E%A5%E5%8F%A3%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口可选属性</h3>
<p>实战开发中可有可无的属性可以定义为可选属性。</p>
<pre><code class="language-typescript">interface Product {
    id: number;
    name: string;
    price: number;
    count: number;
    remark?: string;
}
</code></pre>
<h3><a id="%E5%8F%AF%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可索引类型</h3>
<p>属性未来可能会扩展，个数也不确定，类型也不确定，但是目前还不确定。</p>
<pre><code class="language-typescript">interface Product {
    id: number;
    name: string;
    price: number;
    count: number;
    remark?: string;
		// 字符串索引签名
    [prop: string]: any;
}

function calTotal(product: Product) {
    console.log(&quot;product总价：&quot;, product.price * product.count);
}

// 使用了多个 Product 接口中没有定义的属性，但是编译不会报错。
calTotal({id: 100, name: &quot;电脑&quot;, price: 5000, count: 10, remark: &quot;hello&quot;, place: &quot;武汉&quot;, quatity: &quot;二手&quot;})
</code></pre>
<pre><code class="language-typescript">interface Getter{
    [key: string]: (state: any) =&gt; void;
}

let getter:Getter = {
    eat() =&gt; {},
    
    drink(state: string) =&gt; {}
}
</code></pre>
<h3><a id="%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数类型</h3>
<pre><code class="language-typescript">interface Product {
    id: number;
    name: string;
    price: number;
    count: number;
    remark?: string;
    [prop: string]: any;  //字符串索引签名
    process(): void;      // 方法，函数类型
    transport?():void;    // 可选方法，函数类型
}
</code></pre>
<h3><a id="%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口继承实现</h3>
<p><strong>接口继承的使用场景：</strong></p>
<p>新的接口只是在原来接口继承之上增加了一些属性或方法，这时就用接口继承</p>
<pre><code class="language-js">// 例子1：
// 开始定义了一个接口
interface  Point{
    x:number;
    y:number;
}

// 需求发生了变化，但是是在原来 Point 接口的基础之上增加了一个新的 z:number 属性。
interface Point3d extends Point{
    z:number;
}


// 例子2：Vue3源码中 稍复杂一点的接口继承
interface Error {
  name: string;
  message: string
}

interface CompilerError extends Error {
  code: number
}

const enum ErrorCodes {
  // parse errors
  ABRUPT_CLOSING_OF_EMPTY_COMMENT,
  CDATA_IN_HTML_CONTENT,
  DUPLICATE_ATTRIBUTE,
  END_TAG_WITH_ATTRIBUTES,
  END_TAG_WITH_TRAILING_SOLIDUS,
  EOF_BEFORE_TAG_NAME,
  EOF_IN_CDATA,
  EOF_IN_COMMENT,
  EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT,
  EOF_IN_TAG,
  INCORRECTLY_CLOSED_COMMENT
   ......
}
 
 interface CoreCompilerError extends CompilerError {
  code: ErrorCodes
}

//  其他应用比较少的场景:
//  1 接口也可以继承多个接口  2 接口可以继承类  3 类可以继承一个或多个接口
//  同学们可以
</code></pre>
<h2><a id="type%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>type 定义类型和接口定义的区别</h2>
<p><strong>type 和接口类似，都用来定义类型，但 type 和 interface 区别如下：</strong></p>
<p><strong>1、定义类型范围不同</strong></p>
<p>interface 只能定义对象类型或接口当名字的函数类型。</p>
<p>type 可以定义任何类型，包括基础类型、联合类型 ，交叉类型，元组。</p>
<pre><code class="language-typescript">// 接口定义对象类型
interface Product {
    id: number;
    name: string;
    price: number;
    count: number;
    remark?: string;

    getCost(): number;
    transport(): void;
}

let product: Product = {
    id: 10,
    name: &quot;电脑&quot;,
    price: 5000,
    count: 10,
    getCost(): number {
        return this.price * this.count;
    },
    transport() {
        console.log(&quot;使用顺丰物流运输&quot;);
    }
}

console.log(product.getCost());
product.transport();


// 接口当名字的函数类型
interface Print {
    (content: string): void
}

let print: Print = (content: string): void =&gt; {
    console.log(`输出内容：`, content)
}

print(&quot;abc&quot;);

export {}
</code></pre>
<pre><code class="language-typescript">// type 定义基础类型
type num = number

//  type 定义联合类型例子1：
type baseType = string | number | symbol

//  type 定义联合类型例子2：
interface Car {
    brandNo: string
}

interface Plane {
    No: string;
    brandNo: string
}

type TypVechile = Car | Plane

//  元组
interface Car {
    brandNo: string
}

interface Plane {
    No: string;
    brandNo: string
}

type TypVechile = [Car, Plane]


export {};
</code></pre>
<p><strong>2、接口可以extends 一个或者多个 接口或类， 也可以继承type，但type 类型没有继承功能</strong></p>
<p>但一般 接口继承类和 type 的应用场景很少见，我们只需要知道有这样的语法即可。</p>
<p><strong>3、用 type 交叉类型 &amp; 可让类型中的成员合并成一个新的 type 类型，但接口不能交叉合并</strong></p>
<pre><code class="language-js">type Group = { groupName: string, memberNum: number }
type GroupInfoLog = { info: string, happen: string }
type GroupMemeber = Group &amp; GroupInfoLog// type 交叉类型合并

let data: GroupMemeber = {
  groupName: &quot;001&quot;, memberNum: 10,
  info: &quot;集体爬山&quot;, happen: &quot;中途有组员差点滑落,有惊无险&quot;,
}

export { }
</code></pre>
<p><strong>4、接口可以合并声明</strong></p>
<p>定义两个相同名称的接口会合并声明，定义两个同名的type会出现编译错误。</p>
<pre><code class="language-js">interface Error {
    name: string;
}

interface Error {
    message: string;
    stack?: string;
}

// 接口合并
let error: Error = {
    message: &quot;空指针&quot;,
    name: &quot;NullPointException&quot;
}
</code></pre>
<h2><a id="%E5%A2%9E%E5%BC%BA%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>增强布尔类型——联合类型的使用</h2>
<p>假如我们想把0， 1 当布尔类型使用，JS中是默认可以的，但是TS需要处理一下类型问题才行。</p>
<pre><code class="language-typescript">type IncreaseBoolean = Boolean | 1 | 0;

function mounted(isStartUp: IncreaseBoolean) {
    if (isStartUp) {
        console.log(&quot;yes&quot;);
    } else {
        console.log(&quot;no&quot;);
    }
}

mounted(true);     // yes
mounted(1);        // yes
mounted(false);    // no
mounted(0);        // no

export {}
</code></pre>
<h2><a id="ts%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TS 声明文件</h2>
<h3><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么要用声明文件？</h3>
<p>如果文件使用 TS 编写，在编译时可以自动生成声明文件，并在发布的时候将 .d.ts  文件一起发布，我们无需编写声明文件。</p>
<p>当我们在 TS 文件中引入使用第三方库的类型或使用集成库时，比如：@types/jquery  库，ES6 库的 Map 类型 ，这些库用 JS 开发，不能获取 TS 一样的类型提示，需要一个声明文件来帮助库的使用者来获取库的类型提示。</p>
<p><strong>注意：声明文件中只对类型定义，不能进行赋值和实现。</strong></p>
<h3><a id="%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>声明文件生成</h3>
<p>**前提：**生成声明文件的前提之一就是必须要 export 出去，如果都不 export 出去，说明外部根本不会用到，那么也就不需要声明了。</p>
<pre><code class="language-typescript">export const xxx = xxx;

export default class xxx

...........................................
</code></pre>
<p><strong>tsconfig.json 中下面的配置项：</strong></p>
<p>declaration：必须打开</p>
<p>declarationMap：打开或关闭都可以，打开时会额外生成一个 .d.ts.map 文件</p>
<p>skipLibCheck：必须关闭，否则会跳过 .d.ts 检查</p>
<pre><code class="language-json">&quot;declaration&quot;: true,            /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
// &quot;declarationMap&quot;: true,         /* Create sourcemaps for d.ts files. */
// &quot;skipLibCheck&quot;: true                                 /* Skip type checking all .d.ts files. */
</code></pre>
<p>使用 tsc 命令编译，查看编译后的文件，可以看到声明文件只有定义，没有实现。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205120930102.png" alt="image-20220512093026706" /></p>
<p>如果两个配置项全打开，则还会生成一个 .d.ts.map 文件。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205120928072.png" alt="image-20220512092834766" /></p>
<h3><a id="%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>声明文件编写</h3>
<p>1、js 文件 如何感知声明文件的作用</p>
<p>2、学会定义和使用声明文件</p>
<pre><code class="language-js">// 关键字 declare 表示声明的意思,我们可以用它来做出各种声明:
declare let/const  // 声明全局变量
declare function   // 声明全局方法
declare class      // 声明全局类
declare enum       // 声明全局枚举类型 
declare namespace  // 声明（含有子属性的）全局对象
interface/type     // 声明全局类型

//----------------------------------------------------------------------------------------
// 以 jquery 为例编写几个方法对应的声明文件。 test.d.ts
declare type CssSelector = {
    css: (key: string, value: string) =&gt; CssSelector
}

declare function $(ready: () =&gt; void): void

declare function $(selector: any): CssSelector

// 在src目录下任意位置使用
$(function(){});
$(&quot;div&quot;);
$(&quot;div&quot;).css(&quot;color&quot;, &quot;red&quot;);
</code></pre>
<p>Declare 声明后，全局范围内都可以使用（src目录下任意位置），并且不需要 import 。</p>
<p>只有 JS 能够识别的才需要加 declare，否则可以不加。比如 type、interface  JS不能识别，所以可以省略。</p>
<pre><code class="language-typescript">// test.d.ts
type CssSelector = {
    css: (key: string, value: string) =&gt; CssSelector
}

interface Print {
    print(content: string): void
}

declare function $(ready: () =&gt; void): void

declare function $(selector: any): CssSelector
</code></pre>
<h3><a id="%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%9C%A8%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>命名空间在声明文件中的使用</h3>
<p>1、命名空间本质上可以看做一个全局对象(编译成JS后就是对象)，它的作用可以简单理解为防止类型名重名；</p>
<p>2、命名空间 + declare 属于顶级声明，命名空间内部不能再使用 declare 否则会报错，但是可以通过 export 导出，我们一般都这么做；</p>
<p>3、使用命名空间后，使用时要加上命名空间名称；</p>
<pre><code class="language-typescript">declare namespace JQuery {
    type CssSelector = {
        css: (key: string, value: string) =&gt; CssSelector
    }

    export function $(ready: () =&gt; void): void

    export function $(selector: any): CssSelector
}
    
// 加上命名空间后，访问方式也要发生变化
JQuery.$(function () {
});

JQuery.$(&quot;div&quot;);

JQuery.$(&quot;div&quot;).css(&quot;color&quot;, &quot;red&quot;); 
</code></pre>
<p>4、命名空间里可以嵌套命名空间，但是访问的时候必须从顶级命名空间开始；</p>
<pre><code class="language-typescript">declare namespace JQuery {
    type CssSelector = {
        css: (key: string, value: string) =&gt; CssSelector
    }

    export function $(ready: () =&gt; void): void

    export function $(selector: any): CssSelector

    export namespace $ {
        function ajax(url: string, options?: any): void;

        function get(url: string, options?: any): void;

        function post(url: string, options?: any): void;
    }
}

// 前面的 JQuery 不可以省略
JQuery.$(function () {
});

JQuery.$(&quot;div&quot;);

JQuery.$(&quot;div&quot;).css(&quot;color&quot;, &quot;red&quot;);

JQuery.$.ajax(&quot;http:www.baidu.com&quot;);
</code></pre>
<h3><a id="%E6%A8%A1%E5%9D%97%E5%A3%B0%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模块声明</h3>
<p>使用模块声明对比使用namespace的好处就是可以省略命名空间名称。但是需要使用 import 语句导入模块。</p>
<pre><code class="language-typescript">declare module &quot;JQuery&quot; {
    type CssSelector = {
        css: (key: string, value: string) =&gt; CssSelector
    }

    function $(ready: () =&gt; void): void

    function $(selector: any): CssSelector

    namespace $ {
        function ajax(url: string, options?: any): void;

        function get(url: string, options?: any): void;

        function post(url: string, options?: any): void;
    }

    // 前一种导出方式也是可以的，但是为了兼容 commonJS、amd 规范，一般使用后一这种.
    // export default $;]
    export = $;
}

// 需要导入模块
import $ from &quot;JQuery&quot;

$(function () {
});

$(&quot;div&quot;);

$(&quot;div&quot;).css(&quot;color&quot;, &quot;red&quot;);

$.ajax(&quot;http:www.baidu.com&quot;);
</code></pre>
<h3><a id="%E5%A6%82%E4%BD%95%E5%9C%A8ts%E4%B8%AD%E5%BC%95%E5%85%A5-js%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何在 TS 中引入 js 文件</h3>
<p>1、开启 tsconfig.json 中的 allowJs 配置项</p>
<pre><code class="language-json">&quot;allowJs&quot;: true,           /* Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files. */
</code></pre>
<p>2、ts 文件中引入js示例</p>
<pre><code class="language-js">// student.js
export const add = (x, y) =&gt; {
    return x + y;
}

export class Student {

    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    show() {
        console.log(`name: ``{this.name}, age: ``{this.age}`);
    }
}


// index.ts
import {add, Student} from &quot;./student&quot;;

console.log(add(100, 200));

let stu = new Student(&quot;zhangsan&quot;, 29);
stu.show();
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TS 手写 axios 源码]]></title>
    <link href="http://yuanchao.blogs.io/16537420437408.html"/>
    <updated>2022-05-28T20:47:23+08:00</updated>
    <id>http://yuanchao.blogs.io/16537420437408.html</id>
    <content type="html"><![CDATA[
<h1><a id="%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目初始化</h1>
<h2><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h2>
<p>接下来的章节，我们会使用 TypeScript 来重构 axios，重构之前，我们需要简单地做一些需求分析，看一下我们这次重构需要支持哪些 feature。</p>
<h3><a id="features" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Features</h3>
<ul>
<li>在浏览器端使用 XMLHttpRequest 对象通讯</li>
<li>支持 Promise API</li>
<li>支持请求和响应的拦截器</li>
<li>支持请求数据和响应数据的转换</li>
<li>支持请求的取消</li>
<li>JSON 数据的自动转换</li>
<li>客户端防止 XSRF</li>
</ul>
<p>此外，我们还会支持一些 axios 库支持的一些其它的 feature。这里要注意的，我们这次重构不包括 axios 在 Node 中的实现，因为这部分我们在平时项目中应用的很少，还涉及到很多 Node.js 的知识，如果都讲的话，一是比较占用时间，另一个可能会喧宾夺主了。</p>
<h3><a id="xmlhttprequest" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>XMLHttpRequest</h3>
<p>由于 axios 底层使用的是 XMLHttpRequest，故有必要了解一下相关知识，关于 XMLHttpRequest 基础知识参考<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html">这里</a>。</p>
<pre><code class="language-js">// 下面是 2 段示例代码片段，分别对一个老版本和新版本
// level1
function sendAjax(){var xhr = new XMLHttpRequest();
  xhr.open('GET', 'example.php');
　xhr.send();
  xhr.onreadystatechange = function(){if ( xhr.readyState == 4 &amp;&amp; xhr.status == 200) {alert( xhr.responseText);
　　} else {alert( xhr.statusText);
　　}
　};
}

// level2
function sendAjax() {
  // 构造表单数据
  var formData = new FormData();
  formData.append('username', 'johndoe');
  formData.append('id', 123456);
  // 创建 xhr 对象 
  var xhr = new XMLHttpRequest();
  // 设置 xhr 请求的超时时间
  xhr.timeout = 3000;
  // 设置响应返回的数据格式
  xhr.responseType = &quot;text&quot;;
  // 创建一个 post 请求，采用异步
  xhr.open('POST', '/server', true);
  // 注册相关事件回调处理函数
  xhr.onload = function(e) {if(this.status == 200||this.status == 304){alert(this.responseText);
    }
  };
  xhr.ontimeout = function(e) {...};
  xhr.onerror = function(e) {...};
  xhr.upload.onprogress = function(e) {...};
  
  // 发送数据
  xhr.send(formData);
}
</code></pre>
<h2><a id="%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>初始化项目</h2>
<h3><a id="%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建代码仓库</h3>
<p>接下来，我们开始初始化项目，首先我们先去 GitHub 上创建一个 repo，填好 repo 名称，以及写一下 README，对项目先做个简单的描述。</p>
<p>通常我们初始化一个项目，需要配置一大堆东西，比如 <code>package.json</code>、<code>.editorconfig</code>、<code>.gitignore</code> 等；还包括一些构建工具如 <code>rollup</code>、<code>webpack</code> 以及它们的配置。</p>
<p>当我们使用 TypeScript 去写一个项目的时候，还需要配置 TypeScript 的编译配置文件 <code>tsconfig.json</code> 以及<br />
<code>tslint.json</code> 文件。</p>
<p>这些茫茫多的配置往往会让一个想从零开始写项目的同学望而却步，如果有一个脚手架工具帮我们生成好这些初始化文件该多好。好在确实有这样的工具，接下来我们的主角 <code>TypeScript library starter</code> 隆重登场。</p>
<h3><a id="typescript-library-starter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeScript library starter</h3>
<p>它是一个开源的 TypeScript 开发基础库的脚手架工具，可以帮助我们快速初始化一个 TypeScript 项目，我们可以去它的 <a href="https://github.com/alexjoverm/typescript-library-starter">官网地址</a> 学习和使用它。</p>
<h4><a id="%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用方式</h4>
<pre><code class="language-bash">git clone https://github.com/alexjoverm/typescript-library-starter.git ts-axios
cd ts-axios

npm install
</code></pre>
<p>先通过 <code>git clone</code> 把项目代码拉下来到我们的 <code>ts-axios</code> 目录，然后运行 <code>npm install</code> 安装依赖，并且给项目命名，我们仍然使用 <code>ts-axios</code>。</p>
<p>安装好依赖后，我们先来预览一下这个项目的目录结构。</p>
<h4><a id="%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>目录文件介绍</h4>
<p><code>TypeScript library starter</code> 生成的目录结构如下：</p>
<pre><code class="language-plain_text">├── CONTRIBUTING.md
├── LICENSE 
├── README.md
├── code-of-conduct.md
├── node_modules
├── package-lock.json
├── package.json
├── rollup.config.ts // rollup 配置文件
├── src // 源码目录
├── test // 测试目录
├── tools // 发布到 GitHup pages 以及 发布到 npm 的一些配置脚本工具
├── tsconfig.json // TypeScript 编译配置文件
└── tslint.json // TypeScript lint 文件
</code></pre>
<h4><a id="%E4%BC%98%E7%A7%80%E5%B7%A5%E5%85%B7%E9%9B%86%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优秀工具集成</h4>
<p>使用 <code>TypeScript library starter</code> 创建的项目集成了很多优秀的开源工具：</p>
<ul>
<li>使用 <a href="https://rollupjs.org/">RollupJS</a> 帮助我们打包。</li>
<li>使用 <a href="https://github.com/prettier/prettier">Prettier</a> 和 <a href="https://palantir.github.io/tslint/">TSLint</a> 帮助我们格式化代码以及保证代码风格一致性。</li>
<li>使用 <a href="https://typedoc.org/">TypeDoc</a> 帮助我们自动生成文档并部署到 GitHub pages。</li>
<li>使用 <a href="https://jestjs.io/">Jest</a>帮助我们做单元测试。</li>
<li>使用 <a href="https://github.com/commitizen/cz-cli">Commitizen</a>帮助我们生成规范化的提交注释。</li>
<li>使用 <a href="https://github.com/semantic-release/semantic-release">Semantic release</a>帮助我们管理版本和发布。</li>
<li>使用 <a href="https://github.com/typicode/husky">husky</a>帮助我们更简单地使用 git hooks。</li>
<li>使用 <a href="https://github.com/conventional-changelog/conventional-changelog">Conventional changelog</a>帮助我们通过代码提交信息自动生成 change log。</li>
</ul>
<p>这里我们列举了很多工具，感兴趣的同学们可以点开他们的链接对这些工具做进一步学习。</p>
<h4><a id="npm-scripts" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Npm Scripts</h4>
<p><code>TypeScript library starter</code> 同样在 <code>package.json</code> 中帮我们配置了一些 <code>npm scripts</code>，接下来我们先列举一下我们开发中常用的 <code>npm scripts</code>，剩余的我们在之后学习中遇到的时候再来介绍。</p>
<ul>
<li><code>npm run lint</code>: 使用 TSLint 工具检查 <code>src</code> 和 <code>test</code> 目录下 TypeScript 代码的可读性、可维护性和功能性错误。</li>
<li><code>npm start</code>: 观察者模式运行 <code>rollup</code> 工具打包代码。</li>
<li><code>npm test</code>: 运行 <code>jest</code> 工具跑单元测试。</li>
<li><code>npm run commit</code>: 运行 <code>commitizen</code> 工具提交格式化的 <code>git commit</code> 注释。</li>
<li><code>npm run build</code>: 运行 <code>rollup</code> 编译打包 TypeScript 代码，并运行 <code>typedoc</code> 工具生成文档。</li>
</ul>
<h3><a id="%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关联远程分支</h3>
<p>代码已经初始化好，接下来我们要把当前代码仓库关联我们的远程仓库，首先在命令行中运行命令查看远程分支：</p>
<pre><code class="language-bash">git remote -v
</code></pre>
<p>这里我们不会得到任何输出，因为我们还没有关联远程分支，我们先去 GitHub 上找到我们仓库的地址，在命令行运行：</p>
<pre><code class="language-bash">git remote add origin 仓库地址
</code></pre>
<p>关联后，远程库的名字就是 <code>origin</code>，这是 <code>Git</code> 默认的叫法，也可以改成别的，但是 <code>origin</code> 这个名字一看就知道是远程库。</p>
<p>接着你就可以继续运行 <code>git remote -v</code> 查看关联结果了。</p>
<h4><a id="%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拉取代码</h4>
<p>运行如下命令从远程仓库拉取 master 分支代码并合并：</p>
<pre><code class="language-bash">git pull origin master
</code></pre>
<p>这个时候会报错：</p>
<pre><code class="language-bash">error: The following untracked working tree files would be overwritten by merge:
	README.md
Please move or remove them before you merge.
Aborting
</code></pre>
<p>因为我们在使用 <code>typescript library starter</code> 初始化代码的时候也创建了 <code>README.md</code>，和远程仓库的 <code>README.md</code> 冲突了。我们把 <code>README.md</code> 文件删除，再次运行：</p>
<pre><code class="language-bash">git pull origin master
</code></pre>
<p>这次代码就拉取成功了，并且在本地也创建了一个 <code>master</code> 分支。</p>
<h4><a id="%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>提交代码</h4>
<p>最后我们来提交代码，首先运行：</p>
<pre><code class="language-bash">git add .
</code></pre>
<p>把提交的代码从工作区添加到暂存区，然后运行 <code>npm run commit</code> 这个 <code>npm</code> 脚本来提交代码，运行后它会依次询问你几个问题，比如你这次修改的范围包括哪些、提交的描述、是否有 break change、影响了哪些 issue 等等。</p>
<p>填写完毕，工具会帮我们运行 <code>git commit</code> 并且自动把我们提交的信息合成一条提交注释。接着运行命令把代码推送到远程 git 仓库中：</p>
<pre><code class="language-bash">git push origin master
</code></pre>
<p>接着我们去 GitHub 仓库中就可以看到刚才这条提交记录了。</p>
<p>至此，我们项目已经初始化完毕，接下来我们就开始编写源码实现 axios 了。</p>
<h2><a id="%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80%E8%AF%B7%E6%B1%82%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编写基础请求代码</h2>
<p>我们这节课开始编写 <code>ts-axios</code> 库，我们的目标是实现简单的发送请求功能，即客户端通过 <code>XMLHttpRequest</code> 对象把请求发送到 server 端，server 端能收到请求并响应即可。</p>
<p>我们实现 <code>axios</code> 最基本的操作，通过传入一个对象发送请求，如下：</p>
<pre><code class="language-typescript">axios({
  method: 'get',
  url: '/simple/get',
  params: {
    a: 1,
    b: 2
  }
})
</code></pre>
<h3><a id="%E5%88%9B%E5%BB%BA%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建入口文件</h3>
<p>我们删除 <code>src</code> 目录下的文件，先创建一个 <code>index.ts</code> 文件，作为整个库的入口文件，然后我们先定义一个 <code>axios</code> 方法，并把它导出，如下：</p>
<pre><code class="language-typescript">function axios(config) {

}

export default axios

</code></pre>
<p>这里 TypeScript 编译器会检查到错误，分别是 <code>config</code> 的声明上有隐含的 <code>any</code> 报错，以及代码块为空。代码块为空我们比较好理解，第一个错误的原因是因为我们给 TypeScript 编译配置的 <code>strict</code> 设置为 <code>true</code> 导致。</p>
<h4><a id="%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6tsconfig-json" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编译配置文件 tsconfig.json</h4>
<p><code>tsconfig.json</code> 文件中指定了用来编译这个项目的根文件和编译选项，关于它的具体学习，我希望同学们去 <a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">官网</a> 系统学习一下</p>
<p>我们在之前讲 TypeScript 的基础时，会运行 <code>tsc</code> 命令去编译 TypeScript 文件，编译器会从当前目录开始去查找 <code>tsconfig.json</code> 文件，作为编译时的一些编译选项。</p>
<p>我们来看一下 tsconfig.json 文件，它包含了很多编译时的配置，其中我们把 <code>strict</code> 设置为 <code>true</code>，它相当于启用所有严格类型的检查选项。启用 <code>--strict</code> 相当于启用 <code>--noImplicitAny</code>,<code>--noImplicitThis</code>,<code>--alwaysStrict</code>，<code>--strictNullChecks</code> 和 <code>--strictFunctionTypes</code> 和 <code>--strictPropertyInitialization</code>。</p>
<p>我们讲 TypeScript 的基础时提到了 <code>--strictNullChecks</code>，其它的编译配置我建议同学们都去查看它的<a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">官网文档</a>，把它当做手册去查阅即可。</p>
<h4><a id="%E5%AE%9A%E4%B9%89axiosrequestconfig%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义 AxiosRequestConfig 接口类型</h4>
<p>接下来，我们需要给 <code>config</code> 参数定义一种接口类型。我们创建一个 <code>types</code> 目录，在下面创建一个 <code>index.ts</code> 文件，作为我们项目中公用的类型定义文件。</p>
<p>接下来我们来定义 <code>AxiosRequestConfig</code> 接口类型：</p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  url: string
  method?: string
  data?: any
  params?: any
}
</code></pre>
<p>其中，<code>url</code> 为请求的地址，必选属性；而其余属性都是可选属性。<code>method</code> 是请求的 HTTP 方法；<code>data</code> 是 <code>post</code>、<code>patch</code> 等类型请求的数据，放到 <code>request body</code> 中的；<code>params</code> 是 <code>get</code>、<code>head</code> 等类型请求的数据，拼接到 <code>url</code> 的 <code>query string</code> 中的。</p>
<p>为了让 <code>method</code> 只能传入合法的字符串，我们定义一种字符串字面量类型 <code>Method</code>：</p>
<pre><code class="language-typescript">export type Method = 'get' | 'GET'
  | 'delete' | 'Delete'
  | 'head' | 'HEAD'
  | 'options' | 'OPTIONS'
  | 'post' | 'POST'
  | 'put' | 'PUT'
  | 'patch' | 'PATCH'
</code></pre>
<p>接着我们把 <code>AxiosRequestConfig</code> 中的 <code>method</code> 属性类型改成这种字符串字面量类型：</p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  url: string
  method?: Method
  data?: any
  params?: any
}
</code></pre>
<p>然后回到 <code>index.ts</code>，我们引入 <code>AxiosRequestConfig</code> 类型，作为 <code>config</code> 的参数类型，如下：</p>
<pre><code class="language-typescript">import {AxiosRequestConfig} from './types'

function axios(config: AxiosRequestConfig) {
}

export default axios
</code></pre>
<p>那么接下来，我们就来实现这个函数体内部的逻辑——发送请求。</p>
<h3><a id="%E5%88%A9%E7%94%A8xmlhttprequest%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>利用 XMLHttpRequest 发送请求</h3>
<p>我们并不想在 <code>index.ts</code> 中去实现发送请求的逻辑，我们利用模块化的编程思想，把这个功能拆分到一个单独的模块中。</p>
<p>于是我们在 <code>src</code> 目录下创建一个 <code>xhr.ts</code> 文件，我们导出一个 <code>xhr</code> 方法，它接受一个 <code>config</code> 参数，类型也是 <code>AxiosRequestConfig</code> 类型。</p>
<pre><code class="language-typescript">import {AxiosRequestConfig} from './types'

export default function xhr(config: AxiosRequestConfig) {
}
</code></pre>
<p>接下来，我们来实现这个函数体逻辑，如下：</p>
<pre><code class="language-typescript">export default function xhr(config: AxiosRequestConfig): void {const { data = null, url, method = 'get'} = config

  const request = new XMLHttpRequest()request.open(method.toUpperCase(), url, true)request.send(data)
}
</code></pre>
<p>我们首先通过解构赋值的语法从 <code>config</code> 中拿到对应的属性值赋值给我的变量，并且还定义了一些默认值，因为在 <code>AxiosRequestConfig</code> 接口的定义中，有些属性是可选的。</p>
<p>接着我们实例化了一个 <code>XMLHttpRequest</code> 对象，然后调用了它的 <code>open</code> 方法，传入了对应的一些参数，最后调用 <code>send</code> 方法发送请求。</p>
<p>对于 <code>XMLHttpRequest</code> 的学习，我希望同学们去 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">mdn</a> 上系统地学习一下它的一些属性和方法，当做参考资料，因为在后续的开发中我们可能会反复查阅这些文档资料。</p>
<h4><a id="%E5%BC%95%E5%85%A5xhr%E6%A8%A1%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>引入 xhr 模块</h4>
<p>编写好了 <code>xhr</code> 模块，我们就需要在 <code>index.ts</code> 中去引入这个模块，如下：</p>
<pre><code class="language-typescript">import {AxiosRequestConfig} from './types'
import xhr from './xhr'

function axios(config: AxiosRequestConfig): void {xhr(config)
}

export default axios
</code></pre>
<p>那么至此，我们基本的发送请求代码就编写完毕了，接下来我们来写一个小 demo，来使用我们编写的 axios 库去发送请求。</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<p>我们会利用 Node.js 的 <a href="http://expressjs.com/"><code>express</code></a> 库去运行我们的 demo，利用 <a href="https://webpack.js.org/"><code>webpack</code></a> 来作为 demo 的构建工具。</p>
<h4><a id="%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>依赖安装</h4>
<p>我们先来安装一些编写 demo 需要的依赖包，如下：</p>
<pre><code class="language-plain_text">&quot;webpack&quot;: &quot;^4.28.4&quot;,
&quot;webpack-dev-middleware&quot;: &quot;^3.5.0&quot;,
&quot;webpack-hot-middleware&quot;: &quot;^2.24.3&quot;,
&quot;ts-loader&quot;: &quot;^5.3.3&quot;,
&quot;tslint-loader&quot;: &quot;^3.5.4&quot;,
&quot;express&quot;: &quot;^4.16.4&quot;,
&quot;body-parser&quot;: &quot;^1.18.3&quot;
</code></pre>
<p>其中，<code>webpack</code> 是打包构建工具，<code>webpack-dev-middleware</code> 和 <code>webpack-hot-middleware</code> 是 2 个 <code>express</code> 的 <code>webpack</code> 中间件，<code>ts-loader</code> 和 <code>tslint-loader</code> 是 <code>webpack</code> 需要的 TypeScript 相关 loader，<code>express</code> 是 Node.js 的服务端框架，<code>body-parser</code> 是 <code>express</code> 的一个中间件，解析 <code>body</code> 数据用的。</p>
<h4><a id="%E7%BC%96%E5%86%99webpack%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编写 webpack 配置文件</h4>
<p>在 <code>examples</code> 目录下创建 <code>webpack</code> 配置文件 <code>webpack.config.js</code>：</p>
<pre><code class="language-javascript">const fs = require('fs')
const path = require('path')
const webpack = require('webpack')

module.exports = {
  mode: 'development',

  /**
   * 我们会在 examples 目录下建多个子目录
   * 我们会把不同章节的 demo 放到不同的子目录中
   * 每个子目录的下会创建一个 app.ts
   * app.ts 作为 webpack 构建的入口文件
   * entries 收集了多目录个入口文件，并且每个入口还引入了一个用于热更新的文件
   * entries 是一个对象，key 为目录名
   */
  entry: fs.readdirSync(__dirname).reduce((entries, dir) =&gt; {const fullDir = path.join(__dirname, dir)
    const entry = path.join(fullDir, 'app.ts')
    if (fs.statSync(fullDir).isDirectory()&amp;&amp; fs.existsSync(entry)) {entries[dir] = ['webpack-hot-middleware/client', entry]
    }

    return entries
  }, {}),

  /**
   * 根据不同的目录名称，打包生成目标 js，名称和目录名一致
   */
  output: {path: path.join(__dirname, '__build__'),
    filename: '[name].js',
    publicPath: '/__build__/'
  },

  module: {
    rules: [
      {
        test: /\.ts$/,
        enforce: 'pre',
        use: [
          {loader: 'tslint-loader'}
        ]
      },
      {
        test: /\.tsx?$/,
        use: [
          {
            loader: 'ts-loader',
            options: {transpileOnly: true}
          }
        ]
      }
    ]
  },

  resolve: {extensions: ['.ts', '.tsx', '.js']
  },

  plugins: [new webpack.HotModuleReplacementPlugin(),
    new webpack.NoEmitOnErrorsPlugin()]}
</code></pre>
<h4><a id="%E7%BC%96%E5%86%99server%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编写 server 文件</h4>
<p>在 <code>examples</code> 目录下创建 <code>server.js</code> 文件：</p>
<pre><code class="language-javascript">const express = require('express')
const bodyParser = require('body-parser')
const webpack = require('webpack')
const webpackDevMiddleware = require('webpack-dev-middleware')
const webpackHotMiddleware = require('webpack-hot-middleware')
const WebpackConfig = require('./webpack.config')

const app = express()const compiler = webpack(WebpackConfig)

app.use(webpackDevMiddleware(compiler, {
  publicPath: '/__build__/',
  stats: {
    colors: true,
    chunks: false
  }
}))app.use(webpackHotMiddleware(compiler))

app.use(express.static(__dirname))

app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: true}))

const port = process.env.PORT || 8080
module.exports = app.listen(port, () =&gt; {console.log(`Server listening on http://localhost:${port}, Ctrl+C to stop`)})
</code></pre>
<h4><a id="%E7%BC%96%E5%86%99demo%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编写 demo 代码</h4>
<p>首先在 <code>examples</code> 目录下创建 <code>index.html</code> 和 <code>global.css</code>，作为所有 <code>demo</code> 的入口文件已全局样式文件。</p>
<p><code>index.html</code>：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;ts-axios examples&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/global.css&quot;&gt;
  &lt;/head&gt;
  &lt;body style=&quot;padding: 0 20px&quot;&gt;
    &lt;h1&gt;ts-axios examples&lt;/h1&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;simple&quot;&gt;Simple&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>global.css</code>：</p>
<pre><code class="language-css">html, body {
  font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;
  color: #2c3e50;
}

ul {
  line-height: 1.5em;
  padding-left: 1.5em;
}

a {
  color: #7f8c8d;
  text-decoration: none;
}

a:hover {color: #4fc08d;}
</code></pre>
<p>然后在 <code>examples</code> 目录下创建 <code>simple</code> 目录，作为本章节的 demo 目录，在该目录下再创建 <code>index.html</code> 和 <code>app.ts</code> 文件</p>
<p><code>index.html</code> 文件如下:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Simple example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;/__build__/simple.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>app.ts</code> 文件如下：</p>
<pre><code class="language-typescript">import axios from '../../src/index'

axios({
  method: 'get',
  url: '/simple/get',
  params: {
    a: 1,
    b: 2
  }
})
</code></pre>
<p>因为我们这里通过 <code>axios</code> 发送了请求，那么我们的 server 端要实现对应的路由接口，我们来修改 <code>server.js</code>，添加如下代码：</p>
<pre><code class="language-javascript">const router = express.Router()router.get('/simple/get', function(req, res) {
  res.json({msg: `hello world`})
})app.use(router)
</code></pre>
<h4><a id="%E8%BF%90%E8%A1%8Cdemo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>运行 demo</h4>
<p>接着我们在 <code>package.json</code> 中去新增一个 <code>npm script</code>：</p>
<pre><code class="language-plain_text">&quot;dev&quot;: &quot;node examples/server.js&quot;
</code></pre>
<p>然后我们去控制台执行命令</p>
<pre><code class="language-bash">npm run dev
</code></pre>
<p>相当于执行了 <code>node examples/server.js</code>，会开启我们的 server。</p>
<p>接着我们打开 chrome 浏览器，访问 <code>http://localhost:8080/</code> 即可访问我们的 demo 了，我们点到 <code>Simple</code> 目录下，通过开发者工具的 network 部分我们可以看到成功发送到了一条请求，并在 response 中看到了服务端返回的数据。</p>
<p>至此，我们就实现了一个简单的请求发送，并编写了相关的 demo。但是现在存在一些问题：我们传入的 <code>params</code> 数据并没有用，也没有拼接到 <code>url</code> 上；我们对 request body 的数据格式、请求头 headers 也没有做处理；另外我们虽然从网络层面收到了响应的数据，但是我们代码层面也并没有对响应的数据做处理。那么下面一章，我们就来解决这些问题。</p>
<h1><a id="%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础功能实现</h1>
<h2><a id="%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82url%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理请求 url 参数</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>还记得我们上节课遗留了一个问题，再来看这个例子：</p>
<pre><code class="language-typescript">axios({
  method: 'get',
  url: '/base/get',
  params: {
    a: 1,
    b: 2
  }
})
</code></pre>
<p>我们希望最终请求的 <code>url</code> 是 <code>/base/get?a=1&amp;b=2</code>，这样服务端就可以通过请求的 url 解析到我们传来的参数数据了。实际上就是把 <code>params</code> 对象的 key 和 value 拼接到 <code>url</code> 上。</p>
<p>再来看几个更复杂的例子。</p>
<h4><a id="%E5%8F%82%E6%95%B0%E5%80%BC%E4%B8%BA%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数值为数组</h4>
<pre><code class="language-typescript">axios({
  method: 'get',
  url: '/base/get',
  params: {foo: ['bar', 'baz']
  }
})
</code></pre>
<p>最终请求的 <code>url</code> 是 <code>/base/get?foo[]=bar&amp;foo[]=baz'</code>。</p>
<h4><a id="%E5%8F%82%E6%95%B0%E5%80%BC%E4%B8%BA%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数值为对象</h4>
<pre><code class="language-typescript">axios({
  method: 'get',
  url: '/base/get',
  params: {
    foo: {bar: 'baz'}
  }
})
</code></pre>
<p>最终请求的 <code>url</code> 是 <code>/base/get?foo=%7B%22bar%22:%22baz%22%7D</code>，<code>foo</code> 后面拼接的是 <code>{&quot;bar&quot;:&quot;baz&quot;}</code> encode 后的结果。</p>
<h4><a id="%E5%8F%82%E6%95%B0%E5%80%BC%E4%B8%BAdate%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数值为 Date 类型</h4>
<pre><code class="language-typescript">const date = new Date()

axios({
  method: 'get',
  url: '/base/get',
  params: {date}
})
</code></pre>
<p>最终请求的 <code>url</code> 是 <code>/base/get?date=2019-04-01T05:55:39.030Z</code>，<code>date</code> 后面拼接的是 <code>date.toISOString()</code> 的结果。</p>
<h4><a id="%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E6%94%AF%E6%8C%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>特殊字符支持</h4>
<p>对于字符 <code>@</code>、<code>:</code>、<code>$</code>、<code>,</code>、<code> </code>、<code>[</code>、<code>]</code>，我们是允许出现在 <code>url</code> 中的，不希望被 encode。</p>
<pre><code class="language-typescript">axios({
  method: 'get',
  url: '/base/get',
  params: {foo: '@:$,'}
})
</code></pre>
<p>最终请求的 <code>url</code> 是 <code>/base/get?foo=@:$+</code>，注意，我们会把空格 <code> </code> 转换成 <code>+</code>。</p>
<h4><a id="%E7%A9%BA%E5%80%BC%E5%BF%BD%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>空值忽略</h4>
<p>对于值为 <code>null</code> 或者 <code>undefined</code> 的属性，我们是不会添加到 url 参数中的。</p>
<pre><code class="language-typescript">axios({
  method: 'get',
  url: '/base/get',
  params: {
    foo: 'bar',
    baz: null
  }
})
</code></pre>
<p>最终请求的 <code>url</code> 是 <code>/base/get?foo=bar</code>。</p>
<h4><a id="%E4%B8%A2%E5%BC%83url%E4%B8%AD%E7%9A%84%E5%93%88%E5%B8%8C%E6%A0%87%E8%AE%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>丢弃 url 中的哈希标记</h4>
<pre><code class="language-typescript">axios({
  method: 'get',
  url: '/base/get#hash',
  params: {foo: 'bar'}
})
</code></pre>
<p>最终请求的 <code>url</code> 是 <code>/base/get?foo=bar</code></p>
<h4><a id="%E4%BF%9D%E7%95%99url%E4%B8%AD%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>保留 url 中已存在的参数</h4>
<pre><code class="language-typescript">axios({
  method: 'get',
  url: '/base/get?foo=bar',
  params: {bar: 'baz'}
})
</code></pre>
<p>最终请求的 <code>url</code> 是 <code>/base/get?foo=bar&amp;bar=baz</code></p>
<h3><a id="buildurl%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>buildURL 函数实现</h3>
<p>根据我们之前的需求分析，我们要实现一个工具函数，把 <code>params</code> 拼接到 <code>url</code> 上。我们希望把项目中的一些工具函数、辅助方法独立管理，于是我们创建一个 <code>helpers</code> 目录，在这个目录下创建 <code>url.ts</code> 文件，未来会把处理 <code>url</code> 相关的工具函数都放在该文件中。</p>
<p><code>helpers/url.ts</code>：</p>
<pre><code class="language-typescript">import {isDate, isObject} from './util'

function encode (val: string): string {return encodeURIComponent(val)
    .replace(/%40/g, '@')
    .replace(/%3A/gi, ':')
    .replace(/%24/g, '$')
    .replace(/%2C/gi, ',')
    .replace(/%20/g, '+')
    .replace(/%5B/gi, '[')
    .replace(/%5D/gi, ']')
}

export function bulidURL (url: string, params?: any) {if (!params) {return url}

  const parts: string[] = []

  Object.keys(params).forEach((key) =&gt; {let val = params[key]
    if (val === null || typeof val === 'undefined') {return}
    let values: string[]
    if (Array.isArray(val)) {
      values = val
      key += '[]'} else {values = [val]
    }
    values.forEach((val) =&gt; {if (isDate(val)) {val = val.toISOString()
      } else if (isObject(val)) {val = JSON.stringify(val)
      }
      parts.push(```{encode(key)}=``{encode(val)}`)})
  })let serializedParams = parts.join('&amp;')

  if (serializedParams) {const markIndex = url.indexOf('#')
    if (markIndex !== -1) {url = url.slice(0, markIndex)
    }

    url += (url.indexOf('?') === -1 ? '?' : '&amp;')+ serializedParams}

  return url
}
</code></pre>
<p><code>helpers/util.ts</code>：</p>
<pre><code class="language-typescript">const toString = Object.prototype.toString

export function isDate (val: any): val is Date {return toString.call(val) === '[object Date]'
}

export function isObject (val: any): val is Object {return val !== null &amp;&amp; typeof val === 'object'}

</code></pre>
<h3><a id="%E5%AE%9E%E7%8E%B0url%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现 url 参数处理逻辑</h3>
<p>我们已经实现了 <code>buildURL</code> 函数，接下来我们来利用它实现 <code>url</code> 参数的处理逻辑。</p>
<p>在 <code>index.ts</code> 文件中添加如下代码：</p>
<pre><code class="language-typescript">function axios (config: AxiosRequestConfig): void {processConfig(config)
  xhr(config)
}

function processConfig (config: AxiosRequestConfig): void {config.url = transformUrl(config)
}

function transformUrl (config: AxiosRequestConfig): string {const { url, params} = config
  return bulidURL(url, params)
}
</code></pre>
<p>在执行 <code>xhr</code> 函数前，我们先执行 <code>processConfig</code> 方法，对 <code>config</code> 中的数据做处理，除了对 <code>url</code> 和 <code>params</code> 处理之外，未来还会处理其它属性。</p>
<p>在 <code>processConfig</code> 函数内部，我们通过执行 <code>transformUrl</code> 函数修改了 <code>config.url</code>，该函数内部调用了 <code>buildURL</code>。</p>
<p>那么至此，我们对 <code>url</code> 参数处理逻辑就实现完了，接下来我们就开始编写 demo 了。</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<p>在 <code>examples</code> 目录下创建 <code>base</code> 目录，在 <code>base</code> 目录下创建 <code>index.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Base example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;/__build__/base.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>接着创建 <code>app.ts</code> 作为入口文件：</p>
<pre><code class="language-typescript">import axios from '../../src/index'

axios({
  method: 'get',
  url: '/base/get',
  params: {foo: ['bar', 'baz']
  }
})

axios({
  method: 'get',
  url: '/base/get',
  params: {
    foo: {bar: 'baz'}
  }
})const date = new Date()

axios({
  method: 'get',
  url: '/base/get',
  params: {date}
})

axios({
  method: 'get',
  url: '/base/get',
  params: {foo: '@:$,'}
})

axios({
  method: 'get',
  url: '/base/get',
  params: {
    foo: 'bar',
    baz: null
  }
})

axios({
  method: 'get',
  url: '/base/get#hash',
  params: {foo: 'bar'}
})

axios({
  method: 'get',
  url: '/base/get?foo=bar',
  params: {bar: 'baz'}
})
</code></pre>
<p>接着在 <code>server.js</code> 添加新的接口路由：</p>
<pre><code class="language-typescript">router.get('/base/get', function(req, res) {res.json(req.query)
})
</code></pre>
<p>然后在命令行运行 <code>npm run dev</code>，接着打开 chrome 浏览器，访问 <code>http://localhost:8080/</code> 即可访问我们的 demo 了，我们点到 <code>Base</code> 目录下，通过开发者工具的 network 部分我们可以看到成功发送的多条请求，并可以观察它们最终请求的 url，已经如期添加了请求参数。</p>
<p>那么至此我们的请求 <code>url</code> 参数处理编写完了，下一小节我们会对 <code>request body</code> 数据做处理。</p>
<h2><a id="%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82body%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理请求 body 数据</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>我们通过执行 <code>XMLHttpRequest</code> 对象实例的 <code>send</code> 方法来发送请求，并通过该方法的参数设置请求 <code>body</code> 数据，我们可以去 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send">mdn</a> 查阅该方法支持的参数类型。</p>
<p>我们发现 <code>send</code> 方法的参数支持 <code>Document</code> 和 <code>BodyInit</code> 类型，<code>BodyInit</code> 包括了 <code>Blob</code>, <code>BufferSource</code>, <code>FormData</code>, <code>URLSearchParams</code>, <code>ReadableStream</code>、<code>USVString</code>，当没有数据的时候，我们还可以传入 <code>null</code>。</p>
<p>但是我们最常用的场景还是传一个普通对象给服务端，例如：</p>
<pre><code class="language-typescript">axios({
  method: 'post',
  url: '/base/post',
  data: { 
    a: 1,
    b: 2 
  }
})
</code></pre>
<p>这个时候 <code>data</code> 是不能直接传给 <code>send</code> 函数的，我们需要把它转换成 JSON 字符串。</p>
<h3><a id="transformrequest%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>transformRequest 函数实现</h3>
<p>根据需求分析，我们要实现一个工具函数，对 request 中的 <code>data</code> 做一层转换。我们在 <code>helpers</code> 目录新建 <code>data.ts</code> 文件。</p>
<p><code>helpers/data.ts</code>：</p>
<pre><code class="language-typescript">import {isPlainObject} from './util'

export function transformRequest (data: any): any {if (isPlainObject(data)) {return JSON.stringify(data)
  }
  return data
}
</code></pre>
<p><code>helpers/util.js</code>：</p>
<pre><code class="language-typescript">export function isPlainObject (val: any): val is Object {return toString.call(val) === '[object Object]'
}
</code></pre>
<p>这里为什么要使用 <code>isPlainObject</code> 函数判断，而不用之前的 <code>isObject</code> 函数呢，因为 <code>isObject</code> 的判断方式，对于 <code>FormData</code>、<code>ArrayBuffer</code> 这些类型，<code>isObject</code> 判断也为 <code>true</code>，但是这些类型的数据我们是不需要做处理的，而 <code>isPlainObject</code> 的判断方式，只有我们定义的普通 <code>JSON</code> 对象才能满足。</p>
<p><code>helpers/url.ts</code>：</p>
<pre><code class="language-typescript">if (isDate(val)) {val = val.toISOString()
} else if (isPlainObject(val)) {val = JSON.stringify(val)
}
</code></pre>
<p>对于上节课我们对请求参数值的判断，我们也应该用 <code>isPlainObject</code> 才更加合理。</p>
<p><code>helpers/util.js</code></p>
<pre><code class="language-typescript">// export function isObject (val: any): val is Object {
//   return val !== null &amp;&amp; typeof val === 'object'
// }
</code></pre>
<p>既然现在 <code>isObject</code> 方法不再使用，我们先将其注释。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82body%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现请求 body 处理逻辑</h3>
<p><code>index.ts</code>：</p>
<pre><code class="language-typescript">import {transformRequest} from './helpers/data'

function processConfig (config: AxiosRequestConfig): void {config.url = transformURL(config)
  config.data = transformRequestData(config)
}

function transformRequestData (config: AxiosRequestConfig): any {return transformRequest(config.data)
}
</code></pre>
<p>我们定义了 <code>transformRequestData</code> 函数，去转换请求 <code>body</code> 的数据，内部调用了我们刚刚实现的的 <code>transformRequest</code> 方法。</p>
<p>然后我们在 <code>processConfig</code> 内部添加了这段逻辑，在处理完 url 后接着对 <code>config</code> 中的 <code>data</code> 做处理。</p>
<h3><a id="%E7%BC%96%E5%86%99demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编写 demo</h3>
<pre><code class="language-typescript">axios({
  method: 'post',
  url: '/base/post',
  data: {
    a: 1,
    b: 2
  }
})const arr = new Int32Array([21, 31])

axios({
  method: 'post',
  url: '/base/buffer',
  data: arr
})
</code></pre>
<p>我们在 <code>examples/base/app.ts</code> 添加 2 段代码，第一个 post 请求的 <code>data</code> 是一个普通对象，第二个请求的 <code>data</code> 是一个 <code>Int32Array</code> 类型的数据，它是可以直接传给 <code>XMLHttpRequest</code> 对象的 <code>send</code> 方法的。</p>
<pre><code class="language-javascript">router.post('/base/post', function(req, res) {res.json(req.body)
})router.post('/base/buffer', function(req, res) {let msg = []
  req.on('data', (chunk) =&gt; {if (chunk) {msg.push(chunk)
    }
  })req.on('end', () =&gt; {let buf = Buffer.concat(msg)
    res.json(buf.toJSON())
  })})
</code></pre>
<p>我们接着在 <code>examples/server.js</code> 中添加 2 个路由，分别针对这俩种请求，返回请求传入的数据。</p>
<p>然后我们打开浏览器运行 demo，看一下结果，我们发现 <code>/base/buffer</code> 的请求是可以拿到数据，但是 <code>base/post</code> 请求的 response 里却返回的是一个空对象，这是什么原因呢？</p>
<p>实际上是因为我们虽然执行 <code>send</code> 方法的时候把普通对象 <code>data</code> 转换成一个 <code>JSON</code> 字符串，但是我们请求 <code>header</code> 的 <code>Content-Type</code> 是 <code>text/plain;charset=UTF-8</code>，导致了服务端接受到请求并不能正确解析请求 <code>body</code> 的数据。</p>
<p>知道这个问题后，下面一节课我们来实现对请求 <code>header</code> 的处理。</p>
<h2><a id="%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82header" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理请求 header</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>我们上节课遗留了一个问题：</p>
<pre><code class="language-typescript">axios({
  method: 'post',
  url: '/base/post',
  data: {
    a: 1,
    b: 2
  }
})
</code></pre>
<p>我们做了请求数据的处理，把 <code>data</code> 转换成了 JSON 字符串，但是数据发送到服务端的时候，服务端并不能正常解析我们发送的数据，因为我们并没有给请求 <code>header</code> 设置正确的 <code>Content-Type </code>。</p>
<p>所以首先我们要支持发送请求的时候，可以支持配置 <code>headers</code> 属性，如下：</p>
<pre><code class="language-typescript">axios({
  method: 'post',
  url: '/base/post',
  headers: {'content-type': 'application/json;charset=utf-8'},
  data: {
    a: 1,
    b: 2
  }
})
</code></pre>
<p>并且在当我们传入的 <code>data</code> 为普通对象的时候，<code>headers</code> 如果没有配置 <code>Content-Type</code> 属性，需要自动设置请求 <code>header</code> 的 <code>Content-Type</code> 字段为：<code>application/json;charset=utf-8</code>。</p>
<h3><a id="processheaders%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>processHeaders 函数实现</h3>
<p>根据需求分析，我们要实现一个工具函数，对 request 中的 <code>headers</code> 做一层加工。我们在 <code>helpers</code> 目录新建 <code>headers.ts</code> 文件。</p>
<p><code>helpers/headers.ts</code>：</p>
<pre><code class="language-typescript">import {isPlainObject} from './util'

function normalizeHeaderName (headers: any, normalizedName: string): void {if (!headers) {return}
  Object.keys(headers).forEach(name =&gt; {if (name !== normalizedName &amp;&amp; name.toUpperCase() === normalizedName.toUpperCase()) {headers[normalizedName] = headers[name]
      delete headers[name]
    }
  })
}

export function processHeaders (headers: any, data: any): any {normalizeHeaderName(headers, 'Content-Type')
  
  if (isPlainObject(data)) {if (headers &amp;&amp; !headers['Content-Type']) {headers['Content-Type'] = 'application/json;charset=utf-8'
    }
  }
  return headers
}
</code></pre>
<p>这里有个需要注意的点，因为请求 <code>header</code> 属性是大小写不敏感的，比如我们之前的例子传入 <code>header</code> 的属性名 <code>content-type</code> 就是全小写的，所以我们先要把一些 <code>header</code> 属性名规范化。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82header%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现请求 header 处理逻辑</h3>
<p>在这之前，我们先修改一下 <code>AxiosRequestConfig</code> 接口类型的定义，添加 <code>headers</code> 这个可选属性：</p>
<p><code>types/index.ts</code></p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  url: string
  method?: Method
  data?: any
  params?: any
  headers?: any
}
</code></pre>
<p><code>index.ts</code>：</p>
<pre><code class="language-typescript">function processConfig (config: AxiosRequestConfig): void {config.url = transformURL(config)
  config.headers = transformHeaders(config)
  config.data = transformRequestData(config)
}

function transformHeaders (config: AxiosRequestConfig) {const { headers = {}, data } = config
  return processHeaders(headers, data)
}
</code></pre>
<p>因为我们处理 <code>header</code> 的时候依赖了 <code>data</code>，所以要在处理请求 <code>body</code> 数据之前处理请求 <code>header</code>。</p>
<p><code>xhr.ts</code>：</p>
<pre><code class="language-typescript">export default function xhr (config: AxiosRequestConfig): void {const { data = null, url, method = 'get', headers} = config

  const request = new XMLHttpRequest()request.open(method.toUpperCase(), url, true)Object.keys(headers).forEach((name) =&gt; {if (data === null &amp;&amp; name.toLowerCase() === 'content-type') {delete headers[name]
    } else {request.setRequestHeader(name, headers[name])
    }
  })request.send(data)
}
</code></pre>
<p>这里要额外判断一个逻辑，当我们传入的 <code>data</code> 为空的时候，请求 <code>header</code> 配置 <code>Content-Type</code> 是没有意义的，于是我们把它删除。</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<pre><code class="language-typescript">axios({
  method: 'post',
  url: '/base/post',
  data: {
    a: 1,
    b: 2
  }
})

axios({
  method: 'post',
  url: '/base/post',
  headers: {'content-type': 'application/json;'},
  data: {
    a: 1,
    b: 2
  }
})

const paramsString = 'q=URLUtils.searchParams&amp;topic=api'
const searchParams = new URLSearchParams(paramsString)

axios({
  method: 'post',
  url: '/base/post',
  data: searchParams
})
</code></pre>
<p>通过 demo 我们可以看到，当我们请求的数据是普通对象并且没有配置 <code>headers</code> 的时候，会自动为其添加 <code>Content-Type:application/json;charset=utf-8</code>；同时我们发现当 data 是某些类型如 <code>URLSearchParams</code> 的时候，浏览器会自动为请求 <code>header</code> 加上合适的 <code>Content-Type</code>。</p>
<p>至此我们对于请求的处理逻辑暂时告一段落。目前我们的请求从网络层面是可以收到服务端的响应的，下一节课我们就从代码层面来处理服务端响应，并且让调用方可以拿到从服务端返回的数据。</p>
<h2><a id="%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取响应数据</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>在前面的章节中，我们发送的请求都可以从网络层面接收到服务端返回的数据，但是代码层面并没有做任何关于返回数据的处理。我们希望能处理服务端响应的数据，并支持 Promise 链式调用的方式，如下：</p>
<pre><code class="language-typescript">axios({
  method: 'post',
  url: '/base/post',
  data: {
    a: 1,
    b: 2
  }
}).then((res) =&gt; {console.log(res)
})
</code></pre>
<p>我们可以拿到 <code>res</code> 对象，并且我们希望该对象包括：服务端返回的数据 <code>data</code>，HTTP 状态码 <code>status</code>，状态消息 <code>statusText</code>，响应头 <code>headers</code>、请求配置对象 <code>config</code> 以及请求的 <code>XMLHttpRequest</code> 对象实例 <code>request</code>。</p>
<h3><a id="%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义接口类型</h3>
<p>根据需求，我们可以定义一个 <code>AxiosResponse</code> 接口类型，如下：</p>
<pre><code class="language-typescript">export interface AxiosResponse {
  data: any
  status: number
  statusText: string
  headers: any
  config: AxiosRequestConfig
  request: any
}
</code></pre>
<p>另外，<code>axios</code> 函数返回的是一个 <code>Promise</code> 对象，我们可以定义一个 <code>AxiosPromise</code> 接口，它继承于 <code>Promise&lt;AxiosResponse&gt;</code> 这个泛型接口：</p>
<pre><code class="language-typescript">export interface AxiosPromise extends Promise&lt;AxiosResponse&gt; {
}
</code></pre>
<p>这样的话，当 <code>axios</code> 返回的是 <code>AxiosPromise</code> 类型，那么 <code>resolve</code> 函数中的参数就是一个 <code>AxiosResponse</code> 类型。</p>
<p>对于一个 AJAX 请求的 <code>response</code>，我们是可以指定它的响应的数据类型的，通过设置 <code>XMLHttpRequest</code> 对象的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType"><code>responseType</code></a> 属性，于是我们可以给 <code>AxiosRequestConfig</code> 类型添加一个可选属性：</p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  // ...
  responseType?: XMLHttpRequestResponseType
}
</code></pre>
<p><code>responseType</code> 的类型是一个 <code>XMLHttpRequestResponseType</code> 类型，它的定义是 <code>&quot;&quot; |&quot;arraybuffer&quot;|&quot;blob&quot;|&quot;document&quot;|&quot;json&quot;|&quot;text&quot;</code> 字符串字面量类型。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现获取响应数据逻辑</h3>
<p>首先我们要在 <code>xhr</code> 函数添加 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/onreadystatechange"><code>onreadystatechange</code></a> 事件处理函数，并且让 <code>xhr</code> 函数返回的是 <code>AxiosPromise</code> 类型。</p>
<p><code>xhr.ts</code>：</p>
<pre><code class="language-typescript">export default function xhr(config: AxiosRequestConfig): AxiosPromise {return new Promise((resolve) =&gt; {const { data = null, url, method = 'get', headers, responseType} = config

    const request = new XMLHttpRequest()if (responseType) {request.responseType = responseType}

    request.open(method.toUpperCase(), url, true)request.onreadystatechange = function handleLoad() {if (request.readyState !== 4) {return}

      const responseHeaders = request.getAllResponseHeaders()
      const responseData = responseType &amp;&amp; responseType !== 'text' ? request.response : request.responseText
      const response: AxiosResponse = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      }
      resolve(response)
    }

    Object.keys(headers).forEach((name) =&gt; {if (data === null &amp;&amp; name.toLowerCase() === 'content-type') {delete headers[name]
      } else {request.setRequestHeader(name, headers[name])
      }
    })request.send(data)
  })
}
</code></pre>
<p>注意，我们这里还判断了如果 <code>config</code> 中配置了 <code>responseType</code>，我们把它设置到 <code>request.responseType</code> 中。在 <code>onreadystatechange</code> 事件函数中，我们构造了 <code>AxiosResponse</code> 类型的 <code>reponse</code> 对象，并把它 <code>resolve</code> 出去。</p>
<p>修改了 <code>xhr</code> 函数，我们同样也要对应修改 <code>axios</code> 函数：</p>
<p><code>index.ts</code>：</p>
<pre><code class="language-typescript">function axios(config: AxiosRequestConfig): AxiosPromise {processConfig(config)
  return xhr(config)
}
</code></pre>
<p>这样我们就实现了 <code>axios</code> 函数的 Promise 化。</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<p>我们在 <code>examples/base/app.ts</code> 文件中添加 2 段代码：</p>
<pre><code class="language-typescript">axios({
  method: 'post',
  url: '/base/post',
  data: {
    a: 1,
    b: 2
  }
}).then((res) =&gt; {console.log(res)
})

axios({
  method: 'post',
  url: '/base/post',
  responseType: 'json',
  data: {
    a: 3,
    b: 4
  }
}).then((res) =&gt; {console.log(res)
})
</code></pre>
<p>我们打开浏览器运行 demo，看一下结果，发现我们可以正常 log 出这个 <code>res</code> 变量，它包含 <code>AxiosResponse</code> 类型中定义的那些属性，不过我们发现 2 个小问题：第一个是 <code>headers</code> 属性是一个字符串，我们需要把它解析成对象类型；第二个是在第一个请求中，得到的数据是一个 JSON 字符串，我们也需要把它转换成对象类型。</p>
<p>那么下一小节，我们将来解决第一个问题，对于响应的 <code>header</code> 做处理。</p>
<h2><a id="%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94header" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理响应 header</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>我们通过 <code>XMLHttpRequest</code> 对象的 <code>getAllResponseHeaders</code> 方法获取到的值是如下一段字符串：</p>
<pre><code class="language-plain_text">date: Fri, 05 Apr 2019 12:40:49 GMT
etag: W/&quot;d-Ssxx4FRxEutDLwo2+xkkxKc4y0k&quot;
connection: keep-alive
x-powered-by: Express
content-length: 13
content-type: application/json; charset=utf-8
</code></pre>
<p>每一行都是以回车符和换行符 <code>\r\n</code> 结束，它们是每个 <code>header</code> 属性的分隔符。对于上面这串字符串，我们希望最终解析成一个对象结构：</p>
<pre><code class="language-json">{
  date: 'Fri, 05 Apr 2019 12:40:49 GMT'
  etag: 'W/&quot;d-Ssxx4FRxEutDLwo2+xkkxKc4y0k&quot;',
  connection: 'keep-alive',
  'x-powered-by': 'Express',
  'content-length': '13'
  'content-type': 'application/json; charset=utf-8'
}
</code></pre>
<h3><a id="parseheaders%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>parseHeaders 函数实现及应用</h3>
<p>根据需求分析，我们要实现一个 <code>parseHeaders</code> 工具函数。</p>
<p><code>helpers/headers.ts</code>：</p>
<pre><code class="language-typescript">export function parseHeaders(headers: string): any {let parsed = Object.create(null)
  if (!headers) {return parsed}

  headers.split('\r\n').forEach(line =&gt; {let [key, val] = line.split(':')
    key = key.trim().toLowerCase()
    if (!key) {return}
    if (val) {val = val.trim()
    }
    parsed[key] = val
  })return parsed}
</code></pre>
<p>然后我们使用这个工具函数：</p>
<p><code>xhr.ts</code>：</p>
<pre><code class="language-typescript">const responseHeaders = parseHeaders(request.getAllResponseHeaders())
</code></pre>
<p>接着我们再去看刚才的 demo，发现我们已经把响应的 <code>headers</code> 字段从字符串解析成对象结构了。那么接下来，我们在解决之前遗留的第二个问题：对响应 <code>data</code> 字段的处理。</p>
<h2><a id="%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94data" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理响应 data</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>在我们不去设置 <code>responseType</code> 的情况下，当服务端返回给我们的数据是字符串类型，我们可以尝试去把它转换成一个 JSON 对象。例如：</p>
<pre><code class="language-plain_text">data: &quot;{&quot;a&quot;:1,&quot;b&quot;:2}&quot;
</code></pre>
<p>我们把它转换成：</p>
<pre><code class="language-json">data: {
  a: 1,
  b: 2
}
</code></pre>
<h3><a id="transformresponse%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>transformResponse 函数实现及应用</h3>
<p>根据需求分析，我们要实现一个 <code>transformResponse</code> 工具函数。</p>
<p><code>helpers/data.ts</code>：</p>
<pre><code class="language-typescript">export function transformResponse(data: any): any {if (typeof data === 'string') {
    try {data = JSON.parse(data)
    } catch (e) {// do nothing}
  }
  return data
}
</code></pre>
<p><code>index.ts</code>：</p>
<pre><code class="language-typescript">function axios(config: AxiosRequestConfig): AxiosPromise {processConfig(config)
  return xhr(config).then((res) =&gt; {return transformResponseData(res)
  })
}

function transformResponseData(res: AxiosResponse): AxiosResponse {res.data = transformResponse(res.data)
  return res
}
</code></pre>
<p>接着我们再去看刚才的 demo，发现我们已经把响应的 <code>data</code> 字段从字符串解析成 JSON 对象结构了。</p>
<p>那么至此，我们的 <code>ts-axios</code> 的基础功能已经实现完毕。不过到目前为止，我们都仅仅实现的是正常情况的逻辑，下面一章我们要处理各种异常情况的逻辑。</p>
<h1><a id="%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>异常处理情况</h1>
<h2><a id="%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>错误处理</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>在上一章节，我们实现了 <code>ts-axios</code> 的基础功能，但目前为止我们都是处理了正常接收请求的逻辑，并没有考虑到任何错误情况的处理，这对于一个程序的健壮性而言是远不够的，因此我们这一章需要对 AJAX 各种错误情况做处理。</p>
<p>并且我们希望程序也能捕获到这些错误，做进一步的处理。</p>
<pre><code class="language-typescript">axios({
  method: 'get',
  url: '/error/get'
}).then((res) =&gt; {console.log(res)
}).catch((e) =&gt; {console.log(e)
})
</code></pre>
<p>如果在请求的过程中发生任何错误，我们都可以在 <code>reject</code> 回调函数中捕获到。</p>
<p>我们把错误分成了几类，接下来我们就来分别处理这些错误情况。</p>
<h3><a id="%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E5%BC%82%E5%B8%B8%E9%94%99%E8%AF%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理网络异常错误</h3>
<p>当网络出现异常（比如不通）的时候发送请求会触发 <code>XMLHttpRequest</code> 对象实例的 <code>error</code> 事件，于是我们可以在 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestEventTarget/onerror"><code>onerror</code></a> 的事件回调函数中捕获此类错误。</p>
<p>我们在 <code>xhr</code> 函数中添加如下代码：</p>
<pre><code class="language-typescript">request.onerror = function handleError() {reject(new Error('Network Error'))
}
</code></pre>
<h3><a id="%E5%A4%84%E7%90%86%E8%B6%85%E6%97%B6%E9%94%99%E8%AF%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理超时错误</h3>
<p>我们可以设置某个请求的超时时间 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/timeout"><code>timeout</code></a>，也就是当请求发送后超过某个时间后仍然没收到响应，则请求自动终止，并触发 <code>timeout</code> 事件。</p>
<p>请求默认的超时时间是 0，即永不超时。所以我们首先需要允许程序可以配置超时时间：</p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  // ...
  timeout?: number
}
</code></pre>
<p>接着在 <code>xhr</code> 函数中添加如下代码：</p>
<pre><code class="language-typescript">const {/*...*/ timeout} = config

if (timeout) {request.timeout = timeout}

request.ontimeout = function handleTimeout() {reject(new Error(`Timeout of ${timeout} ms exceeded`))}
</code></pre>
<h3><a id="%E5%A4%84%E7%90%86%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理非 200 状态码</h3>
<p>对于一个正常的请求，往往会返回 200-300 之间的 HTTP 状态码，对于不在这个区间的状态码，我们也把它们认为是一种错误的情况做处理。</p>
<pre><code class="language-typescript">request.onreadystatechange = function handleLoad() {if (request.readyState !== 4) {return}

  if (request.status === 0) {return}

  const responseHeaders = parseHeaders(request.getAllResponseHeaders())
  const responseData =
    responseType &amp;&amp; responseType !== 'text' ? request.response : request.responseText
  const response: AxiosResponse = {
    data: responseData,
    status: request.status,
    statusText: request.statusText,
    headers: responseHeaders,
    config,
    request
  }
  handleResponse(response)
}

function handleResponse(response: AxiosResponse) {if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) {resolve(response)
  } else {reject(new Error(`Request failed with status code ${response.status}`))}}
</code></pre>
<p>我们在 <code>onreadystatechange</code> 的回调函数中，添加了对 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/status"><code>request.status</code></a> 的判断，因为当出现网络错误或者超时错误的时候，该值都为 0。</p>
<p>接着我们在 <code>handleResponse</code> 函数中对 <code>request.status</code> 的值再次判断，如果是 <code>2xx</code> 的状态码，则认为是一个正常的请求，否则抛错。</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<p>在 <code>examples</code> 目录下创建 <code>error</code> 目录，在 <code>error</code> 目录下创建 <code>index.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Error example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;/__build__/error.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>接着创建 <code>app.ts</code> 作为入口文件：</p>
<pre><code class="language-typescript">import axios from '../../src/index'

axios({
  method: 'get',
  url: '/error/get1'
}).then((res) =&gt; {console.log(res)
}).catch((e) =&gt; {console.log(e)
})

axios({
  method: 'get',
  url: '/error/get'
}).then((res) =&gt; {console.log(res)
}).catch((e) =&gt; {console.log(e)
})setTimeout(() =&gt; {
  axios({
    method: 'get',
    url: '/error/get'
  }).then((res) =&gt; {console.log(res)
  }).catch((e) =&gt; {console.log(e)
  })}, 5000)

axios({
  method: 'get',
  url: '/error/timeout',
  timeout: 2000
}).then((res) =&gt; {console.log(res)
}).catch((e) =&gt; {console.log(e.message)
})
</code></pre>
<p>接着在 <code>server.js</code> 添加新的接口路由：</p>
<pre><code class="language-typescript">router.get('/error/get', function(req, res) {if (Math.random() &gt; 0.5) {
    res.json({msg: `hello world`})
  } else {res.status(500)
    res.end()}})

router.get('/error/timeout', function(req, res) {setTimeout(() =&gt; {
    res.json({msg: `hello world`})
  }, 3000)})
</code></pre>
<p>然后在命令行运行 <code>npm run dev</code>，接着打开 chrome 浏览器，访问 <code>http://localhost:8080/</code> 即可访问我们的 demo 了，我们点到 <code>Error</code> 目录下，通过开发者工具的 network 部分我们可以看到不同的错误情况。</p>
<p>至此我们对各种错误都做了处理，并把它们抛给了程序应用方，让他们对错误可以做进一步的处理。但是这里我们的错误都仅仅是简单的 Error 实例，只有错误文本信息，并不包含是哪个请求、请求的配置、响应对象等其它信息。那么下一节课，我们会对错误信息做增强。</p>
<h2><a id="%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%BC%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>错误信息增强</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>上一节课我们已经捕获了几类 AJAX 的错误，但是对于错误信息提供的非常有限，我们希望对外提供的信息不仅仅包含错误文本信息，还包括了请求对象配置 <code>config</code>，错误代码 <code>code</code>，<code>XMLHttpRequest</code> 对象实例 <code>request</code> 以及自定义响应对象 <code>response</code>。</p>
<pre><code class="language-typescript">axios({
  method: 'get',
  url: '/error/timeout',
  timeout: 2000
}).then((res) =&gt; {console.log(res)
}).catch((e: AxiosError) =&gt; {console.log(e.message)
  console.log(e.request)
  console.log(e.code)
})
</code></pre>
<p>这样对于应用方来说，他们就可以捕获到这些错误的详细信息，做进一步的处理。</p>
<p>那么接下来，我们就来对错误信息做增强。</p>
<h3><a id="%E5%88%9B%E5%BB%BAaxioserror%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建 AxiosError 类</h3>
<p>我们先来定义 <code>AxiosError</code> 类型接口，用于外部使用。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosError extends Error {
  config: AxiosRequestConfig
  code?: string
  request?: any
  response?: AxiosResponse
  isAxiosError: boolean
}
</code></pre>
<p>接着我们创建 <code>error.ts</code> 文件，然后实现 <code>AxiosError</code> 类，它是继承于 <code>Error</code> 类。</p>
<p><code>helpers/error.ts</code>：</p>
<pre><code class="language-typescript">import {AxiosRequestConfig, AxiosResponse} from '../types'

export class AxiosError extends Error {
  isAxiosError: boolean
  config: AxiosRequestConfig
  code?: string | null
  request?: any
  response?: AxiosResponse

  constructor(
    message: string,
    config: AxiosRequestConfig,
    code?: string | null,
    request?: any,
    response?: AxiosResponse
  ) {super(message)

    this.config = config
    this.code = code
    this.request = request
    this.response = response
    this.isAxiosError = true

    Object.setPrototypeOf(this, AxiosError.prototype)
  }
}

export function createError(
  message: string,
  config: AxiosRequestConfig,
  code?: string | null,
  request?: any,
  response?: AxiosResponse
): AxiosError {const error = new AxiosError(message, config, code, request, response)

  return error
}
</code></pre>
<p><code>AxiosError</code> 继承于 <code>Error</code> 类，添加了一些自己的属性：<code>config</code>、<code>code</code>、<code>request</code>、<code>response</code>、<code>isAxiosError</code> 等属性。这里要注意一点，我们使用了 <code>Object.setPrototypeOf(this, AxiosError.prototype)</code>，这段代码的目的是为了解决 TypeScript 继承一些内置对象的时候的坑，<a href="https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work">参考</a>。</p>
<p>另外，为了方便使用，我们对外暴露了一个 <code>createError</code> 的工厂方法。</p>
<h3><a id="createerror%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>createError 方法应用</h3>
<p>修改关于错误对象创建部分的逻辑，如下：</p>
<p><code>xhr.ts</code>：</p>
<pre><code class="language-typescript">import {createError} from './helpers/error'

request.onerror = function handleError() {
  reject(createError(
    'Network Error',
    config,
    null,
    request
  ))}

request.ontimeout = function handleTimeout() {
  reject(createError(`Timeout of ${config.timeout} ms exceeded`,
    config,
    'ECONNABORTED',
    request
  ))}

function handleResponse(response: AxiosResponse) {if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) {resolve(response)
  } else {
    reject(createError(`Request failed with status code ${response.status}`,
      config,
      null,
      request,
      response
    ))}}
</code></pre>
<h3><a id="%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>导出类型定义</h3>
<p>在 demo 中，TypeScript 并不能把 <code>e</code> 参数推断为 <code>AxiosError</code> 类型，于是我们需要手动指明类型，为了让外部应用能引入 <code>AxiosError</code> 类型，我们也需要把它们导出。</p>
<p>我们创建 <code>axios.ts</code> 文件，把之前的 <code>index.ts</code> 的代码拷贝过去，然后修改 <code>index.ts</code> 的代码。</p>
<p><code>index.ts</code>：</p>
<pre><code class="language-typescript">import axios from './axios'

export * from './types'

export default axios
</code></pre>
<p>这样我们在 demo 中就可以引入 <code>AxiosError</code> 类型了。</p>
<p><code>examples/error/app.ts</code>：</p>
<pre><code class="language-typescript">import axios, {AxiosError} from '../../src/index'

axios({
  method: 'get',
  url: '/error/timeout',
  timeout: 2000
}).then((res) =&gt; {console.log(res)
}).catch((e: AxiosError) =&gt; {console.log(e.message)
  console.log(e.code)
})
</code></pre>
<p>至此，我们关于 <code>ts-axios</code> 的异常处理逻辑就告一段落。下面的章节，我们会对 <code>ts-axios</code> 的接口做扩展，让它提供更多好用和方便的 API。</p>
<h1><a id="axios%E6%8E%A5%E5%8F%A3%E6%89%A9%E5%B1%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Axios 接口扩展</h1>
<h2><a id="%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展接口</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>为了用户更加方便地使用 axios 发送请求，我们可以为所有支持请求方法扩展一些接口：</p>
<ul>
<li>
<p><code>axios.request(config)</code></p>
</li>
<li>
<p><code>axios.get(url[, config])</code></p>
</li>
<li>
<p><code>axios.delete(url[, config])</code></p>
</li>
<li>
<p><code>axios.head(url[, config])</code></p>
</li>
<li>
<p><code>axios.options(url[, config])</code></p>
</li>
<li>
<p><code>axios.post(url[, data[, config]])</code></p>
</li>
<li>
<p><code>axios.put(url[, data[, config]])</code></p>
</li>
<li>
<p><code>axios.patch(url[, data[, config]])</code></p>
</li>
</ul>
<p>如果使用了这些方法，我们就不必在 <code>config</code> 中指定 <code>url</code>、<code>method</code>、<code>data</code> 这些属性了。</p>
<p>从需求上来看，<code>axios</code> 不再单单是一个方法，更像是一个混合对象，本身是一个方法，又有很多方法属性，接下来我们就来实现这个混合对象。</p>
<h3><a id="%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口类型定义</h3>
<p>根据需求分析，混合对象 <code>axios</code> 本身是一个函数，我们再实现一个包括它属性方法的类，然后把这个类的原型属性和自身属性再拷贝到 <code>axios</code> 上。</p>
<p>我们先来给 <code>axios</code> 混合对象定义接口：</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface Axios {request(config: AxiosRequestConfig): AxiosPromise

  get(url: string, config?: AxiosRequestConfig): AxiosPromise

  delete(url: string, config?: AxiosRequestConfig): AxiosPromise

  head(url: string, config?: AxiosRequestConfig): AxiosPromise

  options(url: string, config?: AxiosRequestConfig): AxiosPromise

  post(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise

  put(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise

  patch(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise
}

export interface AxiosInstance extends Axios {(config: AxiosRequestConfig): AxiosPromise
}

export interface AxiosRequestConfig {
  url?: string
  // ...
}

</code></pre>
<p>首先定义一个 <code>Axios</code> 类型接口，它描述了 <code>Axios</code> 类中的公共方法，接着定义了 <code>AxiosInstance</code> 接口继承 <code>Axios</code>，它就是一个混合类型的接口。</p>
<p>另外 <code>AxiosRequestConfig</code> 类型接口中的 <code>url</code> 属性变成了可选属性。</p>
<h3><a id="%E5%88%9B%E5%BB%BAaxios%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建 Axios 类</h3>
<p>我们创建一个 <code>Axios</code> 类，来实现接口定义的公共方法。我们创建了一个 <code>core</code> 目录，用来存放发送请求核心流程的代码。我们在 <code>core</code> 目录下创建 <code>Axios.ts</code> 文件。</p>
<p><code>core/Axios.ts</code></p>
<pre><code class="language-typescript">import {AxiosRequestConfig, AxiosPromise, Method} from '../types'
import dispatchRequest from './dispatchRequest'

export default class Axios {request(config: AxiosRequestConfig): AxiosPromise {return dispatchRequest(config)
  }

  get(url: string, config?: AxiosRequestConfig): AxiosPromise {return this._requestMethodWithoutData('get', url, config)
  }

  delete(url: string, config?: AxiosRequestConfig): AxiosPromise {return this._requestMethodWithoutData('delete', url, config)
  }

  head(url: string, config?: AxiosRequestConfig): AxiosPromise {return this._requestMethodWithoutData('head', url, config)
  }

  options(url: string, config?: AxiosRequestConfig): AxiosPromise {return this._requestMethodWithoutData('options', url, config)
  }

  post(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise {return this._requestMethodWithData('post', url, data, config)
  }

  put(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise {return this._requestMethodWithData('put', url, data, config)
  }

  patch(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise {return this._requestMethodWithData('patch', url, data, config)
  }

  _requestMethodWithoutData(method: Method, url: string, config?: AxiosRequestConfig) {
    return this.request(Object.assign(config || {}, {
        method,
        url
      }))}

  _requestMethodWithData(method: Method, url: string, data?: any, config?: AxiosRequestConfig) {
    return this.request(Object.assign(config || {}, {
        method,
        url,
        data
      }))}
}
</code></pre>
<p>其中 <code>request</code> 方法的功能和我们之前的 <code>axios</code> 函数功能是一致。<code>axios</code> 函数的功能就是发送请求，基于模块化编程的思想，我们把这部分功能抽出一个单独的模块，在 <code>core</code> 目录下创建 <code>dispatchRequest</code> 方法，把之前 <code>axios.ts</code> 的相关代码拷贝过去。另外我们把 <code>xhr.ts</code> 文件也迁移到 <code>core</code> 目录下。</p>
<p><code>core/dispatchRequest.ts</code>：</p>
<pre><code class="language-typescript">import {AxiosPromise, AxiosRequestConfig, AxiosResponse} from '../types'
import xhr from './xhr'
import {buildURL} from '../helpers/url'
import {transformRequest, transformResponse} from '../helpers/data'
import {processHeaders} from '../helpers/headers'

export default function dispatchRequest(config: AxiosRequestConfig): AxiosPromise {processConfig(config)
  return xhr(config).then(res =&gt; {return transformResponseData(res)
  })
}

function processConfig(config: AxiosRequestConfig): void {config.url = transformURL(config)
  config.headers = transformHeaders(config)
  config.data = transformRequestData(config)
}

function transformURL(config: AxiosRequestConfig): string {const { url, params} = config
  return buildURL(url, params)
}

function transformRequestData(config: AxiosRequestConfig): any {return transformRequest(config.data)
}

function transformHeaders(config: AxiosRequestConfig) {const { headers = {}, data } = config
  return processHeaders(headers, data)
}

function transformResponseData(res: AxiosResponse): AxiosResponse {res.data = transformResponse(res.data)
  return res
}
</code></pre>
<p>回到 <code>Axios.ts</code> 文件，对于 <code>get</code>、<code>delete</code>、<code>head</code>、<code>options</code>、<code>post</code>、<code>patch</code>、<code>put</code> 这些方法，都是对外提供的语法糖，内部都是通过调用 <code>request</code> 方法实现发送请求，只不过在调用之前对 <code>config</code> 做了一层合并处理。</p>
<h3><a id="%E6%B7%B7%E5%90%88%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>混合对象实现</h3>
<p>混合对象实现思路很简单，首先这个对象是一个函数，其次这个对象要包括 <code>Axios</code> 类的所有原型属性和实例属性，我们首先来实现一个辅助函数 <code>extend</code>。</p>
<p><code>helpers/util.ts</code></p>
<pre><code class="language-typescript">export function extend&lt;T, U&gt;(to: T, from: U): T &amp; U {for (const key in from) {;(to as T &amp; U)[key] = from[key] as any
  }
  return to as T &amp; U
}
</code></pre>
<p><code>extend</code> 方法的实现用到了交叉类型，并且用到了类型断言。<code>extend</code> 的最终目的是把 <code>from</code> 里的属性都扩展到 <code>to</code> 中，包括原型上的属性。</p>
<p>我们接下来对 <code>axios.ts</code> 文件做修改，我们用工厂模式去创建一个 <code>axios</code> 混合对象。</p>
<p><code>axios.ts</code>：</p>
<pre><code class="language-typescript">import {AxiosInstance} from './types'
import Axios from './core/Axios'
import {extend} from './helpers/util'

function createInstance(): AxiosInstance {const context = new Axios()
  const instance = Axios.prototype.request.bind(context)

  extend(instance, context)

  return instance as AxiosInstance
}

const axios = createInstance()

export default axios
</code></pre>
<p>在 <code>createInstance</code> 工厂函数的内部，我们首先实例化了 <code>Axios</code> 实例 <code>context</code>，接着创建 <code>instance</code> 指向 <code>Axios.prototype.request</code> 方法，并绑定了上下文 <code>context</code>；接着通过 <code>extend</code> 方法把 <code>context</code> 中的原型方法和实例方法全部拷贝到 <code>instance</code> 上，这样就实现了一个混合对象：<code>instance</code> 本身是一个函数，又拥有了 <code>Axios</code> 类的所有原型和实例属性，最终把这个 <code>instance</code> 返回。由于这里 <code>TypeScript</code> 不能正确推断 <code>instance</code> 的类型，我们把它断言成 <code>AxiosInstance</code> 类型。</p>
<p>这样我们就可以通过 <code>createInstance</code> 工厂函数创建了 <code>axios</code>，当直接调用 <code>axios</code> 方法就相当于执行了 <code>Axios</code> 类的 <code>request</code> 方法发送请求，当然我们也可以调用 <code>axios.get</code>、<code>axios.post</code> 等方法。</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<p>在 <code>examples</code> 目录下创建 <code>extend</code> 目录，在 <code>extend</code> 目录下创建 <code>index.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Extend example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;/__build__/extend.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>接着创建 <code>app.ts</code> 作为入口文件：</p>
<pre><code class="language-typescript">import axios from '../../src/index'

axios({
  url: '/extend/post',
  method: 'post',
  data: {msg: 'hi'}
})

axios.request({
  url: '/extend/post',
  method: 'post',
  data: {msg: 'hello'}
})axios.get('/extend/get')

axios.options('/extend/options')

axios.delete('/extend/delete')

axios.head('/extend/head')

axios.post('/extend/post', { msg: 'post'})

axios.put('/extend/put', { msg: 'put'})

axios.patch('/extend/patch', { msg: 'patch'})
</code></pre>
<p>然后在命令行运行 <code>npm run dev</code>，接着打开 chrome 浏览器，访问 <code>http://localhost:8080/</code> 即可访问我们的 demo 了，我们点到 <code>Extend</code> 目录下，通过开发者工具的 network 部分我们可以看到每个请求的发送情况。</p>
<p>至此我们支持了对 <code>axios</code> API 的扩展，把它变成了一个混合对象。官方的 <code>axios</code> 实例除了支持了 <code>axios(config)</code>，还支持了传入 2 个参数 <code>axios(url, config)</code>，这里就涉及到函数重载的概念了，下一节我们来实现这个 feature。</p>
<h2><a id="axios%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>axios 函数重载</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>目前我们的 axios 函数只支持传入 1 个参数，如下：</p>
<pre><code class="language-typescript">axios({
  url: '/extend/post',
  method: 'post',
  data: {msg: 'hi'}
})
</code></pre>
<p>我们希望该函数也能支持传入 2 个参数，如下：</p>
<pre><code class="language-typescript">axios('/extend/post', {
  method: 'post',
  data: {msg: 'hello'}
})
</code></pre>
<p>第一个参数是 <code>url</code>，第二个参数是 <code>config</code>，这个函数有点类似 <code>axios.get</code> 方法支持的参数类型，不同的是如果我们想要指定 HTTP 方法类型，仍然需要在 <code>config</code> 传入 <code>method</code>。</p>
<p>这就用到我们之前所学的函数重载知识点了，接下来我们来实现它。</p>
<h3><a id="%E9%87%8D%E8%BD%BD%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重载实现</h3>
<p>首先我们要修改 <code>AxiosInstance</code> 的类型定义。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosInstance extends Axios {(config: AxiosRequestConfig): AxiosPromise

  (url: string, config?: AxiosRequestConfig): AxiosPromise
}
</code></pre>
<p>我们增加一种函数的定义，它支持 2 个参数，其中 <code>url</code> 是必选参数，<code>config</code> 是可选参数。</p>
<p>由于 <code>axios</code> 函数实际上指向的是 <code>request</code> 函数，所以我们来修改 <code>request</code> 函数的实现。</p>
<p><code>core/Axios.ts</code>：</p>
<pre><code class="language-typescript">  request(url: any, config?: any): AxiosPromise {if (typeof url === 'string') {if (!config) {config = {}
      }
      config.url = url
    } else {config = url}
    return dispatchRequest(config)
  }
</code></pre>
<p>我们把 <code>request</code> 函数的参数改成 2 个，<code>url</code> 和 <code>config</code> 都是 <code>any</code> 类型，<code>config</code> 还是可选参数。</p>
<p>接着在函数体我们判断 <code>url</code> 是否为字符串类型，一旦它为字符串类型，则继续对 <code>config</code> 判断，因为它可能不传，如果为空则构造一个空对象，然后把 <code>url</code> 添加到 <code>config.url</code> 中。如果 <code>url</code> 不是字符串类型，则说明我们传入的就是单个参数，且 <code>url</code> 就是 <code>config</code>，因此把 <code>url</code> 赋值给 <code>config</code>。</p>
<p>这里要注意的是，我们虽然修改了 <code>request</code> 的实现，支持了 2 种参数，但是我们对外提供的 <code>request</code> 接口仍然不变，可以理解为这仅仅是内部的实现的修改，与对外接口不必一致，只要保留实现兼容接口即可。</p>
<h3><a id="%E7%BC%96%E5%86%99demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编写 demo</h3>
<p><code>examples/extend/app.ts</code>：</p>
<pre><code class="language-typescript">axios({
  url: '/extend/post',
  method: 'post',
  data: {msg: 'hi'}
})

axios('/extend/post', {
  method: 'post',
  data: {msg: 'hello'}
})
</code></pre>
<p>我们使用了 <code>axios</code> 2 种请求方式，打开页面运行 <code>demo</code>，通过 network 我们可以看到 2 种请求都是运行正常的。</p>
<p>至此我们实现了 <code>axios</code> 函数的重载。官方 axios 支持了一种能力，我们可以去定义返回数据的类型，并在请求的时候指定该类型，然后在响应数据中我们就可以获取到该数据类型。下一节课我们就来实现这个 feature。</p>
<h2><a id="%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>响应数据支持泛型</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>通常情况下，我们会把后端返回数据格式单独放入一个接口中：</p>
<pre><code class="language-typescript">// 请求接口数据
export interface ResponseData&lt;T = any&gt; {
  /**
   * 状态码
   * @type {number}
   */
  code: number

  /**
   * 数据
   * @type {T}
   */
  result: T

  /**
   * 消息
   * @type {string}
   */
  message: string
}
</code></pre>
<p>我们可以把 API 抽离成单独的模块：</p>
<pre><code class="language-typescript">import {ResponseData} from './interface.ts';

export function getUser&lt;T&gt;() {return axios.get&lt;ResponseData&lt;T&gt;&gt;('/somepath')
    .then(res =&gt; res.data)
    .catch(err =&gt; console.error(err))
}
</code></pre>
<p>接着我们写入返回的数据类型 <code>User</code>，这可以让 TypeScript 顺利推断出我们想要的类型：</p>
<pre><code class="language-typescript">interface User {
  name: string
  age: number
}

async function test() {
  // user 被推断出为
  // {
  //  code: number,
  //  result: {name: string, age: number},
  //  message: string
  // }
  const user = await getUser&lt;User&gt;()}
</code></pre>
<h3><a id="%E6%8E%A5%E5%8F%A3%E6%B7%BB%E5%8A%A0%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口添加泛型参数</h3>
<p>根据需求分析，我们需要给相关的接口定义添加泛型参数。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosResponse&lt;T = any&gt; {
  data: T
  status: number
  statusText: string
  headers: any
  config: AxiosRequestConfig
  request: any
}

export interface AxiosPromise&lt;T = any&gt; extends Promise&lt;AxiosResponse&lt;T&gt;&gt; {
}

export interface Axios {request&lt;T = any&gt;(config: AxiosRequestConfig): AxiosPromise&lt;T&gt;

  get&lt;T = any&gt;(url: string, config?: AxiosRequestConfig): AxiosPromise&lt;T&gt;

  delete&lt;T = any&gt;(url: string, config?: AxiosRequestConfig): AxiosPromise&lt;T&gt;

  head&lt;T = any&gt;(url: string, config?: AxiosRequestConfig): AxiosPromise&lt;T&gt;

  options&lt;T = any&gt;(url: string, config?: AxiosRequestConfig): AxiosPromise&lt;T&gt;

  post&lt;T = any&gt;(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise&lt;T&gt;

  put&lt;T = any&gt;(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise&lt;T&gt;

  patch&lt;T = any&gt;(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise&lt;T&gt;
}

export interface AxiosInstance extends Axios {&lt;T = any&gt;(config: AxiosRequestConfig): AxiosPromise&lt;T&gt;

  &lt;T = any&gt;(url: string, config?: AxiosRequestConfig): AxiosPromise&lt;T&gt;
}
</code></pre>
<p>这里我们先给 <code>AxiosResponse</code> 接口添加了泛型参数 <code>T</code>，<code>T=any</code> 表示泛型的类型参数默认值为 <code>any</code>。</p>
<p>接着我们为 <code>AxiosPromise</code>、<code>Axios</code> 以及 <code>AxiosInstance</code> 接口都加上了泛型参数。我们可以看到这些请求的返回类型都变成了 <code>AxiosPromise&lt;T&gt;</code>，也就是 <code>Promise&lt;AxiosResponse&lt;T&gt;&gt;</code>，这样我们就可以从响应中拿到了类型 <code>T</code> 了。</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<p><code>examples/extend/app.ts</code>：</p>
<pre><code class="language-typescript">interface ResponseData&lt;T = any&gt; {
  code: number
  result: T
  message: string
}

interface User {
  name: string
  age: number
}

function getUser&lt;T&gt;() {return axios&lt;ResponseData&lt;T&gt;&gt;('/extend/user')
    .then(res =&gt; res.data)
    .catch(err =&gt; console.error(err))
}


async function test() {const user = await getUser&lt;User&gt;()
  if (user) {console.log(user.result.name)
  }
}

test()
</code></pre>
<p>当我们调用 <code>getUser&lt;User&gt;</code> 的时候，相当于调用了 <code>axios&lt;ResponseData&lt;User&gt;&gt;</code>，也就是我们传入给 <code>axios</code> 函数的类型 <code>T</code> 为 <code>ResponseData&lt;User&gt;</code>；相当于返回值 <code>AxiosPromise&lt;T&gt;</code> 的 <code>T</code>，实际上也是 <code>Promise&lt;AxiosResponse&lt;T&gt;&gt;</code> 中的 <code>T</code> 的类型是 <code>ResponseData&lt;User&gt;</code>，所以响应数据中的 <code>data</code> 类型就是 <code>ResponseData&lt;User&gt;</code>，也就是如下数据结构：</p>
<pre><code class="language-json">{
  code: number
  result: User
  message: string
}
</code></pre>
<p>这个也是 <code>const user = await getUser&lt;User&gt;()</code> 返回值 <code>user</code> 的数据类型，所以 TypeScript 能正确推断出 <code>user</code> 的类型。</p>
<p>至此，我们的 <code>ts-axios</code> 接口扩展章节就告一段落了，下一章我们来实现 <code>axios</code> 的一个非常好用的功能 —— 拦截器。</p>
<h1><a id="%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拦截器实现</h1>
<h2><a id="%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拦截器设计与实现</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>我们希望能对请求的发送和响应做拦截，也就是在发送请求之前和接收到响应之后做一些额外逻辑。</p>
<p>我们希望设计的拦截器的使用方式如下：</p>
<pre><code class="language-typescript">// 添加一个请求拦截器
axios.interceptors.request.use(function (config) {
  // 在发送请求之前可以做一些事情
  return config;
}, function (error) {
  // 处理请求错误
  return Promise.reject(error);
});
// 添加一个响应拦截器
axios.interceptors.response.use(function (response) {
  // 处理响应数据
  return response;
}, function (error) {
  // 处理响应错误
  return Promise.reject(error);
});
</code></pre>
<p>在 <code>axios</code> 对象上有一个 <code>interceptors</code> 对象属性，该属性又有 <code>request</code> 和 <code>response</code> 2 个属性，它们都有一个 <code>use</code> 方法，<code>use</code> 方法支持 2 个参数，第一个参数类似 Promise 的 <code>resolve</code> 函数，第二个参数类似 Promise 的 <code>reject</code> 函数。我们可以在 <code>resolve</code> 函数和 <code>reject</code> 函数中执行同步代码或者是异步代码逻辑。</p>
<p>并且我们是可以添加多个拦截器的，拦截器的执行顺序是链式依次执行的方式。对于 <code>request</code> 拦截器，后添加的拦截器会在请求前的过程中先执行；对于 <code>response</code> 拦截器，先添加的拦截器会在响应后先执行。</p>
<pre><code class="language-typescript">axios.interceptors.request.use(config =&gt; {
  config.headers.test += '1'
  return config
})
axios.interceptors.request.use(config =&gt; {
  config.headers.test += '2'
  return config
})
</code></pre>
<p>此外，我们也可以支持删除某个拦截器，如下：</p>
<pre><code class="language-typescript">const myInterceptor = axios.interceptors.request.use(function () {/*...*/})
axios.interceptors.request.eject(myInterceptor)
</code></pre>
<h3><a id="%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>整体设计</h3>
<p>我们先用一张图来展示一下拦截器工作流程：</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205141517307.png" alt="image-20220514151720909" /></p>
<p>整个过程是一个链式调用的方式，并且每个拦截器都可以支持同步和异步处理，我们自然而然地就联想到使用 Promise 链的方式来实现整个调用过程。</p>
<p>在这个 Promise 链的执行过程中，请求拦截器 <code>resolve</code> 函数处理的是 <code>config</code> 对象，而相应拦截器 <code>resolve</code> 函数处理的是 <code>response</code> 对象。</p>
<p>在了解了拦截器工作流程后，我们先要创建一个拦截器管理类，允许我们去添加<br />
删除和遍历拦截器。</p>
<h3><a id="%E6%8B%A6%E6%88%AA%E5%99%A8%E7%AE%A1%E7%90%86%E7%B1%BB%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拦截器管理类实现</h3>
<p>根据需求，<code>axios</code> 拥有一个 <code>interceptors</code> 对象属性，该属性又有 <code>request</code> 和 <code>response</code> 2 个属性，它们对外提供一个 <code>use</code> 方法来添加拦截器，我们可以把这俩属性看做是一个拦截器管理对象。<code>use</code> 方法支持 2 个参数，第一个是 <code>resolve</code> 函数，第二个是 <code>reject</code> 函数，对于 <code>resolve</code> 函数的参数，请求拦截器是 <code>AxiosRequestConfig</code> 类型的，而响应拦截器是 <code>AxiosResponse</code> 类型的；而对于 <code>reject</code> 函数的参数类型则是 <code>any</code> 类型的。</p>
<p>根据上述分析，我们先来定义一下拦截器管理对象对外的接口。</p>
<h4><a id="%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口定义</h4>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosInterceptorManager&lt;T&gt; {use(resolved: ResolvedFn&lt;T&gt;, rejected?: RejectedFn): number

  eject(id: number): void
}

export interface ResolvedFn&lt;T=any&gt; {(val: T): T | Promise&lt;T&gt;
}

export interface RejectedFn {(error: any): any
}
</code></pre>
<p>这里我们定义了 <code>AxiosInterceptorManager</code> 泛型接口，因为对于 <code>resolve</code> 函数的参数，请求拦截器和响应拦截器是不同的。</p>
<h4><a id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码实现</h4>
<pre><code class="language-typescript">import {ResolvedFn, RejectedFn} from '../types'

interface Interceptor&lt;T&gt; {
  resolved: ResolvedFn&lt;T&gt;
  rejected?: RejectedFn
}

export default class InterceptorManager&lt;T&gt; {
  private interceptors: Array&lt;Interceptor&lt;T&gt; | null&gt;

  constructor() {this.interceptors = []
  }

  use(resolved: ResolvedFn&lt;T&gt;, rejected?: RejectedFn): number {
    this.interceptors.push({
      resolved,
      rejected
    })return this.interceptors.length - 1}

  forEach(fn: (interceptor: Interceptor&lt;T&gt;) =&gt; void): void {
    this.interceptors.forEach(interceptor =&gt; {if (interceptor !== null) {fn(interceptor)
      }
    }) }

  eject(id: number): void {if (this.interceptors[id]) {this.interceptors[id] = null
    }
  }
}
</code></pre>
<p>我们定义了一个 <code>InterceptorManager</code> 泛型类，内部维护了一个私有属性 <code>interceptors</code>，它是一个数组，用来存储拦截器。该类还对外提供了 3 个方法，其中 <code>use</code> 接口就是添加拦截器到 <code>interceptors</code> 中，并返回一个 <code>id</code> 用于删除；<code>forEach</code> 接口就是遍历 <code>interceptors</code> 用的，它支持传入一个函数，遍历过程中会调用该函数，并把每一个 <code>interceptor</code> 作为该函数的参数传入；<code>eject</code> 就是删除一个拦截器，通过传入拦截器的 <code>id</code> 删除。</p>
<h3><a id="%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>链式调用实现</h3>
<blockquote>
<p>本小节需要你对 Promise 掌握和理解，可以前往 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">mdn</a> 学习。</p>
</blockquote>
<p>当我们实现好拦截器管理类，接下来就是在 <code>Axios</code> 中定义一个 <code>interceptors</code> 属性，它的类型如下：</p>
<pre><code class="language-typescript">interface Interceptors {
  request: InterceptorManager&lt;AxiosRequestConfig&gt;
  response: InterceptorManager&lt;AxiosResponse&gt;
}

export default class Axios {
  interceptors: Interceptors

  constructor() {
    this.interceptors = {request: new InterceptorManager&lt;AxiosRequestConfig&gt;(),
      response: new InterceptorManager&lt;AxiosResponse&gt;()}}
}
</code></pre>
<p><code>Interceptors</code> 类型拥有 2 个属性，一个请求拦截器管理类实例，一个是响应拦截器管理类实例。我们在实例化 <code>Axios</code> 类的时候，在它的构造器去初始化这个 <code>interceptors</code> 实例属性。</p>
<p>接下来，我们修改 <code>request</code> 方法的逻辑，添加拦截器链式调用的逻辑：</p>
<p><code>core/Axios.ts</code>：</p>
<pre><code class="language-typescript">interface PromiseChain {resolved: ResolvedFn | ((config: AxiosRequestConfig) =&gt; AxiosPromise)rejected?: RejectedFn}

request(url: any, config?: any): AxiosPromise {if (typeof url === 'string') {if (!config) {config = {}
    }
    config.url = url
  } else {config = url}
	
  // 将真正发请求的核心方法也变成拦截器链中的一环
  const chain: PromiseChain[] = [{
    resolved: dispatchRequest,
    rejected: undefined
  }]

  this.interceptors.request.forEach(interceptor =&gt; {chain.unshift(interceptor)
  })

  this.interceptors.response.forEach(interceptor =&gt; {chain.push(interceptor)
  })let promise = Promise.resolve(config)

  while (chain.length) {const { resolved, rejected} = chain.shift()!
    promise = promise.then(resolved, rejected)
  }

  return promise
}
</code></pre>
<p>首先，构造一个 <code>PromiseChain</code> 类型的数组 <code>chain</code>，并把 <code>dispatchRequest</code> 函数赋值给 <code>resolved</code> 属性；接着先遍历请求拦截器插入到 <code>chain</code> 的前面；然后再遍历响应拦截器插入到 <code>chain</code> 后面。</p>
<p>接下来定义一个已经 resolve 的 <code>promise</code>，循环这个 <code>chain</code>，拿到每个拦截器对象，把它们的 <code>resolved</code> 函数和 <code>rejected</code> 函数添加到 <code>promise.then</code> 的参数中，这样就相当于通过 Promise 的链式调用方式，实现了拦截器一层层的链式调用的效果。</p>
<p>注意我们拦截器的执行顺序，对于请求拦截器，先执行后添加的，再执行先添加的；而对于响应拦截器，先执行先添加的，后执行后添加的。</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<p>在 <code>examples</code> 目录下创建 <code>interceptor</code> 目录，在 <code>interceptor</code> 目录下创建 <code>index.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Interceptor example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;/__build__/interceptor.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>接着创建 <code>app.ts</code> 作为入口文件：</p>
<pre><code class="language-typescript">import axios from '../../src/index'

axios.interceptors.request.use(config =&gt; {
  config.headers.test += '1'
  return config
})
axios.interceptors.request.use(config =&gt; {
  config.headers.test += '2'
  return config
})
axios.interceptors.request.use(config =&gt; {
  config.headers.test += '3'
  return config
})

axios.interceptors.response.use(res =&gt; {
  res.data += '1'
  return res
})
let interceptor = axios.interceptors.response.use(res =&gt; {
  res.data += '2'
  return res
})
axios.interceptors.response.use(res =&gt; {
  res.data += '3'
  return res
})axios.interceptors.response.eject(interceptor)

axios({
  url: '/interceptor/get',
  method: 'get',
  headers: {test: ''}
}).then((res) =&gt; {console.log(res.data)
})
</code></pre>
<p>该 demo 我们添加了 3 个请求拦截器，添加了 3 个响应拦截器并删除了第二个。运行该 demo 我们通过浏览器访问，我们发送的请求添加了一个 <code>test</code> 的请求 header，它的值是 <code>321</code>；我们的响应数据返回的是 <code>hello</code>，经过响应拦截器的处理，最终我们输出的数据是 <code>hello13</code>。</p>
<p>至此，我们给 <code>ts-axios</code> 实现了拦截器功能，它是一个非常实用的功能，在实际工作中我们可以利用它做一些需求如登录权限认证。</p>
<p>我们目前通过 <code>axios</code> 发送请求，往往会传入一堆配置，但是我们也希望 <code>ts-axios</code> 本身也会有一些默认配置，我们把用户传入的自定义配置和默认配置做一层合并。其实，大部分的 JS 库都是类似的玩法。下面一章我们就来实现这个 feature。</p>
<h1><a id="%E9%85%8D%E7%BD%AE%E5%8C%96%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置化实现</h1>
<h2><a id="%E5%90%88%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>合并配置的设计与实现</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>在之前的章节我们了解到，在发送请求的时候可以传入一个配置，来决定请求的不同行为。我们也希望 <code>ts-axios</code> 可以有默认配置，定义一些默认的行为。这样在发送每个请求，用户传递的配置可以和默认配置做一层合并。</p>
<p>和官网 <code>axios</code> 库保持一致，我们给 <code>axios</code> 对象添加一个 <code>defaults</code> 属性，表示默认配置，你甚至可以直接修改这些默认配置：</p>
<pre><code class="language-typescript">axios.defaults.headers.common['test'] = 123
axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'
axios.defaults.timeout = 2000
</code></pre>
<p>其中对于 <code>headers</code> 的默认配置支持 <code>common</code> 和一些请求 <code>method</code> 字段，<code>common</code> 表示对于任何类型的请求都要添加该属性，而 <code>method</code> 表示只有该类型请求方法才会添加对应的属性。</p>
<p>在上述例子中，我们会默认为所有请求的 <code>header</code> 添加 <code>test</code> 属性，会默认为 <code>post</code> 请求的 <code>header</code> 添加 <code>Content-Type</code> 属性。</p>
<h3><a id="%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>默认配置</h3>
<h4><a id="%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>默认配置定义</h4>
<p>接下来，我们先实现默认配置</p>
<p><code>defaults.ts</code>：</p>
<pre><code class="language-typescript">import {AxiosRequestConfig} from './types'

const defaults: AxiosRequestConfig = {
  method: 'get',

  timeout: 0,

  headers: {
    common: {Accept: 'application/json, text/plain, */*'}
  }
}

const methodsNoData = ['delete', 'get', 'head', 'options']

methodsNoData.forEach(method =&gt; {defaults.headers[method] = {}})

const methodsWithData = ['post', 'put', 'patch']

methodsWithData.forEach(method =&gt; {defaults.headers[method] = {'Content-Type': 'application/x-www-form-urlencoded'}
})

export default defaults
</code></pre>
<p>我们定义了 <code>defaults</code> 常量，它包含默认请求的方法、超时时间，以及 <code>headers</code> 配置。</p>
<p>未来我们会根据新的需求添加更多的默认配置。</p>
<h4><a id="%E6%B7%BB%E5%8A%A0%E5%88%B0axios%E5%AF%B9%E8%B1%A1%E4%B8%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加到 axios 对象中</h4>
<p>根据需求，我们要给 <code>axios</code> 对象添加一个 <code>defaults</code> 属性，表示默认配置：</p>
<pre><code class="language-typescript">export default class Axios {
  defaults: AxiosRequestConfig
  interceptors: Interceptors

  constructor(initConfig: AxiosRequestConfig) {
    this.defaults = initConfig
    this.interceptors = {request: new InterceptorManager&lt;AxiosRequestConfig&gt;(),
      response: new InterceptorManager&lt;AxiosResponse&gt;()}}
  // ...
}  
</code></pre>
<p>我们给 <code>Axios</code> 类添加一个 <code>defaults</code> 成员属性，并且让 <code>Axios</code> 的构造函数接受一个 <code>initConfig</code> 对象，把 <code>initConfig</code> 赋值给 <code>this.defaults</code>。</p>
<p>接着修改 <code>createInstance</code> 方法，支持传入 <code>config</code> 对象。</p>
<pre><code class="language-typescript">import defaults from './defaults'

function createInstance(config: AxiosRequestConfig): AxiosStatic {const context = new Axios(config)
  const instance = Axios.prototype.request.bind(context)

  // extend(instance, Axios.prototype, context)

  extend(instance, context)

  return instance as AxiosStatic
}

const axios = createInstance(defaults)
</code></pre>
<p>这样我们就可以在执行 <code>createInstance</code> 创建 <code>axios</code> 对象的时候，把默认配置传入了。</p>
<h3><a id="%E9%85%8D%E7%BD%AE%E5%90%88%E5%B9%B6%E5%8F%8A%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置合并及策略</h3>
<p>定义了默认配置后，我们发送每个请求的时候需要把自定义配置和默认配置做合并，它并不是简单的 2 个普通对象的合并，对于不同的字段合并，会有不同的合并策略。举个例子：</p>
<pre><code class="language-typescript">config1 = {
  method: 'get',

  timeout: 0,

  headers: {
    common: {Accept: 'application/json, text/plain, */*'}
  }
}

config2 = {
  url: '/config/post',
  method: 'post',
  data: {a: 1},
  headers: {test: '321'}
}

merged = {
  url: '/config/post',
  method: 'post',
  data: {a: 1},
  timeout: 0,
  headers: {
    common: {Accept: 'application/json, text/plain, */*'}
    test: '321'
  }
}
</code></pre>
<p>我们在 <code>core/mergeConfig.ts</code> 中实现合并方法。</p>
<h4><a id="%E5%90%88%E5%B9%B6%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>合并方法</h4>
<pre><code class="language-typescript">export default function mergeConfig(
  config1: AxiosRequestConfig,
  config2?: AxiosRequestConfig
): AxiosRequestConfig {if (!config2) {config2 = {}
  }

  const config = Object.create(null)

  for (let key in config2) {mergeField(key)
  }

  for (let key in config1) {if (!config2[key]) {mergeField(key)
    }
  }

  function mergeField(key: string): void {const strat = strats[key] || defaultStrat
    config[key] = strat(config1[key], config2![key])
  }

  return config
}
</code></pre>
<p>合并方法的整体思路就是对 <code>config1</code> 和 <code>config2</code> 中的属性遍历，执行 <code>mergeField</code> 方法做合并，这里 <code>config1</code> 代表默认配置，<code>config2</code> 代表自定义配置。</p>
<p>遍历过程中，我们会通过 <code>config2[key]</code> 这种索引的方式访问，所以需要给 <code>AxiosRequestConfig</code> 的接口定义添加一个字符串索引签名：</p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  // ...

  [propName: string]: any
}
</code></pre>
<p>在 <code>mergeField</code> 方法中，我们会针对不同的属性使用不同的合并策略。</p>
<h4><a id="%E9%BB%98%E8%AE%A4%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>默认合并策略</h4>
<p>这是大部分属性的合并策略，如下：</p>
<pre><code class="language-typescript">function defaultStrat(val1: any, val2: any): any {return typeof val2 !== 'undefined' ? val2 : val1}
</code></pre>
<p>它很简单，如果有 <code>val2</code> 则返回 <code>val2</code>，否则返回 <code>val1</code>，也就是如果自定义配置中定义了某个属性，就采用自定义的，否则就用默认配置。</p>
<h4><a id="%E5%8F%AA%E6%8E%A5%E5%8F%97%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>只接受自定义配置合并策略</h4>
<p>对于一些属性如 <code>url</code>、<code>params</code>、<code>data</code>，合并策略如下：</p>
<pre><code class="language-typescript">function fromVal2Strat(val1: any, val2: any): any {if (typeof val2 !== 'undefined') {return val2}
}

const stratKeysFromVal2 = ['url', 'params', 'data']

stratKeysFromVal2.forEach(key =&gt; {strats[key] = fromVal2Strat
})
</code></pre>
<p>因为对于 <code>url</code>、<code>params</code>、<code>data</code> 这些属性，默认配置显然是没有意义的，它们是和每个请求强相关的，所以我们只从自定义配置中获取。</p>
<h4><a id="%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A1%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复杂对象合并策略</h4>
<p>对于一些属性如 <code>headers</code>，合并策略如下：</p>
<pre><code class="language-typescript">function deepMergeStrat(val1: any, val2: any): any {if (isPlainObject(val2)) {return deepMerge(val1, val2)
  } else if (typeof val2 !== 'undefined') {return val2} else if (isPlainObject(val1)) {return deepMerge(val1)
  } else if (typeof val1 !== 'undefined') {return val1}
}

const stratKeysDeepMerge = ['headers']

stratKeysDeepMerge.forEach(key =&gt; {strats[key] = deepMergeStrat
})
</code></pre>
<p><code>helpers/util.ts</code>：</p>
<pre><code class="language-typescript">export function deepMerge(...objs: any[]): any {const result = Object.create(null)

  objs.forEach(obj =&gt; {if (obj) {Object.keys(obj).forEach(key =&gt; {const val = obj[key]
        if (isPlainObject(val)) {if (isPlainObject(result[key])) {result[key] = deepMerge(result[key], val) } else {result[key] = deepMerge({}, val)
          }
        } else {result[key] = val
        }
      })}})

  return result
}
</code></pre>
<p>对于 <code>headers</code> 这类的复杂对象属性，我们需要使用深拷贝的方式，同时也处理了其它一些情况，因为它们也可能是一个非对象的普通值。未来我们讲到认证授权的时候，<code>auth</code> 属性也是这个合并策略。</p>
<p>最后我们在 <code>request</code> 方法里添加合并配置的逻辑：</p>
<pre><code class="language-typescript">config = mergeConfig(this.defaults, config)
</code></pre>
<h3><a id="flatten-headers" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>flatten headers</h3>
<p>经过合并后的配置中的 <code>headers</code> 是一个复杂对象，多了 <code>common</code>、<code>post</code>、<code>get</code> 等属性，而这些属性中的值才是我们要真正添加到请求 <code>header</code> 中的。</p>
<p>举个例子：</p>
<pre><code class="language-typescript">headers: {
  common: {Accept: 'application/json, text/plain, */*'},
  post: {'Content-Type':'application/x-www-form-urlencoded'}
}
</code></pre>
<p>我们需要把它压成一级的，如下：</p>
<pre><code class="language-typescript">headers: {
  Accept: 'application/json, text/plain, */*',
 'Content-Type':'application/x-www-form-urlencoded'
}
</code></pre>
<p>这里要注意的是，对于 <code>common</code> 中定义的 <code>header</code> 字段，我们都要提取，而对于 <code>post</code>、<code>get</code> 这类提取，需要和该次请求的方法对应。</p>
<p>接下来我们实现 <code>flattenHeaders</code> 方法。</p>
<p><code>helpers/header.ts</code>：</p>
<pre><code class="language-typescript">export function flattenHeaders(headers: any, method: Method): any {if (!headers) {return headers}
  headers = deepMerge(headers.common || {}, headers[method] || {}, headers)

  const methodsToDelete = ['delete', 'get', 'head', 'options', 'post', 'put', 'patch', 'common']

  methodsToDelete.forEach(method =&gt; {delete headers[method]
  })return headers}
</code></pre>
<p>我们可以通过 <code>deepMerge</code> 的方式把 <code>common</code>、<code>post</code> 的属性拷贝到 <code>headers</code> 这一级，然后再把 <code>common</code>、<code>post</code> 这些属性删掉。</p>
<p>然后我们在真正发送请求前执行这个逻辑。</p>
<p><code>core/dispatchRequest.ts</code>：</p>
<pre><code class="language-typescript">function processConfig(config: AxiosRequestConfig): void {config.url = transformURL(config)
  config.headers = transformHeaders(config)
  config.data = transformRequestData(config)
  config.headers = flattenHeaders(config.headers, config.method!)
}
</code></pre>
<p>这样确保我们了配置中的 <code>headers</code> 是可以正确添加到请求 <code>header</code> 中的</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<p>在 <code>examples</code> 目录下创建 <code>config</code> 目录，在 <code>config</code> 目录下创建 <code>index.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Config example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;/__build__/config.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>接着创建 <code>app.ts</code> 作为入口文件：</p>
<pre><code class="language-typescript">import axios from '../../src/index'
import qs from 'qs'

axios.defaults.headers.common['test2'] = 123

axios({
  url: '/config/post',
  method: 'post',
  data: qs.stringify({a: 1}),
  headers: {test: '321'}
}).then((res) =&gt; {console.log(res.data)
})
</code></pre>
<p>这个例子中我们额外引入了 <code>qs</code> 库，它是一个查询字符串解析和字符串化的库。</p>
<p>比如我们的例子中对于 <code>{a:1}</code> 经过 <code>qs.stringify</code> 变成 <code>a=1</code>。</p>
<p>由于我们的例子给默认值添加了 <code>post</code> 和 <code>common</code> 的 <code>headers</code>，我们在请求前做配置合并，于是我们请求的 <code>header</code> 就添加了 <code>Content-Type</code> 字段，它的值是 <code>application/x-www-form-urlencoded</code>；另外我们也添加了 <code>test2</code> 字段，它的值是 <code>123</code>。</p>
<p>至此，我们合并配置的逻辑就实现完了。我们在前面的章节编写 <code>axios</code> 的基础功能的时候对请求数据和响应数据都做了处理，官方 <code>axios</code> 则把这俩部分逻辑也做到了默认配置中，意味这用户可以去修改这俩部分的逻辑，实现自己对请求和响应数据处理的逻辑。那么下一节我们就来实现这个 feature。</p>
<h2><a id="%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E9%85%8D%E7%BD%AE%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>请求和响应配置化</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>官方的 axios 库给默认配置添加了 <code>transformRequest</code> 和 <code>transformResponse</code> 两个字段，它们的值是一个数组或者是一个函数。</p>
<p>其中 <code>transformRequest</code> 允许你在将请求数据发送到服务器之前对其进行修改，这只适用于请求方法 <code>put</code>、<code>post</code> 和 <code>patch</code>，如果值是数组，则数组中的最后一个函数必须返回一个字符串或 <code>FormData</code>、<code>URLSearchParams</code>、<code>Blob</code> 等类型作为 <code>xhr.send</code> 方法的参数，而且在 <code>transform</code> 过程中可以修改  <code>headers</code> 对象。</p>
<p>而 <code>transformResponse</code> 允许你在把响应数据传递给 <code>then</code> 或者 <code>catch</code> 之前对它们进行修改。</p>
<p>当值为数组的时候，数组的每一个函数都是一个转换函数，数组中的函数就像管道一样依次执行，前者的输出作为后者的输入。</p>
<p>举个例子：</p>
<pre><code class="language-typescript">axios({transformRequest: [(function(data) {return qs.stringify(data)
  }), ...axios.defaults.transformRequest],
  transformResponse: [axios.defaults.transformResponse, function(data) {if (typeof data === 'object') {data.b = 2}
    return data
  }],
  url: '/config/post',
  method: 'post',
  data: {a: 1}
})
</code></pre>
<h3><a id="%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>修改默认配置</h3>
<p>先修改 <code>AxiosRequestConfig</code> 的类型定义，添加 <code>transformRequest</code> 和 <code>transformResponse</code> 俩个可选属性。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  // ...
  transformRequest?: AxiosTransformer | AxiosTransformer[]
  transformResponse?: AxiosTransformer | AxiosTransformer[]}

export interface AxiosTransformer {(data: any, headers?: any): any
}
</code></pre>
<p>接着修改默认配置，如下：</p>
<p><code>defaults.ts</code>：</p>
<pre><code class="language-typescript">import {processHeaders} from './helpers/headers'
import {transformRequest, transformResponse} from './helpers/data'

const defaults: AxiosRequestConfig = {
  // ...
  transformRequest: [function(data: any, headers: any): any {processHeaders(headers, data)
      return transformRequest(data)
    }
  ],

  transformResponse: [function(data: any): any {return transformResponse(data)
    }
  ]
}
</code></pre>
<p>我们把之前对请求数据和响应数据的处理逻辑，放到了默认配置中，也就是默认处理逻辑。</p>
<h3><a id="transform%E9%80%BB%E8%BE%91%E9%87%8D%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>transform 逻辑重构</h3>
<p>接下来，我们就要重构之前写的对请求数据和响应数据的处理逻辑了。由于我们可能会编写多个转换函数，我们先定义一个 <code>transform</code> 函数来处理这些转换函数的调用逻辑。</p>
<p><code>core/transform.ts</code></p>
<pre><code class="language-typescript">import {AxiosTransformer} from '../types'

export default function transform(
  data: any,
  headers: any,
  fns?: AxiosTransformer | AxiosTransformer[]): any {if (!fns) {return data}
  if (!Array.isArray(fns)) {fns = [fns]
  }
  fns.forEach(fn =&gt; {data = fn(data, headers)
  })return data}
</code></pre>
<p><code>transform</code> 函数中接收 <code>data</code>、<code>headers</code>、<code>fns</code> 3 个参数，其中 <code>fns</code> 代表一个或者多个转换函数，内部逻辑很简单，遍历 <code>fns</code>，执行这些转换函数，并且把 <code>data</code> 和 <code>headers</code> 作为参数传入，每个转换函数返回的 <code>data</code> 会作为下一个转换函数的参数 <code>data</code> 传入。</p>
<p>接下来修改对请求数据和响应数据的处理逻辑。</p>
<p><code>dispatchRequest.ts</code>：</p>
<pre><code class="language-typescript">import transform from './transform'

function processConfig(config: AxiosRequestConfig): void {config.url = transformURL(config)
  config.data = transform(config.data, config.headers, config.transformRequest)
  config.headers = flattenHeaders(config.headers, config.method!)
}

function transformResponseData(res: AxiosResponse): AxiosResponse {res.data = transform(res.data, res.headers, res.config.transformResponse)
  return res
}
</code></pre>
<p>我们把对请求数据的处理和对响应数据的处理改成使用 <code>transform</code> 函数实现，并把配置中的 <code>transformRequest</code> 及 <code>transformResponse</code> 分别传入。</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<pre><code class="language-typescript">axios({transformRequest: [(function(data) {return qs.stringify(data)
  }), ...(axios.defaults.transformRequest as AxiosTransformer[])],
  transformResponse: [...(axios.defaults.transformResponse as AxiosTransformer[]), function(data) {if (typeof data === 'object') {data.b = 2}
    return data
  }],
  url: '/config/post',
  method: 'post',
  data: {a: 1}
}).then((res) =&gt; {console.log(res.data)
})
</code></pre>
<p>我们对 <code>transformRequest</code> 做了修改，在执行它默认的 <code>transformRequest</code> 之前，我们先用 <code>qs.stringify</code> 库对传入的数据 <code>data</code> 做了一层转换。同时也对 <code>transformResponse</code> 做了修改，在执行完默认的 <code>transformResponse</code> 后，会给响应的 <code>data</code> 对象添加一个 <code>data.b = 2</code>。</p>
<p>因为之前我们实现了配置的合并，而且我们传入的 <code>transformRequest</code> 和 <code>transformResponse</code> 遵循默认合并策略，它们会覆盖默认的值。</p>
<p>至此，我们就实现了请求和响应的配置化。到目前为止，我们的 axios 都是一个单例，一旦我们修改了 axios 的默认配置，会影响所有的请求。官网提供了一个 <code>axios.create</code> 的工厂方法允许我们创建一个新的 <code>axios</code> 实例，同时允许我们传入新的配置和默认配置合并，并做为新的默认配置。下面一节课我们就来实现这个 feature。</p>
<h2><a id="%E6%89%A9%E5%B1%95axios-create%E9%9D%99%E6%80%81%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展 axios.create 静态接口</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>目前为止，我们的 axios 都是一个单例，一旦我们修改了 axios 的默认配置，会影响所有的请求。我们希望提供了一个 <code>axios.create</code> 的静态接口允许我们创建一个新的 <code>axios</code> 实例，同时允许我们传入新的配置和默认配置合并，并做为新的默认配置。</p>
<p>举个例子：</p>
<pre><code class="language-typescript">const instance = axios.create({transformRequest: [(function(data) {return qs.stringify(data)
  }), ...(axios.defaults.transformRequest as AxiosTransformer[])],
  transformResponse: [...(axios.defaults.transformResponse as AxiosTransformer[]), function(data) {if (typeof data === 'object') {data.b = 2}
    return data
  }]
})

instance({
  url: '/config/post',
  method: 'post',
  data: {a: 1}
})
</code></pre>
<h3><a id="%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态方法扩展</h3>
<p>由于 <code>axios</code> 扩展了一个静态接口，因此我们先来修改接口类型定义。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosStatic extends AxiosInstance{create(config?: AxiosRequestConfig): AxiosInstance
}
</code></pre>
<p><code>create</code> 函数可以接受一个 <code>AxiosRequestConfig</code> 类型的配置，作为默认配置的扩展，也可以接受不传参数。</p>
<p>接着我们来实现 <code>axios.create</code> 静态方法。</p>
<p><code>axios.ts</code>：</p>
<pre><code class="language-typescript">function createInstance(config: AxiosRequestConfig): AxiosStatic {const context = new Axios(config)
  const instance = Axios.prototype.request.bind(context)

  extend(instance, context)

  return instance as AxiosStatic
}
axios.create = function create(config) {return createInstance(mergeConfig(defaults, config))
}
</code></pre>
<p>内部调用了 <code>createInstance</code> 函数，并且把参数 <code>config</code> 与 <code>defaults</code> 合并，作为新的默认配置。注意这里我们需要 <code>createInstance</code> 函数的返回值类型为 <code>AxiosStatic</code>。</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<pre><code class="language-typescript">const instance = axios.create({transformRequest: [(function(data) {return qs.stringify(data)
  }), ...(axios.defaults.transformRequest as AxiosTransformer[])],
  transformResponse: [...(axios.defaults.transformResponse as AxiosTransformer[]), function(data) {if (typeof data === 'object') {data.b = 2}
    return data
  }]
})

instance({
  url: '/config/post',
  method: 'post',
  data: {a: 1}
}).then((res) =&gt; {console.log(res.data)
})
</code></pre>
<p>我们对上节课的示例做了小小的修改，通过 <code>axios.create</code> 方法创建一个新的实例 <code>instance</code>，并传入了 <code>transformRequest</code> 和 <code>transformResponse</code> 的配置修改了默认配置，然后通过 <code>instance</code> 发送请求，效果和之前是一样的。</p>
<p>至此我们实现了 <code>axios.create</code> 静态接口的扩展，整个 <code>ts-axios</code> 的配置化也告一段落。官方 axios 库还支持了对请求取消的能力，在发送请求前以及请求发送出去未响应前都可以取消该请求。下一章我们就来实现这个 feature。</p>
<h2><a id="%E5%8F%96%E6%B6%88%E5%8A%9F%E8%83%BD%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>取消功能的设计与实现</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>有些场景下，我们希望能主动取消请求，比如常见的搜索框案例，在用户输入过程中，搜索框的内容也在不断变化，正常情况每次变化我们都应该向服务端发送一次请求。但是当用户输入过快的时候，我们不希望每次变化请求都发出去，通常一个解决方案是前端用 debounce 的方案，比如延时 200ms 发送请求。这样当用户连续输入的字符，只要输入间隔小于 200ms，前面输入的字符都不会发请求。</p>
<p>但是还有一种极端情况是后端接口很慢，比如超过 1s 才能响应，这个时候即使做了 200ms 的 debounce，但是在我慢慢输入（每个输入间隔超过 200ms）的情况下，在前面的请求没有响应前，也有可能发出去多个请求。因为接口的响应时长是不定的，如果先发出去的请求响应时长比后发出去的请求要久一些，后请求的响应先回来，先请求的响应后回来，就会出现前面请求响应结果覆盖后面请求响应结果的情况，那么就乱了。因此在这个场景下，我们除了做 debounce，还希望后面的请求发出去的时候，如果前面的请求还没有响应，我们可以把前面的请求取消。</p>
<p>从 axios 的取消接口设计层面，我们希望做如下的设计：</p>
<pre><code class="language-typescript">const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios.get('/user/12345', {cancelToken: source.token}).catch(function (e) {if (axios.isCancel(e)) {console.log('Request canceled', e.message);
  } else {// 处理错误}
});

// 取消请求 (请求原因是可选的)
source.cancel('Operation canceled by the user.');
</code></pre>
<p>我们给 <code>axios</code> 添加一个 <code>CancelToken</code> 的对象，它有一个 <code>source</code> 方法可以返回一个 <code>source</code> 对象，<code>source.token</code> 是在每次请求的时候传给配置对象中的 <code>cancelToken</code> 属性，然后在请求发出去之后，我们可以通过 <code>source.cancel</code> 方法取消请求。</p>
<p>我们还支持另一种方式的调用：</p>
<pre><code class="language-typescript">const CancelToken = axios.CancelToken;
let cancel;

axios.get('/user/12345', {cancelToken: new CancelToken(function executor(c) {cancel = c;})
});

// 取消请求
cancel();
</code></pre>
<p><code>axios.CancelToken</code> 是一个类，我们直接把它实例化的对象传给请求配置中的 <code>cancelToken</code> 属性，<code>CancelToken</code> 的构造函数参数支持传入一个 <code>executor</code> 方法，该方法的参数是一个取消函数 <code>c</code>，我们可以在 <code>executor</code> 方法执行的内部拿到这个取消函数 <code>c</code>，赋值给我们外部定义的 <code>cancel</code> 变量，之后我们可以通过调用这个 <code>cancel</code> 方法来取消请求。</p>
<h3><a id="%E5%BC%82%E6%AD%A5%E5%88%86%E7%A6%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>异步分离的设计方案</h3>
<p>通过需求分析，我们知道想要实现取消某次请求，我们需要为该请求配置一个 <code>cancelToken</code>，然后在外部调用一个 <code>cancel</code> 方法。</p>
<p>请求的发送是一个异步过程，最终会执行 <code>xhr.send</code> 方法，<code>xhr</code> 对象提供了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/abort"><code>abort</code></a> 方法，可以把请求取消。因为我们在外部是碰不到 <code>xhr</code> 对象的，所以我们想在执行 <code>cancel</code> 的时候，去执行 <code>xhr.abort</code> 方法。</p>
<p>现在就相当于我们在 <code>xhr</code> 异步请求过程中，插入一段代码，当我们在外部执行 <code>cancel</code> 函数的时候，会驱动这段代码的执行，然后执行 <code>xhr.abort</code> 方法取消请求。</p>
<p>我们可以利用 Promise 实现异步分离，也就是在 <code>cancelToken</code> 中保存一个 <code>pending</code> 状态的 Promise 对象，然后当我们执行 <code>cancel</code> 方法的时候，能够访问到这个 Promise 对象，把它从 <code>pending</code> 状态变成 <code>resolved</code> 状态，这样我们就可以在 <code>then</code> 函数中去实现取消请求的逻辑，类似如下的代码：</p>
<pre><code class="language-typescript">if (cancelToken) {
  cancelToken.promise
    .then(reason =&gt; {request.abort()
      reject(reason)
    })
}
</code></pre>
<h3><a id="canceltoken%E7%B1%BB%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CancelToken 类实现</h3>
<p>接下来，我们就来实现这个 <code>CancelToken</code> 类，先来看一下接口定义：</p>
<h4><a id="%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口定义</h4>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  // ...
  cancelToken?: CancelToken
}

export interface CancelToken {
  promise: Promise&lt;string&gt;
  reason?: string
}

export interface Canceler {(message?: string): void
}

export interface CancelExecutor {(cancel: Canceler): void
}

</code></pre>
<p>其中 <code>CancelToken</code> 是实例类型的接口定义，<code>Canceler</code> 是取消方法的接口定义，<code>CancelExecutor</code> 是 <code>CancelToken</code> 类构造函数参数的接口定义。</p>
<h4><a id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码实现</h4>
<p>我们单独创建 <code>cancel</code> 目录来管理取消相关的代码，在 <code>cancel</code> 目录下创建 <code>CancelToken.ts</code> 文件：</p>
<pre><code class="language-typescript">import {CancelExecutor} from '../types'

interface ResolvePromise {(reason?: string): void
}

export default class CancelToken {
  promise: Promise&lt;string&gt;
  reason?: string

  constructor(executor: CancelExecutor) {
    let resolvePromise: ResolvePromise
    this.promise = new Promise&lt;string&gt;(resolve =&gt; {resolvePromise = resolve})

    executor(message =&gt; {if (this.reason) {return}
      this.reason = message
      resolvePromise(this.reason)
    })}}
</code></pre>
<p>在 <code>CancelToken</code> 构造函数内部，实例化一个 <code>pending</code> 状态的 Promise 对象，然后用一个 <code>resolvePromise</code> 变量指向 <code>resolve</code> 函数。接着执行 <code>executor</code> 函数，传入一个 <code>cancel</code> 函数，在 <code>cancel</code> 函数内部，会调用 <code>resolvePromise</code> 把 Promise 对象从 <code>pending</code> 状态变为 <code>resolved</code> 状态。</p>
<p>接着我们在 <code>xhr.ts</code> 中插入一段取消请求的逻辑。</p>
<p><code>core/xhr.ts</code>：</p>
<pre><code class="language-typescript">const {/*....*/ cancelToken} = config

if (cancelToken) {
  cancelToken.promise.then(reason =&gt; {request.abort()
    reject(reason)
  })
}
</code></pre>
<p>这样就满足了第二种使用方式，接着我们要实现第一种使用方式，给 <code>CancelToken</code> 扩展静态接口。</p>
<h3><a id="canceltoken%E6%89%A9%E5%B1%95%E9%9D%99%E6%80%81%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CancelToken 扩展静态接口</h3>
<h4><a id="%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口定义</h4>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface CancelTokenSource {
  token: CancelToken
  cancel: Canceler
}

export interface CancelTokenStatic {new(executor: CancelExecutor): CancelToken

  source(): CancelTokenSource}
</code></pre>
<p>其中 <code>CancelTokenSource</code> 作为 <code>CancelToken</code> 类静态方法 <code>source</code> 函数的返回值类型，<code>CancelTokenStatic</code> 则作为 <code>CancelToken</code> 类的类类型。</p>
<h4><a id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码实现</h4>
<p><code>cancel/CancelToken.ts</code>：</p>
<pre><code class="language-typescript">export default class CancelToken {
  // ...

  static source(): CancelTokenSource {
    let cancel!: Canceler
    const token = new CancelToken(c =&gt; {cancel = c})
    return {
      cancel,
      token
    }
  }
}
</code></pre>
<p><code>source</code> 的静态方法很简单，定义一个 <code>cancel</code> 变量实例化一个 <code>CancelToken</code> 类型的对象，然后在 <code>executor</code> 函数中，把 <code>cancel</code> 指向参数 <code>c</code> 这个取消函数。</p>
<p>这样就满足了我们第一种使用方式，但是在第一种使用方式的例子中，我们在捕获请求的时候，通过 <code>axios.isCancel</code> 来判断这个错误参数 e 是不是一次取消请求导致的错误，接下来我们对取消错误的原因做一层包装，并且把给 <code>axios</code> 扩展静态方法</p>
<h3><a id="cancel%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8F%8A-axios%E7%9A%84%E6%89%A9%E5%B1%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cancel 类实现及 axios 的扩展</h3>
<h4><a id="%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口定义</h4>
<pre><code class="language-typescript">export interface Cancel {message?: string}

export interface CancelStatic {new(message?: string): Cancel
}

export interface AxiosStatic extends AxiosInstance {create(config?: AxiosRequestConfig): AxiosInstance

  CancelToken: CancelTokenStatic
  Cancel: CancelStatic
  isCancel: (value: any) =&gt; boolean
}
</code></pre>
<p>其中 <code>Cancel</code> 是实例类型的接口定义，<code>CancelStatic</code> 是类类型的接口定义，并且我们给 <code>axios</code> 扩展了多个静态方法。</p>
<h4><a id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码实现</h4>
<p>我在 <code>cancel</code> 目录下创建 <code>Cancel.ts</code> 文件。</p>
<pre><code class="language-typescript">export default class Cancel {
  message?: string

  constructor(message?: string) {this.message = message}
}

export function isCancel(value: any): boolean {return value instanceof Cancel}
</code></pre>
<p><code>Cancel</code> 类非常简单，拥有一个 <code>message</code> 的公共属性。<code>isCancel</code> 方法也非常简单，通过 <code>instanceof</code> 来判断传入的值是不是一个 <code>Cancel</code> 对象。</p>
<p>接着我们对 <code>CancelToken</code> 类中的 <code>reason</code> 类型做修改，把它变成一个 <code>Cancel</code> 类型的实例。</p>
<p>先修改定义部分。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface CancelToken {
  promise: Promise&lt;Cancel&gt;
  reason?: Cancel
}
</code></pre>
<p>再修改实现部分：</p>
<pre><code class="language-typescript">import Cancel from './Cancel'

interface ResolvePromise {(reason?: Cancel): void
}

export default class CancelToken {
  promise: Promise&lt;Cancel&gt;
  reason?: Cancel

  constructor(executor: CancelExecutor) {
    let resolvePromise: ResolvePromise
    this.promise = new Promise&lt;Cancel&gt;(resolve =&gt; {resolvePromise = resolve})

    executor(message =&gt; {if (this.reason) {return}
      this.reason = new Cancel(message)
      resolvePromise(this.reason)
    })}}
</code></pre>
<p>接下来我们给 <code>axios</code> 扩展一些静态方法，供用户使用。</p>
<p><code>axios.ts</code>：</p>
<pre><code class="language-typescript">import CancelToken from './cancel/CancelToken'
import Cancel, {isCancel} from './cancel/Cancel'

axios.CancelToken = CancelToken
axios.Cancel = Cancel
axios.isCancel = isCancel
</code></pre>
<h3><a id="%E9%A2%9D%E5%A4%96%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>额外逻辑实现</h3>
<p>除此之外，我们还需要实现一些额外逻辑，比如当一个请求携带的 <code>cancelToken</code> 已经被使用过，那么我们甚至都可以不发送这个请求，只需要抛一个异常即可，并且抛异常的信息就是我们取消的原因，所以我们需要给 <code>CancelToken</code> 扩展一个方法。</p>
<p>先修改定义部分。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface CancelToken {
  promise: Promise&lt;Cancel&gt;
  reason?: Cancel

  throwIfRequested(): void}
</code></pre>
<p>添加一个 <code>throwIfRequested</code> 方法，接下来实现它：</p>
<p><code>cancel/CancelToken.ts</code>：</p>
<pre><code class="language-typescript">export default class CancelToken {
  // ...

  throwIfRequested(): void {if (this.reason) {throw this.reason}
  }
}
</code></pre>
<p>判断如果存在 <code>this.reason</code>，说明这个 <code>token</code> 已经被使用过了，直接抛错。</p>
<p>接下来在发送请求前增加一段逻辑。</p>
<p><code>core/dispatchRequest.ts</code>：</p>
<pre><code class="language-typescript">export default function dispatchRequest(config: AxiosRequestConfig): AxiosPromise {throwIfCancellationRequested(config)
  processConfig(config)

  // ...
}

function throwIfCancellationRequested(config: AxiosRequestConfig): void {if (config.cancelToken) {config.cancelToken.throwIfRequested()
  }
}
</code></pre>
<p>发送请求前检查一下配置的 cancelToken 是否已经使用过了，如果已经被用过则不用法请求，直接抛异常。</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<p>在 <code>examples</code> 目录下创建 <code>cancel</code> 目录，在 <code>cancel</code> 目录下创建 <code>index.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Cancel example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;/__build__/cancel.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>接着创建 <code>app.ts</code> 作为入口文件：</p>
<pre><code class="language-typescript">import axios, {Canceler} from '../../src/index'

const CancelToken = axios.CancelToken
const source = CancelToken.source()

axios.get('/cancel/get', {cancelToken: source.token}).catch(function(e) {if (axios.isCancel(e)) {console.log('Request canceled', e.message)
  }
})setTimeout(() =&gt; {source.cancel('Operation canceled by the user.')

  axios.post('/cancel/post', { a: 1}, {cancelToken: source.token}).catch(function(e) {if (axios.isCancel(e)) {console.log(e.message)
    }
  })}, 100)

let cancel: Canceler

axios.get('/cancel/get', {
  cancelToken: new CancelToken(c =&gt; {cancel = c})
}).catch(function(e) {if (axios.isCancel(e)) {console.log('Request canceled')
  }
})setTimeout(() =&gt; {cancel()
}, 200)
</code></pre>
<p>我们的 demo 展示了 2 种使用方式，也演示了如果一个 token 已经被使用过，则再次携带该 token 的请求并不会发送。</p>
<p>至此，我们完成了 <code>ts-axios</code> 的请求取消功能，我们巧妙地利用了 Promise 实现了异步分离。目前官方 <code>axios</code> 库的一些大的 feature 我们都已经实现了，下面的章节我们就开始补充完善 <code>ts-axios</code> 的其它功能。</p>
<h1><a id="%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>更多功能实现</h1>
<h2><a id="withcredentials" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>withCredentials</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>有些时候我们会发一些跨域请求，比如 <code>http://domain-a.com</code> 站点发送一个 <code>http://api.domain-b.com/get</code> 的请求，默认情况下，浏览器会根据同源策略限制这种跨域请求，但是可以通过 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS</a> 技术解决跨域问题。</p>
<p>在同域的情况下，我们发送请求会默认携带当前域下的 cookie，但是在跨域的情况下，默认是不会携带请求域下的 cookie 的，比如 <code>http://domain-a.com</code> 站点发送一个 <code>http://api.domain-b.com/get</code> 的请求，默认是不会携带 <code>api.domain-b.com</code> 域下的 cookie，如果我们想携带（很多情况下是需要的），只需要设置请求的 <code>xhr</code> 对象的 <code>withCredentials</code> 为 true 即可。</p>
<h3><a id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码实现</h3>
<p>先修改 <code>AxiosRequestConfig</code> 的类型定义。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  // ...
  withCredentials?: boolean
}
</code></pre>
<p>然后修改请求发送前的逻辑。</p>
<p><code>core/xhr.ts</code>：</p>
<pre><code class="language-typescript">const {/*...*/ withCredentials} = config

if (withCredentials) {request.withCredentials = true}
</code></pre>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<p>在 <code>examples</code> 目录下创建 <code>more</code> 目录，在 <code>cancel</code> 目录下创建 <code>index.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;More example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;/__build__/more.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>接着创建 <code>app.ts</code> 作为入口文件：</p>
<pre><code class="language-typescript">import axios from '../../src/index'

document.cookie = 'a=b'

axios.get('/more/get').then(res =&gt; {console.log(res)
})axios.post('http://127.0.0.1:8088/more/server2', {}, {withCredentials: true}).then(res =&gt; {console.log(res)
})
</code></pre>
<p>这次我们除了给 <code>server.js</code> 去配置了接口路由，还创建了 <code>server2.js</code>，起了一个跨域的服务。</p>
<pre><code class="language-javascript">const express = require('express')
const bodyParser = require('body-parser')
const cookieParser = require('cookie-parser')

const app = express()app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: true}))
app.use(cookieParser())

const router = express.Router()

const cors = {
  'Access-Control-Allow-Origin': 'http://localhost:8080',
  'Access-Control-Allow-Credentials': true,
  'Access-Control-Allow-Methods': 'POST, GET, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type'
}

router.post('/more/server2', function(req, res) {res.set(cors)
  res.json(req.cookies)
})router.options('/more/server2', function(req, res) {res.set(cors)
  res.end()})

app.use(router)

const port = 8088
module.exports = app.listen(port)
</code></pre>
<p>这里需要安装一下 <code>cookie-parser</code> 插件，用于请求发送的 cookie。</p>
<p>通过 demo 演示我们可以发现，对于同域请求，会携带 cookie，而对于跨域请求，只有我们配置了 <code>withCredentials</code> 为 true，才会携带 cookie。</p>
<p>至此我们的 <code>withCredentials</code> feature 开发完毕，下一节课我们来实现 axios 对 XSRF<br />
的防御功能。</p>
<h2><a id="xsrf%E9%98%B2%E5%BE%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>XSRF 防御</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>XSRF 又名 <a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/First_steps/Website_security#Cross-Site_Request_Forgery_(CSRF)">CSRF</a>，跨站请求伪造，它是前端常见的一种攻击方式，我们先通过一张图来认识它的攻击手段。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205150956385.png" alt="image-20220515095607433" /></p>
<p>CSRF 的防御手段有很多，比如验证请求的 referer，但是 referer 也是可以伪造的，所以杜绝此类攻击的一种方式是服务器端要求每次请求都包含一个 <code>token</code>，这个 <code>token</code> 不在前端生成，而是在我们每次访问站点的时候生成，并通过 <code>set-cookie</code> 的方式种到客户端，然后客户端发送请求的时候，从 <code>cookie</code> 中对应的字段读取出 <code>token</code>，然后添加到请求 <code>headers</code> 中。这样服务端就可以从请求 <code>headers</code> 中读取这个 <code>token</code> 并验证，由于这个 <code>token</code> 是很难伪造的，所以就能区分这个请求是否是用户正常发起的。</p>
<p>对于我们的 <code>ts-axios</code> 库，我们要自动把这几件事做了，每次发送请求的时候，从 <code>cookie</code> 中读取对应的 <code>token</code> 值，然后添加到请求 <code>headers</code> 中。我们允许用户配置 <code>xsrfCookieName</code> 和 <code>xsrfHeaderName</code>，其中 <code>xsrfCookieName</code> 表示存储 <code>token</code> 的 <code>cookie</code> 名称，<code>xsrfHeaderName</code> 表示请求 <code>headers</code> 中 <code>token</code> 对应的 <code>header</code> 名称。</p>
<pre><code class="language-typescript">axios.get('/more/get',{
  xsrfCookieName: 'XSRF-TOKEN', // default
  xsrfHeaderName: 'X-XSRF-TOKEN' // default
}).then(res =&gt; {console.log(res)
})
</code></pre>
<p>我们提供 <code>xsrfCookieName</code> 和 <code>xsrfHeaderName</code> 的默认值，当然用户也可以根据自己的需求在请求中去配置 <code>xsrfCookieName</code> 和 <code>xsrfHeaderName</code>。</p>
<h3><a id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码实现</h3>
<p>先修改 <code>AxiosRequestConfig</code> 的类型定义。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  // ...
  xsrfCookieName?: string
  xsrfHeaderName?: string
}
</code></pre>
<p>然后修改默认配置。</p>
<p><code>defaults.ts</code>：</p>
<pre><code class="language-typescript">const defaults: AxiosRequestConfig = {
  // ...
  xsrfCookieName: 'XSRF-TOKEN',

  xsrfHeaderName: 'X-XSRF-TOKEN',
}
</code></pre>
<p>接下来我们要做三件事：</p>
<ul>
<li>
<p>首先判断如果是配置 <code>withCredentials</code> 为 <code>true</code> 或者是同域请求，我们才会请求 <code>headers</code> 添加 <code>xsrf</code> 相关的字段。</p>
</li>
<li>
<p>如果判断成功，尝试从 cookie 中读取 <code>xsrf</code> 的 <code>token</code> 值。</p>
</li>
<li>
<p>如果能读到，则把它添加到请求 <code>headers</code> 的 <code>xsrf</code> 相关字段中。</p>
</li>
</ul>
<p>我们先来实现同域请求的判断。</p>
<p><code>helpers/url.ts</code>：</p>
<pre><code class="language-typescript">interface URLOrigin {
  protocol: string
  host: string
}


export function isURLSameOrigin(requestURL: string): boolean {const parsedOrigin = resolveURL(requestURL)
  return (parsedOrigin.protocol === currentOrigin.protocol &amp;&amp; parsedOrigin.host === currentOrigin.host)
}

const urlParsingNode = document.createElement('a')
const currentOrigin = resolveURL(window.location.href)

function resolveURL(url: string): URLOrigin {urlParsingNode.setAttribute('href', url)
  const {protocol, host} = urlParsingNode

  return {
    protocol,
    host
  }
}
</code></pre>
<p>同域名的判断主要利用了一个技巧，创建一个 a 标签的 DOM，然后设置 <code>href</code> 属性为我们传入的 <code>url</code>，然后可以获取该 DOM 的 <code>protocol</code>、<code>host</code>。当前页面的 <code>url</code> 和请求的 <code>url</code> 都通过这种方式获取，然后对比它们的 <code>protocol</code> 和 <code>host</code> 是否相同即可。</p>
<p>接着实现 cookie 的读取。</p>
<p><code>helpers/cookie.ts</code>：</p>
<pre><code class="language-typescript">const cookie = {read(name: string): string | null {const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'))
    return match ? decodeURIComponent(match[3]) : null
  }
}

export default cookie
</code></pre>
<p><code>cookie</code> 的读取逻辑很简单，利用了正则表达式可以解析到 <code>name</code> 对应的值。</p>
<p>最后实现完整的逻辑。</p>
<p><code>core/xhr.ts</code>：</p>
<pre><code class="language-typescript">const {
  /*...*/
  xsrfCookieName,
  xsrfHeaderName
} = config

if ((withCredentials || isURLSameOrigin(url!)) &amp;&amp; xsrfCookieName){const xsrfValue = cookie.read(xsrfCookieName)
  if (xsrfValue) {headers[xsrfHeaderName!] = xsrfValue
  }
}
</code></pre>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<pre><code class="language-typescript">const instance = axios.create({
  xsrfCookieName: 'XSRF-TOKEN-D',
  xsrfHeaderName: 'X-XSRF-TOKEN-D'
})instance.get('/more/get').then(res =&gt; {console.log(res)
})
</code></pre>
<p><code>examples/server.js</code>：</p>
<pre><code class="language-javascript">app.use(express.static(__dirname, {setHeaders (res) {res.cookie('XSRF-TOKEN-D', '1234abc')
  }
}))
</code></pre>
<p>在访问页面的时候，服务端通过 <code>set-cookie</code> 往客户端种了 <code>key</code> 为 <code>XSRF-TOKEN</code>，值为 <code>1234abc</code> 的 <code>cookie</code>，作为 <code>xsrf</code> 的 <code>token</code> 值。</p>
<p>然后我们在前端发送请求的时候，就能从 cookie 中读出 <code>key</code> 为 <code>XSRF-TOKEN</code> 的值，然后把它添加到 <code>key</code> 为 <code>X-XSRF-TOKEN</code> 的请求 <code>headers</code> 中。</p>
<p>至此，我们实现了 XSRF 的自动防御的能力，下节课我们来实现 ts-axios 对上传和下载请求的支持。</p>
<h2><a id="%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E7%9A%84%E8%BF%9B%E5%BA%A6%E7%9B%91%E6%8E%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>上传和下载的进度监控</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>有些时候，当我们上传文件或者是请求一个大体积数据的时候，希望知道实时的进度，甚至可以基于此做一个进度条的展示。</p>
<p>我们希望给 <code>axios</code> 的请求配置提供 <code>onDownloadProgress</code> 和 <code>onUploadProgress</code> 2 个函数属性，用户可以通过这俩函数实现对下载进度和上传进度的监控。</p>
<pre><code class="language-typescript">axios.get('/more/get',{onDownloadProgress(progressEvent) {// 监听下载进度}
})

axios.post('/more/post',{onUploadProgress(progressEvent) {// 监听上传进度}
})
</code></pre>
<p><code>xhr</code> 对象提供了一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/progress_event"><code>progress</code></a> 事件，我们可以监听此事件对数据的下载进度做监控；另外，<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload"><code>xhr.uplaod</code></a> 对象也提供了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/progress_event"><code>progress</code></a> 事件，我们可以基于此对上传进度做监控。</p>
<h3><a id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码实现</h3>
<p>首先修改一下类型定义。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  // ...
  onDownloadProgress?: (e: ProgressEvent) =&gt; void
  onUploadProgress?: (e: ProgressEvent) =&gt; void
}
</code></pre>
<p>接着在发送请求前，给 <code>xhr</code> 对象添加属性。</p>
<p><code>core/xhr.ts</code>：</p>
<pre><code class="language-typescript">const {
  /*...*/
  onDownloadProgress,
  onUploadProgress
} = config

if (onDownloadProgress) {request.onprogress = onDownloadProgress}

if (onUploadProgress) {request.upload.onprogress = onUploadProgress}
</code></pre>
<p>另外，如果请求的数据是 <code>FormData</code> 类型，我们应该主动删除请求 <code>headers</code> 中的 <code>Content-Type</code> 字段，让浏览器自动根据请求数据设置 <code>Content-Type</code>。比如当我们通过 <code>FormData</code> 上传文件的时候，浏览器会把请求 <code>headers</code> 中的 <code>Content-Type</code> 设置为 <code>multipart/form-data</code>。</p>
<p>我们先添加一个判断 <code>FormData</code> 的方法。</p>
<p><code>helpers/util.ts</code>：</p>
<pre><code class="language-typescript">export function isFormData(val: any): boolean {return typeof val !== 'undefined' &amp;&amp; val instanceof FormData}
</code></pre>
<p>然后再添加相关逻辑。</p>
<p><code>core/xhr.ts</code>：</p>
<pre><code class="language-typescript">if (isFormData(data)) {delete headers['Content-Type']
}
</code></pre>
<p>我们发现，<code>xhr</code> 函数内部随着需求越来越多，代码也越来越臃肿，我们可以把逻辑梳理一下，把内部代码做一层封装优化。</p>
<pre><code class="language-typescript">export default function xhr(config: AxiosRequestConfig): AxiosPromise {return new Promise((resolve, reject) =&gt; {
    const {
      data = null,
      url,
      method = 'get',
      headers,
      responseType,
      timeout,
      cancelToken,
      withCredentials,
      xsrfCookieName,
      xsrfHeaderName,
      onDownloadProgress,
      onUploadProgress
    } = config

    const request = new XMLHttpRequest()request.open(method.toUpperCase(), url!, true)configureRequest()

    addEvents()processHeaders()

    processCancel()request.send(data)

    function configureRequest(): void {if (responseType) {request.responseType = responseType}

      if (timeout) {request.timeout = timeout}

      if (withCredentials) {request.withCredentials = withCredentials}
    }

    function addEvents(): void {request.onreadystatechange = function handleLoad() {if (request.readyState !== 4) {return}

        if (request.status === 0) {return}

        const responseHeaders = parseHeaders(request.getAllResponseHeaders())
        const responseData =
          responseType &amp;&amp; responseType !== 'text' ? request.response : request.responseText
        const response: AxiosResponse = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        }
        handleResponse(response)
      }

      request.onerror = function handleError() {reject(createError('Network Error', config, null, request))
      }

      request.ontimeout = function handleTimeout() {
        reject(createError(`Timeout of ${config.timeout} ms exceeded`, config, 'ECONNABORTED', request))}

      if (onDownloadProgress) {request.onprogress = onDownloadProgress}

      if (onUploadProgress) {request.upload.onprogress = onUploadProgress}
    }

    function processHeaders(): void {if (isFormData(data)) {delete headers['Content-Type']
      }

      if ((withCredentials || isURLSameOrigin(url!)) &amp;&amp; xsrfCookieName) {const xsrfValue = cookie.read(xsrfCookieName)
        if (xsrfValue) {headers[xsrfHeaderName!] = xsrfValue
        }
      }

      Object.keys(headers).forEach(name =&gt; {if (data === null &amp;&amp; name.toLowerCase() === 'content-type') {delete headers[name]
        } else {request.setRequestHeader(name, headers[name])
        }
      }) }

    function processCancel(): void {if (cancelToken) {
        cancelToken.promise.then(reason =&gt; {request.abort()
          reject(reason)
        })}}

    function handleResponse(response: AxiosResponse): void {if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) {resolve(response)
      } else {
        reject(
          createError(`Request failed with status code ${response.status}`,
            config,
            null,
            request,
            response
          ))}
    }
  })
}
</code></pre>
<p>我们把整个流程分为 7 步：</p>
<ul>
<li>创建一个 <code>request</code> 实例。</li>
<li>执行 <code>request.open</code> 方法初始化。</li>
<li>执行 <code>configureRequest</code> 配置 <code>request</code> 对象。</li>
<li>执行 <code>addEvents</code> 给 <code>request</code> 添加事件处理函数。</li>
<li>执行 <code>processHeaders</code> 处理请求 <code>headers</code>。</li>
<li>执行 <code>processCancel</code> 处理请求取消逻辑。</li>
<li>执行 <code>request.send</code> 方法发送请求。</li>
</ul>
<p>这样拆分后整个流程就会显得非常清晰，未来我们再去新增需求的时候代码也不会显得越来越臃肿。</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<p>这节课的 demo 非常有意思，我们第一次给界面上增加了一些交互的按钮。</p>
<p><code>examples/more/index.html</code></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;More example&lt;/title&gt;
  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;file download&lt;/h1&gt;
&lt;div&gt;
  &lt;button id=&quot;download&quot; class=&quot;btn btn-primary&quot;&gt;Download&lt;/button&gt;
&lt;/div&gt;
&lt;h1&gt;file upload&lt;/h1&gt;
&lt;form role=&quot;form&quot; class=&quot;form&quot; onsubmit=&quot;return false;&quot;&gt;
  &lt;input id=&quot;file&quot; type=&quot;file&quot; class=&quot;form-control&quot;/&gt;
  &lt;button id=&quot;upload&quot; type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;Upload&lt;/button&gt;
&lt;/form&gt;

&lt;script src=&quot;/__build__/more.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>另外，我们为了友好地展示上传和下载进度，我们引入了一个开源库 <a href="https://github.com/rstacruz/nprogress">nprogress</a>，它可以在页面的顶部展示进度条。</p>
<p><code>examples/more/app.ts</code>：</p>
<pre><code class="language-typescript">const instance = axios.create()function calculatePercentage(loaded: number, total: number) {return Math.floor(loaded * 1.0) / total
}

function loadProgressBar() {const setupStartProgress = () =&gt; {
    instance.interceptors.request.use(config =&gt; {NProgress.start()
      return config
    }) }

  const setupUpdateProgress = () =&gt; {const update = (e: ProgressEvent) =&gt; {console.log(e)
      NProgress.set(calculatePercentage(e.loaded, e.total))
    }
    instance.defaults.onDownloadProgress = update
    instance.defaults.onUploadProgress = update
  }

  const setupStopProgress = () =&gt; {
    instance.interceptors.response.use(response =&gt; {NProgress.done()
      return response
    }, error =&gt; {NProgress.done()
      return Promise.reject(error)
    }) }

  setupStartProgress()setupUpdateProgress()
  setupStopProgress()}

loadProgressBar()const downloadEl = document.getElementById('download')

downloadEl!.addEventListener('click', e =&gt; {instance.get('https://img.mukewang.com/5cc01a7b0001a33718720632.jpg')
})const uploadEl = document.getElementById('upload')

uploadEl!.addEventListener('click', e =&gt; {const data = new FormData()
  const fileEl = document.getElementById('file') as HTMLInputElement
  if (fileEl.files) {data.append('file', fileEl.files[0])

    instance.post('/more/upload', data)
  }
})
</code></pre>
<p>对于 <code>progress</code> 事件参数 <code>e</code>，会有 <code>e.total</code> 和 <code>e.loaded</code> 属性，表示进程总体的工作量和已经执行的工作量，我们可以根据这 2 个值算出当前进度，然后通过 <code>Nprogess.set</code> 设置。另外，我们通过配置请求拦截器和响应拦截器执行 <code>NProgress.start()</code> 和 <code>NProgress.done()</code>。</p>
<p>我们给下载按钮绑定了一个 <code>click</code> 事件，请求一张图片，我们可以看到实时的进度；另外我们也给上传按钮绑定了一个 <code>click</code> 事件，上传我们选择的文件，同样也能看到实时进度。</p>
<p>在服务端，我们为了处理上传请求，需要下载安装一个 <code>express</code> 的中间件 <code>connect-multiparty</code>，然后使用它。</p>
<p><code>example/server.js</code>：</p>
<pre><code class="language-javascript">const multipart = require('connect-multiparty')
app.use(multipart({uploadDir: path.resolve(__dirname, 'upload-file')
}))router.post('/more/upload', function(req, res) {console.log(req.body, req.files)
  res.end('upload success!')
})
</code></pre>
<p>这里我们需要在 <code>examples</code> 目录下创建一个 <code>upload-file</code> 的空目录，用于存放上传的文件。</p>
<p>通过这个中间件，我们就可以处理上传请求并且可以把上传的文件存储在 <code>upload-file</code> 目录下。</p>
<p>为了保证代码正常运行，我们还需要在 <code>examples/webpack.config.js</code> 中添加 <code>css-loader</code> 和 <code>css-loader</code>，不要忘记先安装它们。</p>
<p>至此，<code>ts-axios</code> 支持了上传下载进度事件的回调函数的配置，用户可以通过配置这俩函数实现对下载进度和上传进度的监控。下一节课我们来实现 http 的认证授权功能。</p>
<h2><a id="http%E6%8E%88%E6%9D%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP 授权</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>HTTP 协议中的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization">Authorization</a> 请求 header 会包含服务器用于验证用户代理身份的凭证，通常会在服务器返回 401 Unauthorized 状态码以及 WWW-Authenticate 消息头之后在后续请求中发送此消息头。</p>
<p>axios 库也允许你在请求配置中配置 <code>auth</code> 属性，<code>auth</code> 是一个对象结构，包含 <code>username</code> 和 <code>password</code> 2 个属性。一旦用户在请求的时候配置这俩属性，我们就会自动往 HTTP 的 请求 header 中添加 <code>Authorization</code> 属性，它的值为 <code>Basic 加密串 </code>。<br />
这里的加密串是 <code>username:password</code> base64 加密后的结果。</p>
<pre><code class="language-typescript">axios.post('/more/post', {a: 1}, {
  auth: {
    username: 'Yee',
    password: '123456'
  }
}).then(res =&gt; {console.log(res)
})
</code></pre>
<h3><a id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码实现</h3>
<p>首先修改一下类型定义。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  // ...
  auth?: AxiosBasicCredentials
}

export interface AxiosBasicCredentials {
  username: string
  password: string
}
</code></pre>
<p>接着修改合并规则，因为 auth 也是一个对象格式，所以它的合并规则是 <code>deepMergeStrat</code>。</p>
<p><code>core/mergeConfig.ts</code>：</p>
<pre><code class="language-typescript">const stratKeysDeepMerge = ['headers', 'auth']
</code></pre>
<p>然后修改发送请求前的逻辑。</p>
<p><code>core/xhr.ts</code>：</p>
<pre><code class="language-typescript">const {
  /*...*/
  auth
} = config

if (auth) {headers['Authorization'] = 'Basic' + btoa(auth.username + ':' + auth.password)
}
</code></pre>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<pre><code class="language-typescript">axios.post('/more/post', {a: 1}, {
  auth: {
    username: 'Yee',
    password: '123456'
  }
}).then(res =&gt; {console.log(res)
})
</code></pre>
<p>另外，我们在 <code>server.js</code> 中对于这个路由接口写了一段小逻辑：</p>
<pre><code class="language-javascript">router.post('/more/post', function(req, res) {
  const auth = req.headers.authorization
  const [type, credentials] = auth.split(' ')
  console.log(atob(credentials))
  const [username, password] = atob(credentials).split(':')
  if (type === 'Basic' &amp;&amp; username === 'Yee' &amp;&amp; password === '123456') {res.json(req.body)
  } else {res.end('UnAuthorization')
  }
})
</code></pre>
<p>注意，这里我们需要安装第三方库 <code>atob</code> 实现 base64 串的解码。</p>
<p>至此，<code>ts-axios</code> 支持了 HTTP 授权功能，用户可以通过配置 auth 对象实现自动在请求 header 中添加 <code>Authorization</code> 属性。下一节课我们来实现自定义合法状态码功能。</p>
<h2><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%88%E6%B3%95%E7%8A%B6%E6%80%81%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义合法状态码</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>之前 <code>ts-axios</code> 在处理响应结果的时候，认为 HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/status">status</a> 在 200 和 300 之间是一个合法值，在这个区间之外则创建一个错误。有些时候我们想自定义这个规则，比如认为 304 也是一个合法的状态码，所以我们希望 <code>ts-axios</code> 能提供一个配置，允许我们自定义合法状态码规则。如下：</p>
<pre><code class="language-typescript">axios.get('/more/304', {validateStatus(status) {return status &gt;= 200 &amp;&amp; status &lt; 400}
}).then(res =&gt; {console.log(res)
}).catch((e: AxiosError) =&gt; {console.log(e.message)
})
</code></pre>
<p>通过在请求配置中配置一个 <code>validateStatus</code> 函数，它可以根据参数 <code>status</code> 来自定义合法状态码的规则。</p>
<h3><a id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码实现</h3>
<p>首先修改一下类型定义。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  // ...
  validateStatus?: (status: number) =&gt; boolean
}
</code></pre>
<p>然后我们来修改默认配置规则。</p>
<p><code>defaults.ts</code>：</p>
<pre><code class="language-typescript">validateStatus(status: number): boolean {return status &gt;= 200 &amp;&amp; status &lt; 300}
</code></pre>
<p>添加默认合法状态码的校验规则。然后再请求后对响应数据的处理逻辑。</p>
<p><code>core/xhr.ts</code>：</p>
<pre><code class="language-typescript">const {
  /*...*/
  validateStatus
} = config

function handleResponse(response: AxiosResponse): void {if (!validateStatus || validateStatus(response.status)) {resolve(response)
  } else {
    reject(
      createError(`Request failed with status code ${response.status}`,
        config,
        null,
        request,
        response
      ))}
}
</code></pre>
<p>如果没有配置 <code>validateStatus</code> 以及 <code>validateStatus</code> 函数返回的值为 true 的时候，都认为是合法的，正常 <code>resolve(response)</code>，否则都创建一个错误。</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<pre><code class="language-typescript">axios.get('/more/304').then(res =&gt; {console.log(res)
}).catch((e: AxiosError) =&gt; {console.log(e.message)
})

axios.get('/more/304', {validateStatus(status) {return status &gt;= 200 &amp;&amp; status &lt; 400}
}).then(res =&gt; {console.log(res)
}).catch((e: AxiosError) =&gt; {console.log(e.message)
})
</code></pre>
<p><code>server.js</code> 中我们编写了这个路由接口</p>
<pre><code class="language-javascript">router.get('/more/304', function(req, res) {res.status(304)
  res.end()})
</code></pre>
<p>接口返回 304 状态码，对于默认的请求我们会输出一条错误信息。第二个请求中我们配置了自定义合法状态码规则，区间在 200 和 400 之间，这样就不会报错，而是可以正常输出响应对象。</p>
<p>至此 <code>ts-axios</code> 实现了自定义合法状态码功能，用户可以配置 <code>validateStatus</code> 自定义合法状态码规则。之前有同学会质疑 <code>ts-axios</code> 对于请求 <code>url</code> 参数的序列化处理规则，下一节课我们来实现自定义参数序列化规则功能。</p>
<h2><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E5%BA%8F%E5%88%97%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义参数序列化</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>在之前的章节，我们对请求的 url 参数做了处理，我们会解析传入的 params 对象，根据一定的规则把它解析成字符串，然后添加在 url 后面。在解析的过程中，我们会对字符串 encode，但是对于一些特殊字符比如 <code>@</code>、<code>+</code> 等却不转义，这是 axios 库的默认解析规则。当然，我们也希望自己定义解析规则，于是我们希望 <code>ts-axios</code> 能在请求配置中允许我们配置一个 <code>paramsSerializer</code> 函数来自定义参数的解析规则，该函数接受 <code>params</code> 参数，返回值作为解析后的结果，如下：</p>
<pre><code class="language-typescript">axios.get('/more/get', {
  params: {
    a: 1,
    b: 2,
    c: ['a', 'b', 'c']
  },
  paramsSerializer(params) {return qs.stringify(params, { arrayFormat: 'brackets'})
  }
}).then(res =&gt; {console.log(res)
})
</code></pre>
<h3><a id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码实现</h3>
<p>首先修改一下类型定义。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  // ...
  paramsSerializer?: (params: any) =&gt; string
}
</code></pre>
<p>然后修改 <code>buildURL</code> 函数的实现。</p>
<p><code>helpers/url.ts</code>：</p>
<pre><code class="language-typescript">export function buildURL(
  url: string,
  params?: any,
  paramsSerializer?: (params: any) =&gt; string
): string {if (!params) {return url}

  let serializedParams

  if (paramsSerializer) {serializedParams = paramsSerializer(params)
  } else if (isURLSearchParams(params)) {serializedParams = params.toString()
  } else {const parts: string[] = []

    Object.keys(params).forEach(key =&gt; {const val = params[key]
      if (val === null || typeof val === 'undefined') {return}
      let values = []
      if (Array.isArray(val)) {
        values = val
        key += '[]'} else {values = [val]
      }
      values.forEach(val =&gt; {if (isDate(val)) {val = val.toISOString()
        } else if (isPlainObject(val)) {val = JSON.stringify(val)
        }
        parts.push(```{encode(key)}=``{encode(val)}`)})
    })serializedParams = parts.join('&amp;')
  }

  if (serializedParams) {const markIndex = url.indexOf('#')
    if (markIndex !== -1) {url = url.slice(0, markIndex)
    }

    url += (url.indexOf('?') === -1 ? '?' : '&amp;')+ serializedParams}

  return url
}
</code></pre>
<p>这里我们给 <code>buildURL</code> 函数新增了 <code>paramsSerializer</code> 可选参数，另外我们还新增了对 <code>params</code> 类型判断，如果它是一个 <code>URLSearchParams</code> 对象实例的话，我们直接返回它 <code>toString</code> 后的结果。</p>
<p><code>helpers/util.ts</code>：</p>
<pre><code class="language-typescript">export function isURLSearchParams(val: any): val is URLSearchParams {return typeof val !== 'undefined' &amp;&amp; val instanceof URLSearchParams}
</code></pre>
<p>最后我们要修改 <code>buildURL</code> 调用的逻辑。</p>
<p><code>core/dispatchRequest.ts</code>：</p>
<pre><code class="language-typescript">function transformURL(config: AxiosRequestConfig): string {const { url, params, paramsSerializer} = config
  return buildURL(url!, params, paramsSerializer)
}
</code></pre>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<pre><code class="language-typescript">axios.get('/more/get', {params: new URLSearchParams('a=b&amp;c=d')
}).then(res =&gt; {console.log(res)
})

axios.get('/more/get', {
  params: {
    a: 1,
    b: 2,
    c: ['a', 'b', 'c']
  }
}).then(res =&gt; {console.log(res)
})

const instance = axios.create({paramsSerializer(params) {return qs.stringify(params, { arrayFormat: 'brackets'})
  }
})

instance.get('/more/get', {
  params: {
    a: 1,
    b: 2,
    c: ['a', 'b', 'c']
  }
}).then(res =&gt; {console.log(res)
})
</code></pre>
<p>我们编写了 3 种情况的请求，第一种满足请求的 params 参数是 <code>URLSearchParams</code> 对象类型的。后两种请求的结果主要区别在于前者并没有对 <code>[]</code> 转义，而后者会转义。</p>
<p>至此，<code>ts-axios</code> 实现了自定义参数序列化功能，用户可以配置 <code>paramsSerializer</code> 自定义参数序列化规则。下一节课我们来实现 <code>ts-axios</code> 对 <code>baseURL</code> 的支持。</p>
<h2><a id="baseurl" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>baseURL</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>有些时候，我们会请求某个域名下的多个接口，我们不希望每次发送请求都填写完整的 url，希望可以配置一个 <code>baseURL</code>，之后都可以传相对路径。如下：</p>
<pre><code class="language-typescript">const instance = axios.create({baseURL: 'https://some-domain.com/api'})

instance.get('/get')

instance.post('/post')
</code></pre>
<p>我们一旦配置了 <code>baseURL</code>，之后请求传入的 <code>url</code> 都会和我们的 <code>baseURL</code> 拼接成完整的绝对地址，除非请求传入的 <code>url</code> 已经是绝对地址。</p>
<h3><a id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码实现</h3>
<p>首先修改一下类型定义。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosRequestConfig {
  // ...
  baseURL?: string
}
</code></pre>
<p>接下来实现 2 个辅助函数。</p>
<p><code>helpers/url.ts</code>：</p>
<pre><code class="language-typescript">export function isAbsoluteURL(url: string): boolean {return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
}

export function combineURL(baseURL: string, relativeURL?: string): string {return relativeURL ? baseURL.replace(/\/+$/, '') +'/'+ relativeURL.replace(/^\/+/,'') : baseURL
}
</code></pre>
<p>最后我们来调用这俩个辅助函数。</p>
<p><code>core/dispatchRequest.ts</code>：</p>
<pre><code class="language-typescript">function transformURL(config: AxiosRequestConfig): string {let { url, params, paramsSerializer, baseURL} = config
  if (baseURL &amp;&amp; !isAbsoluteURL(url!)) {url = combineURL(baseURL, url)
  }
  return buildURL(url!, params, paramsSerializer)
}
</code></pre>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<pre><code class="language-typescript">const instance = axios.create({baseURL: 'https://img.mukewang.com/'})

instance.get('5cc01a7b0001a33718720632.jpg')

instance.get('https://img.mukewang.com/szimg/5becd5ad0001b89306000338-360-202.jpg')
</code></pre>
<p>这个 demo 非常简单，我们请求了慕课网的 2 张图片，注意当第二个请求 <code>url</code> 已经是绝对地址的时候，我们并不会再去拼接 <code>baseURL</code>。</p>
<p>至此，<code>ts-axios</code> 就实现了 <code>baseURL</code> 的配置功能，接下来我们来实现 <code>ts-axios</code> 的静态方法扩展。</p>
<h2><a id="%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态方法扩展</h2>
<h3><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h3>
<p>官方 axios 库实现了 <code>axios.all</code>、<code>axios.spread</code> 等方法，它们的用法如下：</p>
<pre><code class="language-typescript">function getUserAccount() {return axios.get('/user/12345');
}

function getUserPermissions() {return axios.get('/user/12345/permissions');
}

axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) {// Both requests are now complete}));
</code></pre>
<p>实际上，<code>axios.all</code> 就是 <code>Promise.all</code> 的封装，它返回的是一个 <code>Promise</code> 数组，<code>then</code> 函数的参数本应是一个参数为 <code>Promise resolves</code>（数组）的函数，在这里使用了 <code>axios.spread</code> 方法。所以 <code>axios.spread</code> 方法是接收一个函数，返回一个新的函数，新函数的结构满足 <code>then</code> 函数的参数结构。</p>
<p>个人认为 <code>axios</code> 这俩静态方法在目前看来很鸡肋，因为使用 <code>Promise</code> 一样可以完成这俩需求。</p>
<pre><code class="language-typescript">function getUserAccount() {return axios.get('/user/12345');
}

function getUserPermissions() {return axios.get('/user/12345/permissions');
}

Promise.all([getUserAccount(), getUserPermissions()])
  .then(([acct,perms]) {// Both requests are now complete}));
</code></pre>
<p>在 <code>Promise.all</code> 的 <code>resolve</code> 函数中，我们可以直接通过数组的解构拿到每个请求对应的响应对象。</p>
<p>但是为了保持与官网 axios API 一致，我们也在 <code>ts-axios</code> 库中实现这俩方法。</p>
<p>官方 axios 库也通过 <code>axios.Axios</code> 对外暴露了 <code>Axios</code> 类(感觉也没有啥使用场景，但为了保持一致，我们也会实现)。</p>
<p>另外对于 axios 实例，官网还提供了 <code>getUri</code> 方法在不发送请求的前提下根据传入的配置返回一个 url，如下：</p>
<pre><code class="language-typescript">const fakeConfig = {
  baseURL: 'https://www.baidu.com/',
  url: '/user/12345',
  params: {
    idClient: 1,
    idTest: 2,
    testString: 'thisIsATest'
  }
}
console.log(axios.getUri(fakeConfig))
// https://www.baidu.com/user/12345?idClient=1&amp;idTest=2&amp;testString=thisIsATest
</code></pre>
<h3><a id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码实现</h3>
<p>首先修改类型定义。</p>
<p><code>types/index.ts</code>：</p>
<pre><code class="language-typescript">export interface AxiosClassStatic {new (config: AxiosRequestConfig): Axios
}

export interface AxiosStatic extends AxiosInstance {
  // ...

  all&lt;T&gt;(promises: Array&lt;T | Promise&lt;T&gt;&gt;): Promise&lt;T[]&gt;

  spread&lt;T, R&gt;(callback: (...args: T[]) =&gt; R): (arr: T[]) =&gt; R

  Axios: AxiosClassStatic
}

export interface Axios {
  // ...

  getUri(config?: AxiosRequestConfig): string
}
</code></pre>
<p>然后我们去实现这几个静态方法。</p>
<p><code>axios.ts</code>：</p>
<pre><code class="language-typescript">axios.all = function all(promises) {return Promise.all(promises)
}

axios.spread = function spread(callback) {return function wrap(arr) {return callback.apply(null, arr)
  }
}

axios.Axios = Axios
</code></pre>
<p>最后我们去给 Axios 添加实例方法 <code>getUri</code>。</p>
<p><code>core/Axios.ts</code>：</p>
<pre><code class="language-typescript">getUri(config?: AxiosRequestConfig): string {config = mergeConfig(this.defaults, config)
  return transformURL(config)
}
</code></pre>
<p>先和默认配置合并，然后再通过 <code>dispatchRequest</code> 中实现的 <code>transformURL</code> 返回一个新的 <code>url</code>。</p>
<h3><a id="demo%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo 编写</h3>
<pre><code class="language-typescript">function getA() {return axios.get('/more/A')
}

function getB() {return axios.get('/more/B')
}

axios.all([getA(), getB()])
  .then(axios.spread(function(resA, resB) {console.log(resA.data)
    console.log(resB.data)
  }))axios.all([getA(), getB()])
  .then(([resA, resB]) =&gt; {console.log(resA.data)
    console.log(resB.data)
  })

const fakeConfig = {
  baseURL: 'https://www.baidu.com/',
  url: '/user/12345',
  params: {
    idClient: 1,
    idTest: 2,
    testString: 'thisIsATest'
  }
}
console.log(axios.getUri(fakeConfig))
</code></pre>
<p>这里我们通过 <code>axios.all</code> 同时发出了 2 个请求，返回了 <code>Promise</code> 数组，，我们可以在 <code>axios.spread</code> 的参数函数中拿到结果，也可以直接在 then 函数的参数函数中拿到结果。另外，我们可以根据 <code>axios.getUri</code> 方法在不发送请求的情况下根据配置得到最终请求的 url 结果。</p>
<p>至此，<code>ts-axios</code> 就实现了官网 axios 库在浏览器端的所有需求。如果你学到了这里，先为自己鼓个掌吧，因为我们已经获得了阶段性的学习成果了。</p>
<p>目前为止，我们对于所写代码的验证都是通过 demo 的方式，但是 demo 毕竟难以覆盖所有场景和代码分支，为了保证代码的正确性，我们还需要更科学的方式。从下一章开始，我们会学习编写单元测试，通过单元测试的方式来保证我们的代码正确性。</p>
<h1><a id="%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单元测试</h1>
<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>单元测试是前端一个很重要的方向，鉴别一个开源库是否靠谱的一个标准是它的单元测试是否完善。有了完整的单元测试，未来你去重构现有代码或者是增加新的需求都会有十足的把握不出现 regression bug。</p>
<p>在前面的章节，我们已经编写完成 ts-axios 库的代码，并通过 demo 的形式简单地对一些功能做了验证，但是 demo 可以走到的代码分支，覆盖的场景都是极其有限的。为了用更科学的手段保证我们代码的可靠性，我们需要去编写单元测试，并尽可能达到 99% 以上的测试覆盖率。</p>
<p>这门课我们会使用开源测试框架 <a href="https://jestjs.io/en/">Jest</a>，它是 Facebook 出品的一个测试框架，相对其他测试框架，它的一大特点就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。</p>
<p>由于时间有限，我不会带大家一行行手敲测试代码，但我会把所有的知识点和测试代码都带大家过一遍，确保大家都能够学会。但是我希望你们在学习的过程中，能自己手敲这些测试代码，这样有助于你们学习和巩固。</p>
<p>通过这一章节的学习，我希望你们能够学会使用 Jest 去对 JS 库或者是 TS 库编写单元测试，并能把所学应用到你们的实际项目中。给自己的代码添加完整的测试代码也是一个非常好的开发习惯，虽然枯燥但十分实用，如果养成这些好习惯会有助于提升你的行业竞争力，所以希望大家虽然把代码实现了，也不要太骄傲，耐心把单元测试写好。</p>
<p>那么接下来就让我们开启单元测试之旅。</p>
<h2><a id="jest%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Jest 安装和配置</h2>
<h3><a id="jest%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Jest 安装</h3>
<p>由于我们的项目是使用 <code>typescript-library-starter</code> 初始化的，已经内置了 Jest 的安装，但是安装的版本却不是最新的，我们可以对 <code>package.json</code> 中的相关依赖版本做修改，重新安装。</p>
<pre><code class="language-json">{
  &quot;@types/jest&quot;: &quot;^24.0.13&quot;,
  &quot;jest&quot;: &quot;^24.8.0&quot;,
  &quot;jest-config&quot;: &quot;^24.8.0&quot;,
  &quot;ts-jest&quot;: &quot;^24.0.2&quot;,
  &quot;typescript&quot;: &quot;^3.4.5&quot;
}
</code></pre>
<blockquote>
<p>注意，这里都是目前最新的版本，未来如果有版本升级的话，可以自行更新到最新版本。</p>
</blockquote>
<p>更改版本后，在命令行再次执行 <code>npm install</code> 即可安装到相应版本。</p>
<h3><a id="jest%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Jest 配置</h3>
<p>在 <code>package.json</code> 文件中有 <code>jest</code> 字段，对应 Jest 配置：</p>
<pre><code class="language-json">&quot;jest&quot;: {
  &quot;transform&quot;: {&quot;.(ts|tsx)&quot;: &quot;ts-jest&quot;
  },
  &quot;testEnvironment&quot;: &quot;jsdom&quot;,
  &quot;testRegex&quot;: &quot;/test/.*\\.(test|spec)\\.(ts)$&quot;,
  &quot;moduleFileExtensions&quot;: [
    &quot;ts&quot;,
    &quot;tsx&quot;,
    &quot;js&quot;
  ],
  &quot;coverageThreshold&quot;: {
    &quot;global&quot;: {
      &quot;branches&quot;: 90,
      &quot;functions&quot;: 95,
      &quot;lines&quot;: 95,
      &quot;statements&quot;: 95
    }
  },
  &quot;collectCoverageFrom&quot;: [&quot;src/*.{js,ts}&quot;,
    &quot;src/**/*.{js,ts}&quot;
  ],
  &quot;setupFilesAfterEnv&quot;: [&quot;&lt;rootDir&gt;/test/boot.ts&quot;]
},
</code></pre>
<p>接下来，我们就分别来看这几个配置的含义。</p>
<ul>
<li><a href="https://jestjs.io/docs/en/configuration#transform-object-string-string">transform</a></li>
</ul>
<p>简单地说就是一种转换器配置，比如我们这里的</p>
<pre><code class="language-json">&quot;transform&quot;: {&quot;.(ts|tsx)&quot;: &quot;ts-jest&quot;
},
</code></pre>
<p>表示的就是使用 <code>ts-jest</code> 工具把 <code>.ts</code> 和 <code>.tsx</code> 文件内容转换成 JavaScript，因为我们也是使用 TypeScript 编写测试代码，而 Node.js 是不能直接支持 TypeScript 的，所以需要配置转换器。</p>
<ul>
<li><a href="https://jestjs.io/docs/en/configuration#testenvironment-string">testEnvironment</a></li>
</ul>
<p>测试环境。</p>
<pre><code class="language-json">&quot;testEnvironment&quot;: &quot;jsdom&quot;
</code></pre>
<p>表示它是一个类浏览器的测试环境，我们可以使用浏览器环境中的一些 API。</p>
<ul>
<li><a href="https://jestjs.io/docs/en/configuration#testregex-string-array-string">testRegex</a></li>
</ul>
<p>要测试文件的正则表达式。</p>
<pre><code class="language-json">&quot;testRegex&quot;: &quot;/test/.*\\.(test|spec)\\.(ts)$&quot;
</code></pre>
<p>表示 <code>test</code> 目录下所有以 <code>.test.ts</code> 和 <code>.spec.ts</code> 的文件都需要跑测试。</p>
<ul>
<li><a href="https://jestjs.io/docs/en/configuration#modulefileextensions-array-string">moduleFileExtensions</a></li>
</ul>
<p>模块文件扩展名，当你去引入一个模块并没有指定扩展名的时候，它会依次尝试去添加这些扩展名去找你引入的模块文件。</p>
<pre><code class="language-json">&quot;moduleFileExtensions&quot;: [
  &quot;ts&quot;,
  &quot;tsx&quot;,
  &quot;js&quot;
]
</code></pre>
<p>表示优先找 <code>.ts</code> 的模块、然后是 <code>.tsx</code>，最后是 <code>.js</code>。</p>
<ul>
<li><a href="https://jestjs.io/docs/en/configuration#coveragethreshold-object">coverageThreshold</a></li>
</ul>
<p>测试覆盖率的阈值设定，当我们的测试覆盖率达不到阈值的时候，测试会失败。</p>
<pre><code class="language-json">&quot;coverageThreshold&quot;: {
  &quot;global&quot;: {
    &quot;branches&quot;: 90,
    &quot;functions&quot;: 95,
    &quot;lines&quot;: 95,
    &quot;statements&quot;: 95
  }
}
</code></pre>
<p>表示全局的代码分支覆盖率要达到 <code>90%</code>，方法覆盖率要达到 <code>95%</code>，代码行数覆盖率达到 <code>95%</code>，声明覆盖率达到 <code>95%</code>。</p>
<ul>
<li><a href="https://jestjs.io/docs/en/configuration#collectcoveragefrom-array">collectCoverageFrom</a></li>
</ul>
<p>收集指定文件的测试覆盖率(即使你没为这些文件编写测试)，它的值为 <a href="https://github.com/jonschlinkert/micromatch">glob patterns</a> 类型。</p>
<pre><code class="language-json">&quot;collectCoverageFrom&quot;: [&quot;src/*.{js,ts}&quot;,
  &quot;src/**/*.{js,ts}&quot;
]
</code></pre>
<p>表示收集 <code>src</code> 目录以及它的所有子目录中的 <code>js</code> 和 <code>ts</code> 文件的测试覆盖率。</p>
<ul>
<li><a href="https://jestjs.io/docs/en/configuration#setupfilesafterenv-array">setupFilesAfterEnv</a></li>
</ul>
<p>测试框架安装后立即执行的代码文件列表。</p>
<pre><code class="language-json">&quot;setupFilesAfterEnv&quot;: [&quot;&lt;rootDir&gt;/test/boot.ts&quot;]
</code></pre>
<p>表示每次跑具体测试代码之前会先运行 <code>&lt;rootDir&gt;/test/boot.ts</code> 中的代码，<code>&lt;rootDir&gt;</code> 表示当前项目的根目录。这个配置在之后的章节我们会具体介绍。</p>
<p>其他关于 Jest 的配置，感兴趣的同学可以去 <a href="https://jestjs.io/docs/en/configuration">官网</a> 做扩展学习。</p>
<p>至此，我们学习了 Jest 的安装和配置，下节课我们就开始编写 <code>ts-axios</code> 库的单元测试。</p>
<h2><a id="%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>辅助模块单元测试</h2>
<h3><a id="%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>准备工作</h3>
<p>通常我们会优先为一个库的辅助方法编写测试，我们会优先为 <code>ts-axios</code> 库的 <code>helpers</code> 目录下的模块编写测试。我们在 <code>test</code> 目录下创建一个 <code>helpers</code> 目录，创建一个 <code>boot.ts</code> 空文件，这个是因为我们上节课给 Jest 配置了 <code>setupFilesAfterEnv</code> 指向了这个文件，后面的章节我们会编写这个文件。</p>
<p>然后我们可以在控制台运行 <code>npm test</code>，它实际上是执行了 <code>jest --coverage</code> 来跑单元测试，我们会发现它会报错，没有匹配的测试文件，那是因为我们还没有在 <code>test</code> 目录下编写任何一个 .spec.ts 结尾的测试文件。接下来我们就来为这些辅助模块编写相应的测试。</p>
<h3><a id="util%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>util 模块测试</h3>
<p><code>test/helpers/util.spec.ts</code>：</p>
<pre><code class="language-typescript">import {
  isDate,
  isPlainObject,
  isFormData,
  isURLSearchParams,
  extend,
  deepMerge
} from '../../src/helpers/util'

describe('helpers:util', () =&gt; {describe('isXX', () =&gt; {test('should validate Date', () =&gt; {expect(isDate(new Date())).toBeTruthy()expect(isDate(Date.now())).toBeFalsy()})

    test('should validate PlainObject', () =&gt; {expect(isPlainObject({})).toBeTruthy()expect(isPlainObject(new Date())).toBeFalsy()})

    test('should validate FormData', () =&gt; {expect(isFormData(new FormData())).toBeTruthy()expect(isFormData({})).toBeFalsy()})

    test('should validate URLSearchParams', () =&gt; {expect(isURLSearchParams(new URLSearchParams())).toBeTruthy()expect(isURLSearchParams('foo=1&amp;bar=2')).toBeFalsy()})
  })describe('extend', () =&gt; {test('should be mutable', () =&gt; {const a = Object.create(null)
      const b = {foo: 123}

      extend(a, b)

      expect(a.foo).toBe(123)
    })test('should extend properties', function() {const a = { foo: 123, bar: 456}
      const b = {bar: 789}
      const c = extend(a, b)

      expect(c.foo).toBe(123)
      expect(c.bar).toBe(789)
    })})

  describe('deepMerge', () =&gt; {test('should be immutable', () =&gt; {const a = Object.create(null)
      const b: any = {foo: 123}
      const c: any = {bar: 456}

      deepMerge(a, b, c)

      expect(typeof a.foo).toBe('undefined')
      expect(typeof a.bar).toBe('undefined')
      expect(typeof b.bar).toBe('undefined')
      expect(typeof c.foo).toBe('undefined')
    })test('should deepMerge properties', () =&gt; {const a = { foo: 123}
      const b = {bar: 456}
      const c = {foo: 789}
      const d = deepMerge(a, b, c)

      expect(d.foo).toBe(789)
      expect(d.bar).toBe(456)
    })test('should deepMerge recursively', function() {const a = { foo: { bar: 123} }
      const b = {foo: { baz: 456}, bar: {qux: 789} }
      const c = deepMerge(a, b)

      expect(c).toEqual({
        foo: {
          bar: 123,
          baz: 456
        },
        bar: {qux: 789}
      })})

    test('should remove all references from nested objects', () =&gt; {const a = { foo: { bar: 123} }
      const b = {}
      const c = deepMerge(a, b)

      expect(c).toEqual({
        foo: {bar: 123}
      })expect(c.foo).not.toBe(a.foo)
    })test('should handle null and undefined arguments', () =&gt; {expect(deepMerge(undefined, undefined)).toEqual({})
      expect(deepMerge(undefined, { foo: 123})).toEqual({foo: 123})
      expect(deepMerge({ foo: 123}, undefined)).toEqual({ foo: 123})

      expect(deepMerge(null, null)).toEqual({})
      expect(deepMerge(null, { foo: 123})).toEqual({foo: 123})
      expect(deepMerge({ foo: 123}, null)).toEqual({ foo: 123})
    })})
})
</code></pre>
<p>其中 <a href="https://jestjs.io/docs/en/api#describename-fn"><code>describe</code></a> 方法用来定义一组测试，它可以支持嵌套，<a href="https://jestjs.io/docs/en/api#testname-fn-timeout"><code>test</code></a> 函数是用来定义单个测试用例，它是测试的最小单元。<a href="https://jestjs.io/docs/en/expect#expectvalue"><code>expect</code></a> 是断言函数，所谓 &quot;断言&quot;，就是判断代码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。</p>
<p>测试文件编写好后，我们可以去控制台运行一次 <code>npm test</code>，看一下测试结果，我们可以看跑了几个测试文件，测试是否通过，测试覆盖率等。</p>
<h3><a id="cookie%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cookie 模块测试</h3>
<p><code>test/helpers/cookie.spec.ts</code>：</p>
<pre><code class="language-typescript">import cookie from '../../src/helpers/cookie'

describe('helpers:cookie', () =&gt; {test('should read cookies', () =&gt; {
    document.cookie = 'foo=baz'
    expect(cookie.read('foo')).toBe('baz')
  })test('should return null if cookie name is not exist', () =&gt; {
    document.cookie = 'foo=baz'
    expect(cookie.read('bar')).toBeNull()})
})
</code></pre>
<p>这里我们可以通过 <code>document.cookie</code> 去设置 cookie，就像在浏览器里一样操作。</p>
<h3><a id="data%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>data 模块测试</h3>
<p><code>test/helpers/data.spec.ts</code>：</p>
<pre><code class="language-typescript">import {transformRequest, transformResponse} from '../../src/helpers/data'

describe('helpers:data', () =&gt; {describe('transformRequest', () =&gt; {test('should transform request data to string if data is a PlainObject', () =&gt; {const a = { a: 1}
      expect(transformRequest(a)).toBe('{&quot;a&quot;:1}')})

    test('should do nothing if data is not a PlainObject', () =&gt; {const a = new URLSearchParams('a=b')
      expect(transformRequest(a)).toBe(a)
    })})

  describe('transformResponse', () =&gt; {test('should transform response data to Object if data is a JSON string', () =&gt; {const a = '{&quot;a&quot;: 2}'
      expect(transformResponse(a)).toEqual({a: 2})
    })test('should do nothing if data is a string but not a JSON string', () =&gt; {const a = '{a: 2}'
      expect(transformResponse(a)).toBe('{a: 2}')})

    test('should do nothing if data is not a string', () =&gt; {const a = { a: 2}
      expect(transformResponse(a)).toBe(a)
    })})
})
</code></pre>
<h3><a id="error%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>error 模块测试</h3>
<p><code>test/helpers/error.spec.ts</code>：</p>
<pre><code class="language-typescript">import {createError} from '../../src/helpers/error'
import {AxiosRequestConfig, AxiosResponse} from '../../src/types'

describe('helpers::error', function() {test('should create an Error with message, config, code, request, response and isAxiosError', () =&gt; {const request = new XMLHttpRequest()
    const config: AxiosRequestConfig = {method: 'post'}
    const response: AxiosResponse = {
      status: 200,
      statusText: 'OK',
      headers: null,
      request,
      config,
      data: {foo: 'bar'}
    }
    const error = createError('Boom!', config, 'SOMETHING', request, response)
    expect(error instanceof Error).toBeTruthy()expect(error.message).toBe('Boom!')
    expect(error.config).toBe(config)
    expect(error.code).toBe('SOMETHING')
    expect(error.request).toBe(request)
    expect(error.response).toBe(response)
    expect(error.isAxiosError).toBeTruthy()})
})
</code></pre>
<p>该模块跑完我们会发现，分支覆盖率是在 <code>50%</code>，因为第十七行代码</p>
<pre><code class="language-typescript">super(message)
</code></pre>
<p>这个是 <code>super</code> 继承对测试覆盖率支持的坑，目前没有好的解决方案，可以先忽略。</p>
<h3><a id="headers%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>headers 模块测试</h3>
<p><code>test/helpers/headers.spec.ts</code>：</p>
<pre><code class="language-typescript">import {parseHeaders, processHeaders, flattenHeaders} from '../../src/helpers/headers'

describe('helpers:header', () =&gt; {describe('parseHeaders', () =&gt; {test('should parse headers', () =&gt; {
      const parsed = parseHeaders(
        'Content-Type: application/json\r\n' +
          'Connection: keep-alive\r\n' +
          'Transfer-Encoding: chunked\r\n' +
          'Date: Tue, 21 May 2019 09:23:44 GMT\r\n' +
          ':aa\r\n' +
          'key:'
      )expect(parsed['content-type']).toBe('application/json')
      expect(parsed['connection']).toBe('keep-alive')
      expect(parsed['transfer-encoding']).toBe('chunked')
      expect(parsed['date']).toBe('Tue, 21 May 2019 09:23:44 GMT')
      expect(parsed['key']).toBe('')
    })test('should return empty object if headers is empty string', () =&gt; {expect(parseHeaders('')).toEqual({})
    })})

  describe('processHeaders', () =&gt; {test('should normalize Content-Type header name', () =&gt; {
      const headers: any = {
        'conTenT-Type': 'foo/bar',
        'Content-length': 1024
      }
      processHeaders(headers, {})
      expect(headers['Content-Type']).toBe('foo/bar')
      expect(headers['conTenT-Type']).toBeUndefined()expect(headers['Content-length']).toBe(1024)
    })test('should set Content-Type if not set and data is PlainObject', () =&gt; {const headers: any = {}
      processHeaders(headers, { a: 1})
      expect(headers['Content-Type']).toBe('application/json;charset=utf-8')
    })test('should set not Content-Type if not set and data is not PlainObject', () =&gt; {const headers: any = {}
      processHeaders(headers, new URLSearchParams('a=b'))
      expect(headers['Content-Type']).toBeUndefined()})

    test('should do nothing if headers is undefined or null', () =&gt; {expect(processHeaders(undefined, {})).toBeUndefined()expect(processHeaders(null, {})).toBeNull()})
  })describe('flattenHeaders', () =&gt; {test('should flatten the headers and include common headers', () =&gt; {
      const headers = {
        Accept: 'application/json',
        common: {'X-COMMON-HEADER': 'commonHeaderValue'},
        get: {'X-GET-HEADER': 'getHeaderValue'},
        post: {'X-POST-HEADER': 'postHeaderValue'}
      }

      expect(flattenHeaders(headers, 'get')).toEqual({
        Accept: 'application/json',
        'X-COMMON-HEADER': 'commonHeaderValue',
        'X-GET-HEADER': 'getHeaderValue'
      })})

    test('should flatten the headers without common headers', () =&gt; {
      const headers = {
        Accept: 'application/json',
        get: {'X-GET-HEADER': 'getHeaderValue'}
      }

      expect(flattenHeaders(headers, 'patch')).toEqual({Accept: 'application/json'})
    })test('should do nothing if headers is undefined or null', () =&gt; {expect(flattenHeaders(undefined, 'get')).toBeUndefined()expect(flattenHeaders(null, 'post')).toBeNull()})
  })})
</code></pre>
<p>运行后，我们会发现 <code>parseHeaders</code> 测试组的 <code>should parse headers</code> 测试没通过，<code>expect(parsed['date']).toBe('Tue, 21 May 2019 09:23:44 GMT')</code> 我们期望解析后的 <code>date</code> 字段是 <code>Tue, 21 May 2019 09:23:44 GMT</code>，而实际的值是 <code>Tue, 21 May 2019 09</code>。</p>
<p>测试没通过，我们检查一下代码，发现我们 <code>parseHeaders</code> 的代码逻辑漏洞，我们只考虑了第一个 &quot;:&quot; 号，没考虑后半部分的字符串内部也可能有 &quot;:&quot;，按我们现有的逻辑就会把字符串中 &quot;:&quot; 后面部分都截断了。</p>
<p>因此我们修改 <code>parseHeaders</code> 的实现逻辑。</p>
<pre><code class="language-typescript">export function parseHeaders(headers: string): any {let parsed = Object.create(null)
  if (!headers) {return parsed}

  headers.split('\r\n').forEach(line =&gt; {let [key, ...vals] = line.split(':')
    key = key.trim().toLowerCase()
    if (!key) {return}
    let val = vals.join(':').trim()parsed[key] = val
  })return parsed}
</code></pre>
<p>这样我们再重新跑测试，就会通过了。</p>
<h3><a id="url%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>url 模块测试</h3>
<p><code>test/helpers/url.spec.ts</code>：</p>
<pre><code class="language-typescript">import {buildURL, isAbsoluteURL, combineURL, isURLSameOrigin} from '../../src/helpers/url'

describe('helpers:url', () =&gt; {describe('buildURL', () =&gt; {test('should support null params', () =&gt; {expect(buildURL('/foo')).toBe('/foo')
    })test('should support params', () =&gt; {
      expect(
        buildURL('/foo', {foo: 'bar'})
      ).toBe('/foo?foo=bar')
    })test('should ignore if some param value is null', () =&gt; {
      expect(
        buildURL('/foo', {
          foo: 'bar',
          baz: null
        })).toBe('/foo?foo=bar')
    })test('should ignore if the only param value is null', () =&gt; {
      expect(
        buildURL('/foo', {baz: null})
      ).toBe('/foo')
    })test('should support object params', () =&gt; {
      expect(
        buildURL('/foo', {
          foo: {bar: 'baz'}
        })).toBe('/foo?foo=' + encodeURI('{&quot;bar&quot;:&quot;baz&quot;}'))})

    test('should support date params', () =&gt; {const date = new Date()

      expect(
        buildURL('/foo', {date: date})
      ).toBe('/foo?date=' + date.toISOString())
    })test('should support array params', () =&gt; {
      expect(
        buildURL('/foo', {foo: ['bar', 'baz']
        })).toBe('/foo?foo[]=bar&amp;foo[]=baz')
    })test('should support special char params', () =&gt; {
      expect(
        buildURL('/foo', {foo: '@:$,'})
      ).toBe('/foo?foo=@:$,+')
    })test('should support existing params', () =&gt; {
      expect(
        buildURL('/foo?foo=bar', {bar: 'baz'})
      ).toBe('/foo?foo=bar&amp;bar=baz')
    })test('should correct discard url hash mark', () =&gt; {
      expect(
        buildURL('/foo?foo=bar#hash', {query: 'baz'})
      ).toBe('/foo?foo=bar&amp;query=baz')
    })test('should use serializer if provided', () =&gt; {const serializer = jest.fn(() =&gt; {return 'foo=bar'})
      const params = {foo: 'bar'}
      expect(buildURL('/foo', params, serializer)).toBe('/foo?foo=bar')
      expect(serializer).toHaveBeenCalled()expect(serializer).toHaveBeenCalledWith(params)
    })test('should support URLSearchParams', () =&gt; {expect(buildURL('/foo', new URLSearchParams('bar=baz'))).toBe('/foo?bar=baz')
    })})

  describe('isAbsoluteURL', () =&gt; {test('should return true if URL begins with valid scheme name', () =&gt; {expect(isAbsoluteURL('https://api.github.com/users')).toBeTruthy()expect(isAbsoluteURL('custom-scheme-v1.0://example.com/')).toBeTruthy()expect(isAbsoluteURL('HTTP://example.com/')).toBeTruthy()})

    test('should return false if URL begins with invalid scheme name', () =&gt; {expect(isAbsoluteURL('123://example.com/')).toBeFalsy()expect(isAbsoluteURL('!valid://example.com/')).toBeFalsy()})

    test('should return true if URL is protocol-relative', () =&gt; {expect(isAbsoluteURL('//example.com/')).toBeTruthy()})

    test('should return false if URL is relative', () =&gt; {expect(isAbsoluteURL('/foo')).toBeFalsy()expect(isAbsoluteURL('foo')).toBeFalsy()})
  })describe('combineURL', () =&gt; {test('should combine URL', () =&gt; {expect(combineURL('https://api.github.com', '/users')).toBe('https://api.github.com/users')
    })test('should remove duplicate slashes', () =&gt; {expect(combineURL('https://api.github.com/', '/users')).toBe('https://api.github.com/users')
    })test('should insert missing slash', () =&gt; {expect(combineURL('https://api.github.com', 'users')).toBe('https://api.github.com/users')
    })test('should not insert slash when relative url missing/empty', () =&gt; {expect(combineURL('https://api.github.com/users', '')).toBe('https://api.github.com/users')
    })test('should allow a single slash for relative url', () =&gt; {expect(combineURL('https://api.github.com/users', '/')).toBe('https://api.github.com/users/')
    })})

  describe('isURLSameOrigin', () =&gt; {test('should detect same origin', () =&gt; {expect(isURLSameOrigin(window.location.href)).toBeTruthy()})

    test('should detect different origin', () =&gt; {expect(isURLSameOrigin('https://github.com/axios/axios')).toBeFalsy()})
  })})
</code></pre>
<p>这里要注意的是，我们使用了 <a href="https://jestjs.io/docs/en/jest-object#jestfnimplementation"><code>jest.fn</code></a> 去模拟了一个函数，这个也是在编写 Jest 测试中非常常用的一个 API。</p>
<p>至此，我们就实现了 <code>ts-axios</code> 库 <code>helpers</code> 目录下所有模块的测试，并把该目录下的测试覆盖率达到了近乎 100% 的覆盖率。下面的章节我们就开始测试 <code>ts-axios</code> 的核心流程，针对不同的 <code>feature</code> 去编写单元测试了。</p>
<h2><a id="%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>请求模块单元测试</h2>
<p>请求模块是 axios 最基础的模块，通过一个 axios 方法发送 Ajax 请求。</p>
<h3><a id="jasmine-ajax" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>jasmine-ajax</h3>
<p><a href="https://jasmine.github.io/pages/getting_started.html">Jasmine</a> 是一个 BDD(行为驱动开发)的测试框架，它有很多成熟的插件，比如我们要用到的 <a href="https://github.com/jasmine/jasmine-ajax"><code>jasmine-ajax</code></a>，它会为我们发出的 Ajax 请求根据规范定义一组假的响应，并跟踪我们发出的 Ajax 请求，可以让我们方便的为结果做断言。</p>
<p>其实 Jest 也可以去写插件，但并没有现成的 Ajax 相关的 Jest 插件，但是 Jest 测试中我们仍然可以使用 Jasmine 相关的插件，只需要做一些小小的配置即可。</p>
<p>当然，未来我也会考虑去编写一个 Ajax 相关的 Jest 插件，目前我们仍然使用 <code>jasmine-ajax</code> 去配合我们编写测试。</p>
<p><code>jasmine-ajax</code> 依赖 <code>jasmine-core</code>，因此首先我们要安装几个依赖包，<code>jasmine-ajax</code>、<code>jasmine-core</code> 和 <code>@types/jasmine-ajax</code>。</p>
<p>这个时候我们需要去修改 <code>test/boot.ts</code> 文件，因为每次跑具体测试代码之前会先运行该文件，我们可以在这里去初始化 <code>jasmine-ajax</code>。</p>
<pre><code class="language-typescript">const JasmineCore = require('jasmine-core')
// @ts-ignore
global.getJasmineRequireObj = function() {return JasmineCore}
require('jasmine-ajax')
</code></pre>
<p>这里为了让 <code>jasmine-ajax</code> 插件运行成功，我们需要手动添加全局的 <code>getJasmineRequireObj</code> 方法，参考 <a href="https://github.com/jasmine/jasmine-ajax/issues/178">issue</a>。</p>
<p>接下来，我们就开始编写请求模块的单元测试。</p>
<h3><a id="%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>测试代码编写</h3>
<p><code>test/requests.spec.ts</code>：</p>
<pre><code class="language-typescript">import axios, {AxiosResponse, AxiosError} from '../src/index'
import {getAjaxRequest} from './helper'

describe('requests', () =&gt; {beforeEach(() =&gt; {jasmine.Ajax.install()
  })afterEach(() =&gt; {jasmine.Ajax.uninstall()
  })test('should treat single string arg as url', () =&gt; {axios('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.url).toBe('/foo')
      expect(request.method).toBe('GET')
    })})

  test('should treat method value as lowercase string', done =&gt; {
    axios({
      url: '/foo',
      method: 'POST'
    }).then(response =&gt; {expect(response.config.method).toBe('post')
      done()})

    getAjaxRequest().then(request =&gt; {
      request.respondWith({status: 200})
    })})

  test('should reject on network errors', done =&gt; {const resolveSpy = jest.fn((res: AxiosResponse) =&gt; {return res})

    const rejectSpy = jest.fn((e: AxiosError) =&gt; {return e})

    jasmine.Ajax.uninstall()axios('/foo')
      .then(resolveSpy)
      .catch(rejectSpy)
      .then(next)

    function next(reason: AxiosResponse | AxiosError) {expect(resolveSpy).not.toHaveBeenCalled()expect(rejectSpy).toHaveBeenCalled()expect(reason instanceof Error).toBeTruthy()expect((reason as AxiosError).message).toBe('Network Error')
      expect(reason.request).toEqual(expect.any(XMLHttpRequest))

      jasmine.Ajax.install()done()
    }
  })

  test('should reject when request timeout', done =&gt; {
    let err: AxiosError

    axios('/foo', {
      timeout: 2000,
      method: 'post'
    }).catch(error =&gt; {err = error})

    getAjaxRequest().then(request =&gt; {
      // @ts-ignore
      request.eventBus.trigger('timeout')

      setTimeout(() =&gt; {expect(err instanceof Error).toBeTruthy()expect(err.message).toBe('Timeout of 2000 ms exceeded')
        done()}, 100)
    })})

  test('should reject when validateStatus returns false', done =&gt; {const resolveSpy = jest.fn((res: AxiosResponse) =&gt; {return res})

    const rejectSpy = jest.fn((e: AxiosError) =&gt; {return e})

    axios('/foo', {validateStatus(status) {return status !== 500}
    }).then(resolveSpy)
      .catch(rejectSpy)
      .then(next)

    getAjaxRequest().then(request =&gt; {
      request.respondWith({status: 500})
    })function next(reason: AxiosError | AxiosResponse) {expect(resolveSpy).not.toHaveBeenCalled()expect(rejectSpy).toHaveBeenCalled()expect(reason instanceof Error).toBeTruthy()expect((reason as AxiosError).message).toBe('Request failed with status code 500')
      expect((reason as AxiosError).response!.status).toBe(500)

      done()}})

  test('should resolve when validateStatus returns true', done =&gt; {const resolveSpy = jest.fn((res: AxiosResponse) =&gt; {return res})

    const rejectSpy = jest.fn((e: AxiosError) =&gt; {return e})

    axios('/foo', {validateStatus(status) {return status === 500}
    }).then(resolveSpy)
      .catch(rejectSpy)
      .then(next)

    getAjaxRequest().then(request =&gt; {
      request.respondWith({status: 500})
    })function next(res: AxiosResponse | AxiosError) {expect(resolveSpy).toHaveBeenCalled()expect(rejectSpy).not.toHaveBeenCalled()expect(res.config.url).toBe('/foo')

      done()}})

  test('should return JSON when resolved', done =&gt; {
    let response: AxiosResponse

    axios('/api/account/signup', {
      auth: {
        username: '',
        password: ''
      },
      method: 'post',
      headers: {Accept: 'application/json'}
    }).then(res =&gt; {response = res})

    getAjaxRequest().then(request =&gt; {
      request.respondWith({
        status: 200,
        statusText: 'OK',
        responseText: '{&quot;a&quot;: 1}'
      })setTimeout(() =&gt; {expect(response.data).toEqual({a: 1})
        done()}, 100)
    })})

  test('should return JSON when rejecting', done =&gt; {
    let response: AxiosResponse

    axios('/api/account/signup', {
      auth: {
        username: '',
        password: ''
      },
      method: 'post',
      headers: {Accept: 'application/json'}
    }).catch(error =&gt; {response = error.response})

    getAjaxRequest().then(request =&gt; {
      request.respondWith({
        status: 400,
        statusText: 'Bad Request',
        responseText: '{&quot;error&quot;:&quot;BAD USERNAME&quot;,&quot;code&quot;: 1}'
      })setTimeout(() =&gt; {expect(typeof response.data).toBe('object')
        expect(response.data.error).toBe('BAD USERNAME')
        expect(response.data.code).toBe(1)
        done()}, 100)
    })})

  test('should supply correct response', done =&gt; {
    let response: AxiosResponse

    axios.post('/foo').then(res =&gt; {response = res})

    getAjaxRequest().then(request =&gt; {
      request.respondWith({
        status: 200,
        statusText: 'OK',
        responseText: '{&quot;foo&quot;:&quot;bar&quot;}',
        responseHeaders: {'Content-Type': 'application/json'}
      })setTimeout(() =&gt; {expect(response.data.foo).toBe('bar')
        expect(response.status).toBe(200)
        expect(response.statusText).toBe('OK')
        expect(response.headers['content-type']).toBe('application/json')
        done()}, 100)
    })})

  test('should allow overriding Content-Type header case-insensitive', () =&gt; {
    let response: AxiosResponse

    axios
      .post(
        '/foo',
        {prop: 'value'},
        {
          headers: {'content-type': 'application/json'}
        }
      )
      .then(res =&gt; {response = res})

    return getAjaxRequest().then(request =&gt; {expect(request.requestHeaders['Content-Type']).toBe('application/json')
    })})
})
</code></pre>
<p>我们要注意的一些点，在这里列出：</p>
<ul>
<li>beforeEach &amp; afterEach</li>
</ul>
<p><a href="https://jestjs.io/docs/en/api#beforeeachfn-timeout">beforeEach</a>表示每个测试用例运行前的钩子函数，在这里我们执行 <code>jasmine.Ajax.install()</code> 安装 <code>jasmine.Ajax</code>。</p>
<p><a href="https://jestjs.io/docs/en/api#aftereachfn-timeout">afterEach</a>表示每个测试用例运行后的钩子函数，在这里我们执行 <code>jasmine.Ajax.uninstall()</code> 卸载 <code>jasmine.Ajax</code>。</p>
<ul>
<li><code>getAjaxRequest</code></li>
</ul>
<p><code>getAjaxRequest</code> 是我们在 <code>test/helper.ts</code> 定义的一个辅助方法，通过 <code>jasmine.Ajax.requests.mostRecent()</code> 拿到最近一次请求的 <code>request</code> 对象，这个 <code>request</code> 对象是 <code>jasmine-ajax</code> 库伪造的 <code>xhr</code> 对象，它模拟了 <code>xhr</code> 对象上的方法，并且提供一些 <code>api</code> 让我们使用，比如 <code>request.respondWith</code> 方法返回一个响应。</p>
<ul>
<li>异步测试</li>
</ul>
<p>注意到我们这里大部分的测试用例不再是同步的代码了，几乎都是一些异步逻辑，Jest 非常好地支持<a href="https://jestjs.io/docs/en/asynchronous">异步测试代码</a>。通常有 2 种解决方案。</p>
<p>第一种是利用 <code>done</code> 参数，每个测试用例函数有一个 <code>done</code> 参数，一旦我们使用了该参数，只有当 <code>done</code> 函数执行的时候表示这个测试用例结束。</p>
<p>第二种是我们的测试函数返回一个 Promise 对象，一旦这个 Promise 对象 <code>resolve</code> 了，表示这个测试结束。</p>
<ul>
<li>expect.any(constructor)</li>
</ul>
<p>它表示匹配任意由 <code>constructor</code> 创建的对象实例。</p>
<ul>
<li><code>request.eventBus.trigger</code></li>
</ul>
<p>由于 <code>request.responseTimeout</code> 方法内部依赖了 <code>jasmine.clock</code> 方法会导致运行失败，这里我直接用了 <code>request.eventBus.trigger('timeout')</code> 方法触发了 <code>timeout</code> 事件。因为这个方法不在接口定义中，所以需要加 <code>// @ts-ignore</code>。</p>
<p>另外，我们在测试中发现 2 个 case 没有通过。</p>
<p>第一个是 <code>should treat method value as lowercase string</code>，这个测试用例是我们发送请求的 <code> method</code> 需要转换成小写字符串，这么做的目的也是为了之后 <code>flattenHeaders</code> 能正常处理这些 <code>method</code>，所以我们需要修改源码逻辑。</p>
<p><code>core/Axios.ts</code>：</p>
<pre><code class="language-typescript">  request(url: any, config?: any): AxiosPromise {if (typeof url === 'string') {if (!config) {config = {}
      }
      config.url = url
    } else {config = url}

    config = mergeConfig(this.defaults, config)
    config.method = config.method.toLowerCase()// ...}
</code></pre>
<p>在合并配置后，我们需要把 <code>config.method</code> 转成小写字符串。</p>
<p>另一个是 <code>should return JSON when rejecting</code>，这个测试用例是当我们发送请求失败后，也能把响应数据转换成 JSON 格式，所以也需要修改源码逻辑。</p>
<p><code>core/dispatchRequest.ts</code>：</p>
<pre><code class="language-typescript">export default function dispatchRequest(config: AxiosRequestConfig): AxiosPromise {throwIfCancellationRequested(config)
  processConfig(config)
  return xhr(config).then(
    res =&gt; {return transformResponseData(res)
    },
    e =&gt; {if (e &amp;&amp; e.response) {e.response = transformResponseData(e.response)
      }
      return Promise.reject(e)
    }
  )
}
</code></pre>
<p>除了对正常情况的响应数据做转换，我们也需要对异常情况的响应数据做转换。</p>
<p>至此我们完成了 <code>ts-axios</code> 库对请求模块的测试，下一节课我们会从业务的角度来测试 <code>headers</code> 模块。</p>
<h2><a id="headers%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>headers 模块单元测试</h2>
<p>之前我们测试了 <code>headers</code> 的基础方法模块，接下来我们会从业务角度测试 <code>headers</code> 的相关业务逻辑。</p>
<h3><a id="%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>测试代码编写</h3>
<p><code>test/headers.spec.ts</code>：</p>
<pre><code class="language-typescript">import axios from '../src/index'
import {getAjaxRequest} from './helper'

function testHeaderValue(headers: any, key: string, val?: string): void {
  let found = false

  for (let k in headers) {if (k.toLowerCase() === key.toLowerCase()) {
      found = true
      expect(headers[k]).toBe(val)
      break
    }
  }

  if (!found) {if (typeof val === 'undefined') {expect(headers.hasOwnProperty(key)).toBeFalsy() } else {throw new Error(key + 'was not found in headers')
    }
  }
}

describe('headers', () =&gt; {beforeEach(() =&gt; {jasmine.Ajax.install()
  })afterEach(() =&gt; {jasmine.Ajax.uninstall()
  })test('should use default common headers', () =&gt; {
    const headers = axios.defaults.headers.common

    axios('/foo')

    return getAjaxRequest().then(request =&gt; {for (let key in headers) {if (headers.hasOwnProperty(key)) {expect(request.requestHeaders[key]).toEqual(headers[key])
        }
      }
    })})

  test('should add extra headers for post', () =&gt; {axios.post('/foo', 'fizz=buzz')

    return getAjaxRequest().then(request =&gt; {testHeaderValue(request.requestHeaders, 'Content-Type', 'application/x-www-form-urlencoded')
    })})

  test('should use application/json when posting an object', () =&gt; {
    axios.post('/foo/bar', {
      firstName: 'foo',
      lastName: 'bar'
    })return getAjaxRequest().then(request =&gt; {testHeaderValue(request.requestHeaders, 'Content-Type', 'application/json;charset=utf-8')
    })})

  test('should remove content-type if data is empty', () =&gt; {axios.post('/foo')

    return getAjaxRequest().then(request =&gt; {testHeaderValue(request.requestHeaders, 'Content-Type', undefined)
    })})

  it('should preserve content-type if data is false', () =&gt; {axios.post('/foo', false)

    return getAjaxRequest().then(request =&gt; {testHeaderValue(request.requestHeaders, 'Content-Type', 'application/x-www-form-urlencoded')
    })})

  test('should remove content-type if data is FormData', () =&gt; {const data = new FormData()
    data.append('foo', 'bar')

    axios.post('/foo', data)

    return getAjaxRequest().then(request =&gt; {testHeaderValue(request.requestHeaders, 'Content-Type', undefined)
    })})
})
</code></pre>
<p>内部定义了 <code>testHeaderValue</code> 辅助函数，用于测试 <code>headers</code> 是否存在某个 <code>header name</code> 下的某个值。</p>
<p>至此我们完成了 <code>ts-axios</code> 库 <code>headers</code> 模块相关业务逻辑的测试，下一节课我们会对 <code>Axios</code> 的实例做测试。</p>
<h2><a id="axios%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Axios 实例模块单元测试</h2>
<p><code>ts-axios</code> 提供了 <code>axios.create</code> 静态方法，返回一个 <code>instance</code> 实例，我们需要对这个模块做测试。</p>
<h3><a id="%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>测试代码编写</h3>
<p><code>test/instance.spec.ts</code>：</p>
<pre><code class="language-typescript">import axios, {AxiosRequestConfig, AxiosResponse} from '../src/index'
import {getAjaxRequest} from './helper'

describe('instance', () =&gt; {beforeEach(() =&gt; {jasmine.Ajax.install()
  })afterEach(() =&gt; {jasmine.Ajax.uninstall()
  })test('should make a http request without verb helper', () =&gt; {const instance = axios.create()

    instance('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.url).toBe('/foo')
    })})

  test('should make a http request', () =&gt; {const instance = axios.create()

    instance.get('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.url).toBe('/foo')
      expect(request.method).toBe('GET')
    })})

  test('should make a post request', () =&gt; {const instance = axios.create()

    instance.post('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.method).toBe('POST')
    })})

  test('should make a put request', () =&gt; {const instance = axios.create()

    instance.put('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.method).toBe('PUT')
    })})

  test('should make a patch request', () =&gt; {const instance = axios.create()

    instance.patch('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.method).toBe('PATCH')
    })})

  test('should make a options request', () =&gt; {const instance = axios.create()

    instance.options('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.method).toBe('OPTIONS')
    })})

  test('should make a delete request', () =&gt; {const instance = axios.create()

    instance.delete('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.method).toBe('DELETE')
    })})

  test('should make a head request', () =&gt; {const instance = axios.create()

    instance.head('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.method).toBe('HEAD')
    })})

  test('should use instance options', () =&gt; {const instance = axios.create({ timeout: 1000})

    instance.get('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.timeout).toBe(1000)
    })})

  test('should have defaults.headers', () =&gt; {const instance = axios.create({ baseURL: 'https://api.example.com'})

    expect(typeof instance.defaults.headers).toBe('object')
    expect(typeof instance.defaults.headers.common).toBe('object')
  })

  test('should have interceptors on the instance', done =&gt; {
    axios.interceptors.request.use(config =&gt; {
      config.timeout = 2000
      return config
    })const instance = axios.create()

    instance.interceptors.request.use(config =&gt; {
      config.withCredentials = true
      return config
    })

    let response: AxiosResponse
    instance.get('/foo').then(res =&gt; {response = res})

    getAjaxRequest().then(request =&gt; {
      request.respondWith({status: 200})

      setTimeout(() =&gt; {expect(response.config.timeout).toEqual(0)
        expect(response.config.withCredentials).toEqual(true)
        done()}, 100)
    })})

  test('should get the computed uri', () =&gt; {
    const fakeConfig: AxiosRequestConfig = {
      baseURL: 'https://www.baidu.com/',
      url: '/user/12345',
      params: {
        idClient: 1,
        idTest: 2,
        testString: 'thisIsATest'
      }
    }
    expect(axios.getUri(fakeConfig)).toBe('https://www.baidu.com/user/12345?idClient=1&amp;idTest=2&amp;testString=thisIsATest')
  })})
</code></pre>
<p>至此我们完成了 <code>ts-axios</code> 库 <code>Axios</code> 实例模块相关业务逻辑的测试，下一节课我们会对拦截器模块做测试。</p>
<h2><a id="%E6%8B%A6%E6%88%AA%E5%99%A8%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拦截器模块单元测试</h2>
<p>拦截器是 <code>ts-axios</code> 库一个非常实用的功能，接下来我们来编写它的测试代码。</p>
<h3><a id="%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>测试代码编写</h3>
<p><code>test/interceptor.spec.ts</code>：</p>
<pre><code class="language-typescript">import axios, {AxiosRequestConfig, AxiosResponse} from '../src/index'
import {getAjaxRequest} from './helper'

describe('interceptors', () =&gt; {beforeEach(() =&gt; {jasmine.Ajax.install()
  })afterEach(() =&gt; {jasmine.Ajax.uninstall()
  })test('should add a request interceptor', () =&gt; {const instance = axios.create()

    instance.interceptors.request.use((config: AxiosRequestConfig) =&gt; {
      config.headers.test = 'added by interceptor'
      return config
    })instance('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.requestHeaders.test).toBe('added by interceptor')
    })})

  test('should add a request interceptor that returns a new config object', () =&gt; {const instance = axios.create()

    instance.interceptors.request.use(() =&gt; {
      return {
        url: '/bar',
        method: 'post'
      }
    })instance('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.method).toBe('POST')
      expect(request.url).toBe('/bar')
    })})

  test('should add a request interceptor that returns a promise', done =&gt; {const instance = axios.create()

    instance.interceptors.request.use((config: AxiosRequestConfig) =&gt; {
      return new Promise(resolve =&gt; {setTimeout(() =&gt; {
          config.headers.async = 'promise'
          resolve(config)
        }, 10)})
    })instance('/foo')

    setTimeout(() =&gt; {getAjaxRequest().then(request =&gt; {expect(request.requestHeaders.async).toBe('promise')
        done()})
    }, 100)})

  test('should add multiple request interceptors', () =&gt; {const instance = axios.create()

    instance.interceptors.request.use(config =&gt; {
      config.headers.test1 = '1'
      return config
    })
    instance.interceptors.request.use(config =&gt; {
      config.headers.test2 = '2'
      return config
    })
    instance.interceptors.request.use(config =&gt; {
      config.headers.test3 = '3'
      return config
    })instance('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.requestHeaders.test1).toBe('1')
      expect(request.requestHeaders.test2).toBe('2')
      expect(request.requestHeaders.test3).toBe('3')
    })})

  test('should add a response interceptor', done =&gt; {
    let response: AxiosResponse
    const instance = axios.create()

    instance.interceptors.response.use(data =&gt; {
      data.data = data.data + '- modified by interceptor'
      return data
    })instance('/foo').then(data =&gt; {response = data})

    getAjaxRequest().then(request =&gt; {
      request.respondWith({
        status: 200,
        responseText: 'OK'
      })setTimeout(() =&gt; {expect(response.data).toBe('OK - modified by interceptor')
        done()}, 100)
    })})

  test('should add a response interceptor that returns a new data object', done =&gt; {
    let response: AxiosResponse
    const instance = axios.create()instance.interceptors.response.use(() =&gt; {
      return {
        data: 'stuff',
        headers: null,
        status: 500,
        statusText: 'ERR',
        request: null,
        config: {}}
    })instance('/foo').then(res =&gt; {response = res})

    getAjaxRequest().then(request =&gt; {
      request.respondWith({
        status: 200,
        responseText: 'OK'
      })setTimeout(() =&gt; {expect(response.data).toBe('stuff')
        expect(response.headers).toBeNull()expect(response.status).toBe(500)
        expect(response.statusText).toBe('ERR')
        expect(response.request).toBeNull()expect(response.config).toEqual({})
        done()}, 100)
    })})

  test('should add a response interceptor that returns a promise', done =&gt; {
    let response: AxiosResponse
    const instance = axios.create()

    instance.interceptors.response.use(data =&gt; {
      return new Promise(resolve =&gt; {
        // do something async
        setTimeout(() =&gt; {
          data.data = 'you have been promised!'
          resolve(data)
        }, 10)})
    })instance('/foo').then(res =&gt; {response = res})

    getAjaxRequest().then(request =&gt; {
      request.respondWith({
        status: 200,
        responseText: 'OK'
      })setTimeout(() =&gt; {expect(response.data).toBe('you have been promised!')
        done()}, 100)
    })})

  test('should add multiple response interceptors', done =&gt; {
    let response: AxiosResponse
    const instance = axios.create()

    instance.interceptors.response.use(data =&gt; {
      data.data = data.data + '1'
      return data
    })
    instance.interceptors.response.use(data =&gt; {
      data.data = data.data + '2'
      return data
    })
    instance.interceptors.response.use(data =&gt; {
      data.data = data.data + '3'
      return data
    })instance('/foo').then(data =&gt; {response = data})

    getAjaxRequest().then(request =&gt; {
      request.respondWith({
        status: 200,
        responseText: 'OK'
      })setTimeout(() =&gt; {expect(response.data).toBe('OK123')
        done()}, 100)
    })})

  test('should allow removing interceptors', done =&gt; {
    let response: AxiosResponse
    let intercept
    const instance = axios.create()

    instance.interceptors.response.use(data =&gt; {
      data.data = data.data + '1'
      return data
    })
    intercept = instance.interceptors.response.use(data =&gt; {
      data.data = data.data + '2'
      return data
    })
    instance.interceptors.response.use(data =&gt; {
      data.data = data.data + '3'
      return data
    })instance.interceptors.response.eject(intercept)
    instance.interceptors.response.eject(5)

    instance('/foo').then(data =&gt; {response = data})

    getAjaxRequest().then(request =&gt; {
      request.respondWith({
        status: 200,
        responseText: 'OK'
      })setTimeout(() =&gt; {expect(response.data).toBe('OK13')
        done()}, 100)
    })})
})
</code></pre>
<p>运行测试后我们发现在测试用例 <code>should add a request interceptor that returns a new config object</code> 报错了，是代码运行的报错，而不是测试期望结果的报错，顺着报错信息，我们可以找到报错原因。</p>
<p>在 <code>core/xhr.ts</code> 中，执行到 <code>processHeaders</code> 中的 <code>Object.keys(headers).forEach</code> 代码报错，因为我们在拦截器对请求配置做了修改，导致 <code>headers</code> 为空，所以报错。</p>
<p>于是我们在解构赋值 <code>headers</code> 的时候，给它添加默认值即可。</p>
<pre><code class="language-typescript">const {
  // ...
  headers = {}} = config
</code></pre>
<p>再次运行测试，发现全部测试通过。</p>
<p>至此，我们完成了 <code>ts-axios</code> 库对拦截器模块的单元测试，下节课我们来测试 <code>mergeConfig</code> 模块的业务逻辑。</p>
<h2><a id="mergeconfig%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mergeConfig 模块单元测试</h2>
<p>合并配置是 <code>ts-axios</code> 核心流程中非常重要的一个环节，我们需要为它的各种情况去编写测试。</p>
<h3><a id="%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>测试代码编写</h3>
<p><code>test/mergeConfig.spec.ts</code>：</p>
<pre><code class="language-typescript">import axios from '../src/index'
import mergeConfig from '../src/core/mergeConfig'

describe('mergeConfig', () =&gt; {
  const defaults = axios.defaults

  test('should accept undefined for second argument', () =&gt; {expect(mergeConfig(defaults, undefined)).toEqual(defaults)
  })test('should accept an object for second argument', () =&gt; {expect(mergeConfig(defaults, {})).toEqual(defaults)
  })test('should not leave references', () =&gt; {const merged = mergeConfig(defaults, {})
    expect(merged).not.toBe(defaults)
    expect(merged.headers).not.toBe(defaults.headers)
  })test('should allow setting request options', () =&gt; {
    const config = {
      url: '__sample url__',
      params: '__sample params__',
      data: {foo: true}
    }
    const merged = mergeConfig(defaults, config)
    expect(merged.url).toBe(config.url)
    expect(merged.params).toBe(config.params)
    expect(merged.data).toEqual(config.data)
  })test('should not inherit request options', () =&gt; {
    const localDefaults = {
      url: '__sample url__',
      params: '__sample params__',
      data: {foo: true}
    }
    const merged = mergeConfig(localDefaults, {})
    expect(merged.url).toBeUndefined()expect(merged.params).toBeUndefined()expect(merged.data).toBeUndefined()})

  test('should return default headers if pass config2 with undefined', () =&gt; {
    expect(
      mergeConfig(
        {headers: 'x-mock-header'},
        undefined
      ) ).toEqual({headers: 'x-mock-header'})
  })test('should merge auth, headers with defaults', () =&gt; {
    expect(
      mergeConfig(
        {auth: undefined},
        {
          auth: {
            username: 'foo',
            password: 'test'
          }
        }
      ) ).toEqual({
      auth: {
        username: 'foo',
        password: 'test'
      }
    })
    expect(
      mergeConfig(
        {
          auth: {
            username: 'foo',
            password: 'test'
          }
        },
        {
          auth: {
            username: 'baz',
            password: 'foobar'
          }
        }
      ) ).toEqual({
      auth: {
        username: 'baz',
        password: 'foobar'
      }
    })})

  test('should overwrite auth, headers with a non-object value', () =&gt; {
    expect(
      mergeConfig(
        {
          headers: {
            common: {Accept: 'application/json, text/plain, */*'}
          }
        },
        {headers: null}
      ) ).toEqual({headers: null})
  })test('should allow setting other options', () =&gt; {
    const merged = mergeConfig(defaults, {timeout: 123})
    expect(merged.timeout).toBe(123)
  })})
</code></pre>
<p>运行测试后我们发现 <code>mergeConfig.ts</code> 文件的分支覆盖率并未达到 100%，提示是 23 行，打开文件后发现最后一个 <code>else</code> 逻辑并未走到，也就是 <code>val1</code> 为 <code>undefined</code> 的情况。但实际上即使 <code>val1</code> 为 <code>undefined</code>，我们也是返回 <code>undefined</code>，也就是返回 <code>val1</code>，所以这块代码的逻辑可以优化。</p>
<pre><code class="language-typescript">function deepMergeStrat(val1: any, val2: any): any {if (isPlainObject(val2)) {return deepMerge(val1, val2)
  } else if (typeof val2 !== 'undefined') {return val2} else if (isPlainObject(val1)) {return deepMerge(val1)
  } else {return val1}
}
</code></pre>
<p>2 个分支可以合并到一个分支，这样我们再次跑测试，分支覆盖率就可以达到 100% 了。</p>
<p>至此我们完成了 <code>ts-axios</code> 库对 <code>mergeConfig</code> 模块的测试，下一节课我们来测试取消模块相关代码。</p>
<h2><a id="%E8%AF%B7%E6%B1%82%E5%8F%96%E6%B6%88%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>请求取消模块单元测试</h2>
<p>请求取消模块是 <code>ts-axios</code> 库核心流程其中一个分支，也是非常重要的模块，我们将从基础库和业务流程模块 2 个方面去编写单元测试。</p>
<h3><a id="cancel%E7%B1%BB%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cancel 类单元测试</h3>
<p><code>cancel/Cancel.spec.ts</code>：</p>
<pre><code class="language-typescript">import Cancel, {isCancel} from '../../src/cancel/Cancel'

describe('cancel:Cancel', () =&gt; {test('should returns correct result when message is specified', () =&gt; {const cancel = new Cancel('Operation has been canceled.')
    expect(cancel.message).toBe('Operation has been canceled.')
  })test('should returns true if value is a Cancel', () =&gt; {expect(isCancel(new Cancel())).toBeTruthy()})

  test('should returns false if value is not a Cancel', () =&gt; {expect(isCancel({ foo: 'bar'})).toBeFalsy()})
})
</code></pre>
<h3><a id="canceltoken%E7%B1%BB%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CancelToken 类单元测试</h3>
<p><code>cancel/CancelToken.spec.ts</code>：</p>
<pre><code class="language-typescript">import CancelToken from '../../src/cancel/CancelToken'
import Cancel from '../../src/cancel/Cancel'
import {Canceler} from '../../src/types'

describe('CancelToken', () =&gt; {describe('reason', () =&gt; {test('should returns a Cancel if cancellation has been requested', () =&gt; {
      let cancel: Canceler
      let token = new CancelToken(c =&gt; {cancel = c})
      cancel!('Operation has been canceled.')
      expect(token.reason).toEqual(expect.any(Cancel))
      expect(token.reason!.message).toBe('Operation has been canceled.')
    })test('should has no side effect if call cancellation for multi times', () =&gt; {
      let cancel: Canceler
      let token = new CancelToken(c =&gt; {cancel = c})
      cancel!('Operation has been canceled.')
      cancel!('Operation has been canceled.')
      expect(token.reason).toEqual(expect.any(Cancel))
      expect(token.reason!.message).toBe('Operation has been canceled.')
    })test('should returns undefined if cancellation has not been requested', () =&gt; {const token = new CancelToken(() =&gt; {// do nothing})
      expect(token.reason).toBeUndefined()})
  })describe('promise', () =&gt; {
    test('should returns a Promise that resolves when cancellation is requested', done =&gt; {
      let cancel: Canceler
      const token = new CancelToken(c =&gt; {cancel = c})
      token.promise.then(value =&gt; {expect(value).toEqual(expect.any(Cancel))
        expect(value.message).toBe('Operation has been canceled.')
        done()})
      cancel!('Operation has been canceled.')
    })})

  describe('throwIfRequested', () =&gt; {test('should throws if cancellation has been requested', () =&gt; {
      let cancel: Canceler
      const token = new CancelToken(c =&gt; {cancel = c})
      cancel!('Operation has been canceled.')
      try {token.throwIfRequested()
        fail('Expected throwIfRequested to throw.')
      } catch (thrown) {if (!(thrown instanceof Cancel)) {fail('Expected throwIfRequested to throw a Cancel, but test threw' + thrown + '.')
        }
        expect(thrown.message).toBe('Operation has been canceled.')
      }
    })test('should does not throw if cancellation has not been requested', () =&gt; {const token = new CancelToken(() =&gt; {// do nothing})
      token.throwIfRequested()})
  })describe('source', () =&gt; {test('should returns an object containing token and cancel function', () =&gt; {const source = CancelToken.source()
      expect(source.token).toEqual(expect.any(CancelToken))
      expect(source.cancel).toEqual(expect.any(Function))
      expect(source.token.reason).toBeUndefined()source.cancel('Operation has been canceled.')
      expect(source.token.reason).toEqual(expect.any(Cancel))
      expect(source.token.reason!.message).toBe('Operation has been canceled.')
    })})
})
</code></pre>
<p>注意，这里我们使用了 <code>fail</code> 函数表示一个测试的失败，这个并未在 Jest 文档中体现，但它是一个可以用的 API。</p>
<h3><a id="cancel%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cancel 业务逻辑单元测试</h3>
<p><code>cancel.spec.ts</code>：</p>
<pre><code class="language-typescript">import axios from '../src/index'
import {getAjaxRequest} from './helper'

describe('cancel', () =&gt; {
  const CancelToken = axios.CancelToken
  const Cancel = axios.Cancel

  beforeEach(() =&gt; {jasmine.Ajax.install()
  })afterEach(() =&gt; {jasmine.Ajax.uninstall()
  })describe('when called before sending request', () =&gt; {test('should rejects Promise with a Cancel object', () =&gt; {const source = CancelToken.source()
      source.cancel('Operation has been canceled.')

      return axios
        .get('/foo', {cancelToken: source.token})
        .catch(reason =&gt; {expect(reason).toEqual(expect.any(Cancel))
          expect(reason.message).toBe('Operation has been canceled.')
        })})
  })describe('when called after request has been sent', () =&gt; {
    test('should rejects Promise with a Cancel object', done =&gt; {const source = CancelToken.source()
      axios
        .get('/foo/bar', {cancelToken: source.token})
        .catch(reason =&gt; {expect(reason).toEqual(expect.any(Cancel))
          expect(reason.message).toBe('Operation has been canceled.')
          done()})

      getAjaxRequest().then(request =&gt; {source.cancel('Operation has been canceled.')
        setTimeout(() =&gt; {
          request.respondWith({
            status: 200,
            responseText: 'OK'
          })}, 100)
      })})

    test('calls abort on request object', done =&gt; {const source = CancelToken.source()
      let request: any
      axios
        .get('/foo/bar', {cancelToken: source.token})
        .catch(() =&gt; {expect(request.statusText).toBe('abort')
          done()})

      getAjaxRequest().then(req =&gt; {source.cancel()
        request = req
      })})
  })describe('when called after response has been received', () =&gt; {
    test('should not cause unhandled rejection', done =&gt; {const source = CancelToken.source()
      axios
        .get('/foo', {cancelToken: source.token})
        .then(() =&gt; {window.addEventListener('unhandledrejection', () =&gt; {done.fail('Unhandled rejection.')
          })source.cancel()
          setTimeout(done, 100)
        })getAjaxRequest().then(request =&gt; {
        request.respondWith({
          status: 200,
          responseText: 'OK'
        })})
    })})
})
</code></pre>
<p>注意这里我们使用了 <code>done.fail</code> 表示了一个异常的结束，这个并未在 Jest 文档中体现，但它是一个可以用的 API。</p>
<p>至此，我们完成了取消模块相关业务逻辑的单元测试，我们测试覆盖率达到了阈值，测试已经通过了。但是扔未达到我们的目标，还有很多 feature 是没有覆盖到的。接下来我们就完成剩余 feature 的编写单元测试。</p>
<h2><a id="%E5%89%A9%E4%BD%99%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>剩余模块单元测试</h2>
<h3><a id="defaults%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>defaults 模块单元测试</h3>
<p><code>defaults</code> 模块为请求配置提供了一些默认的属性和方法，我们需要为其编写单元测试。</p>
<p><code>test/defaults.spec.ts</code>：</p>
<pre><code class="language-typescript">import axios, {AxiosTransformer} from '../src/index'
import {getAjaxRequest} from './helper'
import {deepMerge} from '../src/helpers/util'

describe('defaults', () =&gt; {beforeEach(() =&gt; {jasmine.Ajax.install()
  })afterEach(() =&gt; {jasmine.Ajax.uninstall()
  })test('should transform request json', () =&gt; {expect((axios.defaults.transformRequest as AxiosTransformer[])[0]({foo: 'bar'})).toBe('{&quot;foo&quot;:&quot;bar&quot;}')})

  test('should do nothing to request string', () =&gt; {expect((axios.defaults.transformRequest as AxiosTransformer[])[0]('foo=bar')).toBe('foo=bar')
  })test('should transform response json', () =&gt; {const data = (axios.defaults.transformResponse as AxiosTransformer[])[0]('{&quot;foo&quot;:&quot;bar&quot;}')expect(typeof data).toBe('object')
    expect(data.foo).toBe('bar')
  })test('should do nothing to response string', () =&gt; {expect((axios.defaults.transformResponse as AxiosTransformer[])[0]('foo=bar')).toBe('foo=bar')
  })test('should use global defaults config', () =&gt; {axios('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.url).toBe('/foo')
    })})

  test('should use modified defaults config', () =&gt; {
    axios.defaults.baseURL = 'http://example.com/'

    axios('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.url).toBe('http://example.com/foo')
      delete axios.defaults.baseURL
    })})

  test('should use request config', () =&gt; {
    axios('/foo', {baseURL: 'http://www.example.com'})

    return getAjaxRequest().then(request =&gt; {expect(request.url).toBe('http://www.example.com/foo')
    })})

  test('should use default config for custom instance', () =&gt; {
    const instance = axios.create({
      xsrfCookieName: 'CUSTOM-XSRF-TOKEN',
      xsrfHeaderName: 'X-CUSTOM-XSRF-TOKEN'
    })
    document.cookie = instance.defaults.xsrfCookieName + '=foobarbaz'

    instance.get('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.requestHeaders[instance.defaults.xsrfHeaderName!]).toBe('foobarbaz')
      document.cookie =
        instance.defaults.xsrfCookieName +
        '=;expires=' +
        new Date(Date.now() - 86400000).toUTCString()
    })})

  test('should use GET headers', () =&gt; {axios.defaults.headers.get['X-CUSTOM-HEADER'] = 'foo'
    axios.get('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.requestHeaders['X-CUSTOM-HEADER']).toBe('foo')
      delete axios.defaults.headers.get['X-CUSTOM-HEADER']
    })})

  test('should use POST headers', () =&gt; {axios.defaults.headers.post['X-CUSTOM-HEADER'] = 'foo'
    axios.post('/foo', {})

    return getAjaxRequest().then(request =&gt; {expect(request.requestHeaders['X-CUSTOM-HEADER']).toBe('foo')
      delete axios.defaults.headers.post['X-CUSTOM-HEADER']
    })})

  test('should use header config', () =&gt; {
    const instance = axios.create({
      headers: {
        common: {'X-COMMON-HEADER': 'commonHeaderValue'},
        get: {'X-GET-HEADER': 'getHeaderValue'},
        post: {'X-POST-HEADER': 'postHeaderValue'}
      }
    })

    instance.get('/foo', {
      headers: {
        'X-FOO-HEADER': 'fooHeaderValue',
        'X-BAR-HEADER': 'barHeaderValue'
      }
    })return getAjaxRequest().then(request =&gt; {expect(request.requestHeaders).toEqual(
        deepMerge(axios.defaults.headers.common, axios.defaults.headers.get, {
          'X-COMMON-HEADER': 'commonHeaderValue',
          'X-GET-HEADER': 'getHeaderValue',
          'X-FOO-HEADER': 'fooHeaderValue',
          'X-BAR-HEADER': 'barHeaderValue'
        }))})
  })test('should be used by custom instance if set before instance created', () =&gt; {
    axios.defaults.baseURL = 'http://example.org/'
    const instance = axios.create()instance.get('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.url).toBe('http://example.org/foo')
      delete axios.defaults.baseURL
    })})

  test('should not be used by custom instance if set after instance created', () =&gt; {const instance = axios.create()
    axios.defaults.baseURL = 'http://example.org/'

    instance.get('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.url).toBe('/foo')
    })})
})
</code></pre>
<h3><a id="transform%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>transform 模块单元测试</h3>
<p><code>transform</code> 模块用来定义请求和响应的转换方法，我们需要为其编写单元测试。</p>
<pre><code class="language-typescript">import axios, {AxiosResponse, AxiosTransformer} from '../src/index'
import {getAjaxRequest} from './helper'

describe('transform', () =&gt; {beforeEach(() =&gt; {jasmine.Ajax.install()
  })afterEach(() =&gt; {jasmine.Ajax.uninstall()
  })test('should transform JSON to string', () =&gt; {
    const data = {foo: 'bar'}

    axios.post('/foo', data)

    return getAjaxRequest().then(request =&gt; {expect(request.params).toBe('{&quot;foo&quot;:&quot;bar&quot;}')})
  })

  test('should transform string to JSON', done =&gt; {
    let response: AxiosResponse

    axios('/foo').then(res =&gt; {response = res})

    getAjaxRequest().then(request =&gt; {
      request.respondWith({
        status: 200,
        responseText: '{&quot;foo&quot;:&quot;bar&quot;}'
      })setTimeout(() =&gt; {expect(typeof response.data).toBe('object')
        expect(response.data.foo).toBe('bar')
        done()}, 100)
    })})

  test('should override default transform', () =&gt; {
    const data = {foo: 'bar'}

    axios.post('/foo', data, {transformRequest(data) {return data}
    })return getAjaxRequest().then(request =&gt; {expect(request.params).toEqual({foo: 'bar'})
    })})

  test('should allow an Array of transformers', () =&gt; {
    const data = {foo: 'bar'}

    axios.post('/foo', data, {transformRequest: (axios.defaults.transformRequest as AxiosTransformer[]).concat(function(data) {return data.replace('bar', 'baz')
      })})

    return getAjaxRequest().then(request =&gt; {expect(request.params).toBe('{&quot;foo&quot;:&quot;baz&quot;}')})
  })test('should allowing mutating headers', () =&gt; {const token = Math.floor(Math.random() * Math.pow(2, 64)).toString(36)

    axios('/foo', {transformRequest: (data, headers) =&gt; {headers['X-Authorization'] = token
        return data
      }
    })return getAjaxRequest().then(request =&gt; {expect(request.requestHeaders['X-Authorization']).toEqual(token)
    })})
})
</code></pre>
<h3><a id="xsrf%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>xsrf 模块单元测试</h3>
<p><code>xsrf</code> 模块提供了一套防御 <code>xsrf</code> 攻击的解决方案，我们需要为其编写单元测试。</p>
<p><code>test/xsrf.spec.ts</code>：</p>
<pre><code class="language-typescript">import axios from '../src/index'
import {getAjaxRequest} from './helper'

describe('xsrf', () =&gt; {beforeEach(() =&gt; {jasmine.Ajax.install()
  })afterEach(() =&gt; {jasmine.Ajax.uninstall()
    document.cookie =
      axios.defaults.xsrfCookieName + '=;expires=' + new Date(Date.now() - 86400000).toUTCString()
  })test('should not set xsrf header if cookie is null', () =&gt; {axios('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.requestHeaders[axios.defaults.xsrfHeaderName!]).toBeUndefined()})
  })test('should set xsrf header if cookie is set', () =&gt; {
    document.cookie = axios.defaults.xsrfCookieName + '=12345'

    axios('/foo')

    return getAjaxRequest().then(request =&gt; {expect(request.requestHeaders[axios.defaults.xsrfHeaderName!]).toBe('12345')
    })})

  test('should not set xsrf header for cross origin', () =&gt; {
    document.cookie = axios.defaults.xsrfCookieName + '=12345'

    axios('http://example.com/')

    return getAjaxRequest().then(request =&gt; {expect(request.requestHeaders[axios.defaults.xsrfHeaderName!]).toBeUndefined()})
  })test('should set xsrf header for cross origin when using withCredentials', () =&gt; {
    document.cookie = axios.defaults.xsrfCookieName + '=12345'

    axios('http://example.com/', {withCredentials: true})

    return getAjaxRequest().then(request =&gt; {expect(request.requestHeaders[axios.defaults.xsrfHeaderName!]).toBe('12345')
    })})
})
</code></pre>
<p>注意在 <code>afterEach</code> 函数中我们清空了 <code>xsrf</code> 相关的 cookie。</p>
<h3><a id="%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>上传下载模块单元测试</h3>
<p>上传下载模块允许我们监听上传和下载的进度，我们需要为其编写单元测试。</p>
<p><code>test/progress.spec.ts</code>：</p>
<pre><code class="language-typescript">import axios from '../src/index'
import {getAjaxRequest} from './helper'

describe('progress', () =&gt; {beforeEach(() =&gt; {jasmine.Ajax.install()
  })afterEach(() =&gt; {jasmine.Ajax.uninstall()
  })test('should add a download progress handler', () =&gt; {const progressSpy = jest.fn()

    axios('/foo', { onDownloadProgress: progressSpy})

    return getAjaxRequest().then(request =&gt; {
      request.respondWith({
        status: 200,
        responseText: '{&quot;foo&quot;:&quot;bar&quot;}'
      })expect(progressSpy).toHaveBeenCalled()})
  })test('should add a upload progress handler', () =&gt; {const progressSpy = jest.fn()

    axios('/foo', { onUploadProgress: progressSpy})

    return getAjaxRequest().then(request =&gt; {
      // Jasmine AJAX doesn't trigger upload events.Waiting for jest-ajax fix
      // expect(progressSpy).toHaveBeenCalled()})
  })})
</code></pre>
<p>注意，由于 <code>jasmine-ajax</code> 插件不会派发 <code>upload</code> 事件，这个未来可以通过我们自己编写的 <code>jest-ajax</code> 插件来解决，目前不写断言的情况它会直接通过。</p>
<h3><a id="http%E6%8E%88%E6%9D%83%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP 授权模块单元测试</h3>
<p>HTTP 授权模块为我们在请求头中添加 <code>Authorization</code> 字段，我们需要为其编写单元测试。</p>
<p><code>test/auth.spec.ts</code>：</p>
<pre><code class="language-typescript">import axios from '../src/index'
import {getAjaxRequest} from './helper'

describe('auth', () =&gt; {beforeEach(() =&gt; {jasmine.Ajax.install()
  })afterEach(() =&gt; {jasmine.Ajax.uninstall()
  })test('should accept HTTP Basic auth with username/password', () =&gt; {
    axios('/foo', {
      auth: {
        username: 'Aladdin',
        password: 'open sesame'
      }
    })return getAjaxRequest().then(request =&gt; {expect(request.requestHeaders['Authorization']).toBe('Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==')
    })})

  test('should fail to encode HTTP Basic auth credentials with non-Latin1 characters', () =&gt; {
    return axios('/foo', {
      auth: {
        username: 'Aladßç£☃din',
        password: 'open sesame'
      }
    }).then(() =&gt; {
        throw new Error('Should not succeed to make a HTTP Basic auth request with non-latin1 chars in credentials.')
      })
      .catch(error =&gt; {expect(/character/i.test(error.message)).toBeTruthy()})
  })})
</code></pre>
<h3><a id="%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态方法模块单元测试</h3>
<p>静态方法模块为 <code>axios</code> 对象添加了 2 个静态方法，我们需要为其编写单元测试。</p>
<p><code>test/static.spec.ts</code>：</p>
<pre><code class="language-typescript">import axios from '../src/index'

describe('promise', () =&gt; {
  test('should support all', done =&gt; {
    let fulfilled = false

    axios.all([true, false]).then(arg =&gt; {fulfilled = arg[0]
    })setTimeout(() =&gt; {expect(fulfilled).toBeTruthy()done()
    }, 100)})

  test('should support spread', done =&gt; {
    let sum = 0
    let fulfilled = false
    let result: any

    axios
      .all([123, 456])
      .then(axios.spread((a, b) =&gt; {
          sum = a + b
          fulfilled = true
          return 'hello world'
        }) )
      .then(res =&gt; {result = res})

    setTimeout(() =&gt; {expect(fulfilled).toBeTruthy()expect(sum).toBe(123 + 456)
      expect(result).toBe('hello world')
      done()}, 100)
  })})
</code></pre>
<h3><a id="%E8%A1%A5%E5%85%85%E6%9C%AA%E8%A6%86%E7%9B%96%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>补充未覆盖的代码测试</h3>
<p>我们发现，跑完测试后，仍有一些代码没有覆盖到测试，其中 <code>core/xhr.ts</code> 文件的第 43 行：</p>
<pre><code class="language-typescript">if (responseType) {request.responseType = responseType}
</code></pre>
<p>我们并未在测试中设置过 <code>responseType</code>，因此我们在 <code>test/requests.spect.ts</code> 文件中补充相关测试：</p>
<pre><code class="language-typescript">test('should support array buffer response', done =&gt; {
  let response: AxiosResponse

  function str2ab(str: string) {const buff = new ArrayBuffer(str.length * 2)
    const view = new Uint16Array(buff)
    for (let i = 0; i &lt; str.length; i++) {view[i] = str.charCodeAt(i)
    }
    return buff
  }

  axios('/foo', {responseType: 'arraybuffer'}).then(data =&gt; {response = data})

  getAjaxRequest().then(request =&gt; {
    request.respondWith({
      status: 200,
      // @ts-ignore
      response: str2ab('Hello world')
    })setTimeout(() =&gt; {expect(response.data.byteLength).toBe(22)
      done()}, 100)
  })})
</code></pre>
<p>另外我们发现 <code>core/xhr.ts</code> 文件的第 13 行：</p>
<pre><code class="language-typescript">method = 'get'
</code></pre>
<p>分支没有测试完全。因为实际上代码执行到这的时候 <code>method</code> 是一定会有的，所以我们不必为其指定默认值，另外还需要在 <code>method!.toUpperCase()</code> 的时候使用非空断言。</p>
<p>同时 <code>core/xhr.ts</code> 文件的第 66 行：</p>
<pre><code class="language-typescript">const responseData = responseType !== 'text' ? request.response : request.responseText
</code></pre>
<p>分支也没有测试完全。这里我们应该先判断存在 <code>responseType</code> 存在的情况下再去和 <code>text</code> 做对比，需要修改逻辑：</p>
<pre><code class="language-typescript">const responseData = responseType &amp;&amp; responseType !== 'text' ? request.response : request.responseText
</code></pre>
<p>这样再次跑测试，就覆盖了所有的分支。</p>
<p>到此为止，除了我们之前说的 <code>helpers/error.ts</code> 模块中对于 <code>super</code> 的测试的分支覆盖率没达到 100%，其它模块均达到 100% 的测试覆盖率。</p>
<p>有些有强迫症的同学可能会觉得，能不能通过某种手段让它的覆盖率达到 100% 呢，这里其实有一个奇技淫巧，在 <code>helpers/error.ts</code> 文件的 <code>constructor</code> 函数上方加一个 <code>/* istanbul ignore next */</code> 注释，这样其实相当于忽略了整个构造函数的测试，这样我们就可以达到 100% 的覆盖率了。</p>
<p><code>/* istanbul ignore next */</code> 在我们去阅读一些开源代码的时候经常会遇到，主要用途就是用来忽略测试用的，这个技巧不可滥用，除非你明确的知道这段代码不需要测试，否则你不应该使用它。滥用就失去了单元测试的意义了。</p>
<p>至此，我们就完成了整个 <code>ts-axios</code> 库的测试了，我们也成功地让测试覆盖率达到目标 99% 以上。下一章我会教大家如果打包构建和发布我们的 <code>ts-axios</code> 库。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Typescript 基础教程]]></title>
    <link href="http://yuanchao.blogs.io/16537420437480.html"/>
    <updated>2022-05-28T20:47:23+08:00</updated>
    <id>http://yuanchao.blogs.io/16537420437480.html</id>
    <content type="html"><![CDATA[
<h1><a id="%E5%88%9D%E8%AF%86typescript" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>初识 TypeScript</h1>
<h2><a id="%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>介绍</h2>
<p>TypeScript 作为 JavaScript 语言的超级，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。</p>
<h3><a id="%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>学习资料</h3>
<ul>
<li>Typescript中文网：<a href="https://www.tslang.cn/">https://www.tslang.cn/</a></li>
<li>Typescript入门教程：<a href="http://ts.xcatliu.com/">http://ts.xcatliu.com/</a></li>
<li>Typescript配置文档：<a href="http://json.schemastore.org/tsconfig">http://json.schemastore.org/tsconfig</a></li>
<li>Typescript Github：<a href="https://github.com/Microsoft/TypeScript">https://github.com/Microsoft/TypeScript</a></li>
</ul>
<h3><a id="typescript%E7%9A%84%E7%89%B9%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeScript 的特点</h3>
<p>TypeScript 主要有 3 大特点：</p>
<ul>
<li><strong>始于JavaScript，归于JavaScript</strong></li>
</ul>
<p>TypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。</p>
<ul>
<li><strong>强大的工具构建大型应用程序</strong></li>
</ul>
<p>类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。</p>
<p>类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。</p>
<ul>
<li><strong>先进的 JavaScript</strong></li>
</ul>
<p>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。</p>
<p>这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。</p>
<h3><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h3>
<p>TypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。都 2019 年了，如果你还没有开始学习 TypeScript，那么你可能要落后了哟，所以还等什么，快来和我一起学习并使用 TypeScript 吧，来感受一下它为我们带来的奇妙体验。</p>
<h2><a id="%E5%AE%89%E8%A3%85typescript" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装 TypeScript</h2>
<p>命令行运行如下命令，全局安装 TypeScript：</p>
<pre><code class="language-bash">npm install -g typescript
</code></pre>
<p>安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：</p>
<pre><code class="language-bash">tsc -V 
</code></pre>
<h3><a id="%E6%8F%92%E6%9B%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>插曲</h3>
<p>在录制本视频的时候，TypeScript 的版本是 3.3.3333，很多同学看到这个版本号一定很好奇，我也一样，于是我去搜了一下，发现这个是 TypeScript 团队有意为之，详情可以参考这个 <a href="https://github.com/Microsoft/TypeScript/issues/30032">issues</a>。</p>
<h2><a id="%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAtypescript%E7%A8%8B%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编写第一个 TypeScript 程序</h2>
<p>在编辑器，将下面的代码输入到 greeter.ts 文件里：</p>
<pre><code class="language-javascript">function greeter (person) {
  return 'Hello, ' + person
}

let user = 'Yee'

console.log(greeter(user))
</code></pre>
<h3><a id="%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编译代码</h3>
<p>我们使用了 <code>.ts</code> 扩展名，但是这段代码仅仅是 JavaScript 而已。</p>
<p>在命令行上，运行 TypeScript 编译器：</p>
<pre><code class="language-bash">tsc greeter.ts
</code></pre>
<p>输出结果为一个 <code>greeter.js</code> 文件，它包含了和输入文件中相同的 JavsScript 代码。</p>
<p>在命令行上，通过 Node.js 运行这段代码：</p>
<pre><code class="language-bash">node greeter.js
</code></pre>
<p>控制台输出：</p>
<pre><code class="language-plain_text">Hello, Yee
</code></pre>
<h3><a id="%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型注解</h3>
<p>接下来让我们看看 TypeScript 工具带来的高级功能。 给  <code>person</code> 函数的参数添加 <code>: string</code> 类型注解，如下：</p>
<pre><code class="language-typescript">function greeter (person: string) {
  return 'Hello, ' + person
}

let user = 'Yee'

console.log(greeter(user))
</code></pre>
<p>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 <code>greeter</code> 函数接收一个字符串参数。 然后尝试把 <code>greeter</code> 的调用改成传入一个数组：</p>
<pre><code class="language-typescript">function greeter (person: string) {
  return 'Hello, ' + person
}

let user = [0, 1, 2]

console.log(greeter(user))
</code></pre>
<p>重新编译，你会看到产生了一个错误：</p>
<pre><code class="language-plain_text">error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.
</code></pre>
<p>类似地，尝试删除 <code>greeter</code> 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p>
<p>要注意的是尽管有错误，<code>greeter.js</code> 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。</p>
<h3><a id="%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口</h3>
<p>让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 <code>firstName</code> 和 <code>lastName</code> 字段的对象。 在 <code>TypeScript</code> 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 <code>implements</code> 语句。</p>
<pre><code class="language-typescript">interface Person {
  firstName: string
  lastName: string
}

function greeter (person: Person) {
  return 'Hello, ' + person.firstName + ' ' + person.lastName
}

let user = {
  firstName: 'Yee',
  lastName: 'Huang'
}

console.log(greeter(user))
</code></pre>
<h3><a id="%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类</h3>
<p>最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。</p>
<p>让我们创建一个 <code>User</code> 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。</p>
<p>还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。</p>
<pre><code class="language-typescript">class User {
  fullName: string
  firstName: string
  lastName: string

  constructor (firstName: string, lastName: string) {
    this.firstName = firstName
    this.lastName = lastName
    this.fullName = firstName + ' ' + lastName
  }
}

interface Person {
  firstName: string
  lastName: string
}

function greeter (person: Person) {
  return 'Hello, ' + person.firstName + ' ' + person.lastName
}

let user = new User('Yee', 'Huang')

console.log(greeter(user))
</code></pre>
<p>重新运行 <code>tsc greeter.ts</code>，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 <code>JavaScript</code> 函数的实现。</p>
<h3><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h3>
<p>到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。</p>
<h1><a id="typescript%E5%9F%BA%E7%A1%80%E7%AF%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeScript基础篇</h1>
<h2><a id="%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第一章 快速入门</h2>
<h3><a id="0%E3%80%81typescript%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>0、TypeScript简介</h3>
<ol>
<li>TypeScript是JavaScript的超集。</li>
<li>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。</li>
<li>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</li>
<li>TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。</li>
<li>相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。</li>
</ol>
<h3><a id="1%E3%80%81typescript%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、TypeScript 开发环境搭建</h3>
<ol>
<li>
<p>下载Node.js</p>
<ul>
<li>64位：<a href="https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi</a></li>
<li>32位：<a href="https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi</a></li>
</ul>
</li>
<li>
<p>安装Node.js</p>
</li>
<li>
<p>使用npm全局安装typescript</p>
<ul>
<li>进入命令行</li>
<li>输入：npm i -g typescript</li>
</ul>
</li>
<li>
<p>创建一个ts文件</p>
</li>
<li>
<p>使用tsc对ts文件进行编译</p>
<ul>
<li>
<p>进入命令行</p>
</li>
<li>
<p>进入ts文件所在目录</p>
</li>
<li>
<p>执行命令：tsc xxx.ts</p>
</li>
</ul>
</li>
</ol>
<h3><a id="2%E3%80%81%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、基本类型</h3>
<ul>
<li>
<p>类型声明</p>
<ul>
<li>
<p>类型声明是TS非常重要的一个特点</p>
</li>
<li>
<p>通过类型声明可以指定TS中变量（参数、形参）的类型</p>
</li>
<li>
<p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p>
</li>
<li>
<p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</p>
</li>
<li>
<p>语法：</p>
<ul>
<li>
<pre><code class="language-typescript">let 变量: 类型;

let 变量: 类型 = 值;

function fn(参数: 类型, 参数: 类型): 类型{
    ...
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>自动类型判断</p>
<ul>
<li>TS拥有自动的类型判断机制</li>
<li>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</li>
<li>所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</li>
</ul>
</li>
<li>
<p>类型：</p>
<table>
<thead>
<tr>
<th style="text-align: center">类型</th>
<th style="text-align: center">例子</th>
<th style="text-align: center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">number</td>
<td style="text-align: center">1, -33, 2.5</td>
<td style="text-align: center">任意数字</td>
</tr>
<tr>
<td style="text-align: center">string</td>
<td style="text-align: center">'hi', &quot;hi&quot;, <code>hi</code></td>
<td style="text-align: center">任意字符串</td>
</tr>
<tr>
<td style="text-align: center">boolean</td>
<td style="text-align: center">true、false</td>
<td style="text-align: center">布尔值true或false</td>
</tr>
<tr>
<td style="text-align: center">字面量</td>
<td style="text-align: center">其本身</td>
<td style="text-align: center">限制变量的值就是该字面量的值</td>
</tr>
<tr>
<td style="text-align: center">any</td>
<td style="text-align: center">*</td>
<td style="text-align: center">任意类型</td>
</tr>
<tr>
<td style="text-align: center">unknown</td>
<td style="text-align: center">*</td>
<td style="text-align: center">类型安全的any</td>
</tr>
<tr>
<td style="text-align: center">void</td>
<td style="text-align: center">空值（undefined）</td>
<td style="text-align: center">没有值（或undefined）</td>
</tr>
<tr>
<td style="text-align: center">never</td>
<td style="text-align: center">没有值</td>
<td style="text-align: center">不能是任何值</td>
</tr>
<tr>
<td style="text-align: center">object</td>
<td style="text-align: center">{name:'孙悟空'}</td>
<td style="text-align: center">任意的JS对象</td>
</tr>
<tr>
<td style="text-align: center">array</td>
<td style="text-align: center">[1,2,3]</td>
<td style="text-align: center">任意JS数组</td>
</tr>
<tr>
<td style="text-align: center">tuple</td>
<td style="text-align: center">[4,5]</td>
<td style="text-align: center">元素，TS新增类型，固定长度数组</td>
</tr>
<tr>
<td style="text-align: center">enum</td>
<td style="text-align: center">enum{A, B}</td>
<td style="text-align: center">枚举，TS中新增类型</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>number</p>
<ul>
<li>
<pre><code class="language-typescript">let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
let big: bigint = 100n;
</code></pre>
</li>
</ul>
</li>
<li>
<p>boolean</p>
<ul>
<li>
<pre><code class="language-typescript">let isDone: boolean = false;
</code></pre>
</li>
</ul>
</li>
<li>
<p>string</p>
<ul>
<li>
<pre><code class="language-typescript">let color: string = &quot;blue&quot;;
color = 'red';

let fullName: string = `Bob Bobbington`;
let age: number = 37;
let sentence: string = `Hello, my name is ${fullName}.

I'll be ${age + 1} years old next month.`;
</code></pre>
</li>
</ul>
</li>
<li>
<p>字面量</p>
<ul>
<li>
<p>也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围</p>
</li>
<li>
<pre><code class="language-typescript">let color: 'red' | 'blue' | 'black';
let num: 1 | 2 | 3 | 4 | 5;
</code></pre>
</li>
</ul>
</li>
<li>
<p>any</p>
<ul>
<li>
<pre><code class="language-typescript">let d: any = 4;
d = 'hello';
d = true;
</code></pre>
</li>
</ul>
</li>
<li>
<p>unknown</p>
<ul>
<li>
<pre><code class="language-typescript">let notSure: unknown = 4;
notSure = 'hello';
</code></pre>
</li>
</ul>
</li>
<li>
<p>void</p>
<ul>
<li>
<pre><code class="language-typescript">let unusable: void = undefined;
</code></pre>
</li>
</ul>
</li>
<li>
<p>never</p>
<ul>
<li>
<pre><code class="language-typescript">function error(message: string): never {
  throw new Error(message);
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>object（没啥用）</p>
<ul>
<li>
<pre><code class="language-typescript">let obj: object = {};
</code></pre>
</li>
</ul>
</li>
<li>
<p>array</p>
<ul>
<li>
<pre><code class="language-typescript">let list: number[] = [1, 2, 3];
let list: Array&lt;number&gt; = [1, 2, 3];
</code></pre>
</li>
</ul>
</li>
<li>
<p>tuple</p>
<ul>
<li>
<pre><code class="language-typescript">let x: [string, number];
x = [&quot;hello&quot;, 10]; 
</code></pre>
</li>
</ul>
</li>
<li>
<p>enum</p>
<ul>
<li>
<pre><code class="language-typescript">enum Color {
  Red,
  Green,
  Blue,
}
let c: Color = Color.Green;

enum Color {
  Red = 1,
  Green,
  Blue,
}
let c: Color = Color.Green;

enum Color {
  Red = 1,
  Green = 2,
  Blue = 4,
}
let c: Color = Color.Green;
</code></pre>
</li>
</ul>
</li>
<li>
<p>类型断言</p>
<ul>
<li>
<p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</p>
<ul>
<li>
<p>第一种</p>
<ul>
<li>
<pre><code class="language-typescript">let someValue: unknown = &quot;this is a string&quot;;
let strLength: number = (someValue as string).length;
</code></pre>
</li>
</ul>
</li>
<li>
<p>第二种</p>
<ul>
<li>
<pre><code class="language-typescript">let someValue: unknown = &quot;this is a string&quot;;
let strLength: number = (&lt;string&gt;someValue).length;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a id="3%E3%80%81%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、编译选项</h3>
<ul>
<li>
<p>自动编译文件</p>
<ul>
<li>
<p>编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-powershell">tsc xxx.ts -w
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>自动编译整个项目</p>
<ul>
<li>
<p>如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。</p>
</li>
<li>
<p>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json</p>
</li>
<li>
<p>tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译</p>
</li>
<li>
<p>配置选项：</p>
<ul>
<li>
<p>include</p>
<ul>
<li>
<p>定义希望被编译文件所在的目录</p>
</li>
<li>
<p>默认值：[&quot;**/*&quot;]</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;]
</code></pre>
</li>
<li>
<p>上述示例中，所有src目录和tests目录下的文件都会被编译</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>exclude</p>
<ul>
<li>
<p>定义需要排除在外的目录</p>
</li>
<li>
<p>默认值：[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;exclude&quot;: [&quot;./src/hello/**/*&quot;]
</code></pre>
</li>
<li>
<p>上述示例中，src下hello目录下的文件都不会被编译</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>extends</p>
<ul>
<li>
<p>定义被继承的配置文件</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;extends&quot;: &quot;./configs/base&quot;
</code></pre>
</li>
<li>
<p>上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>files</p>
<ul>
<li>
<p>指定被编译文件的列表，只有需要编译的文件少时才会用到</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;files&quot;: [
    &quot;core.ts&quot;,
    &quot;sys.ts&quot;,
    &quot;types.ts&quot;,
    &quot;scanner.ts&quot;,
    &quot;parser.ts&quot;,
    &quot;utilities.ts&quot;,
    &quot;binder.ts&quot;,
    &quot;checker.ts&quot;,
    &quot;tsc.ts&quot;
  ]
</code></pre>
</li>
<li>
<p>列表中的文件都会被TS编译器所编译</p>
</li>
</ul>
</li>
<li>
<p>compilerOptions</p>
<ul>
<li>
<p>编译选项是配置文件中非常重要也比较复杂的配置选项</p>
</li>
<li>
<p>在compilerOptions中包含多个子选项，用来完成对编译的配置</p>
<ul>
<li>
<p>项目选项</p>
<ul>
<li>
<p>target</p>
<ul>
<li>
<p>设置ts代码编译的目标版本</p>
</li>
<li>
<p>可选值：</p>
<ul>
<li>ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;ES6&quot;
}
</code></pre>
</li>
<li>
<p>如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>lib</p>
<ul>
<li>
<p>指定代码运行时所包含的库（宿主环境）</p>
</li>
<li>
<p>可选值：</p>
<ul>
<li>ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;ES6&quot;,
    &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],
    &quot;outDir&quot;: &quot;dist&quot;,
    &quot;outFile&quot;: &quot;dist/aa.js&quot;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>module</p>
<ul>
<li>
<p>设置编译后代码使用的模块化系统</p>
</li>
<li>
<p>可选值：</p>
<ul>
<li>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-typescript">&quot;compilerOptions&quot;: {
    &quot;module&quot;: &quot;CommonJS&quot;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>outDir</p>
<ul>
<li>
<p>编译后文件的所在目录</p>
</li>
<li>
<p>默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;outDir&quot;: &quot;dist&quot;
}
</code></pre>
</li>
<li>
<p>设置后编译后的js文件将会生成到dist目录</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>outFile</p>
<ul>
<li>
<p>将所有的文件编译为一个js文件</p>
</li>
<li>
<p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;outFile&quot;: &quot;dist/app.js&quot;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>rootDir</p>
<ul>
<li>
<p>指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;rootDir&quot;: &quot;./src&quot;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>allowJs</p>
<ul>
<li>是否对js文件编译</li>
</ul>
</li>
<li>
<p>checkJs</p>
<ul>
<li>
<p>是否对js文件进行检查</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;allowJs&quot;: true,
    &quot;checkJs&quot;: true
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>removeComments</p>
<ul>
<li>是否删除注释</li>
<li>默认值：false</li>
</ul>
</li>
<li>
<p>noEmit</p>
<ul>
<li>不对代码进行编译</li>
<li>默认值：false</li>
</ul>
</li>
<li>
<p>sourceMap</p>
<ul>
<li>是否生成sourceMap</li>
<li>默认值：false</li>
</ul>
</li>
</ul>
</li>
<li>
<p>严格检查</p>
<ul>
<li>strict
<ul>
<li>启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查</li>
</ul>
</li>
<li>alwaysStrict
<ul>
<li>总是以严格模式对代码进行编译</li>
</ul>
</li>
<li>noImplicitAny
<ul>
<li>禁止隐式的any类型</li>
</ul>
</li>
<li>noImplicitThis
<ul>
<li>禁止类型不明确的this</li>
</ul>
</li>
<li>strictBindCallApply
<ul>
<li>严格检查bind、call和apply的参数列表</li>
</ul>
</li>
<li>strictFunctionTypes
<ul>
<li>严格检查函数的类型</li>
</ul>
</li>
<li>strictNullChecks
<ul>
<li>严格的空值检查</li>
</ul>
</li>
<li>strictPropertyInitialization
<ul>
<li>严格检查属性是否初始化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>额外检查</p>
<ul>
<li>noFallthroughCasesInSwitch
<ul>
<li>检查switch语句包含正确的break</li>
</ul>
</li>
<li>noImplicitReturns
<ul>
<li>检查函数没有隐式的返回值</li>
</ul>
</li>
<li>noUnusedLocals
<ul>
<li>检查未使用的局部变量</li>
</ul>
</li>
<li>noUnusedParameters
<ul>
<li>检查未使用的参数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>高级</p>
<ul>
<li>allowUnreachableCode
<ul>
<li>检查不可达代码</li>
<li>可选值：
<ul>
<li>true，忽略不可达代码</li>
<li>false，不可达代码将引起错误</li>
</ul>
</li>
</ul>
</li>
<li>noEmitOnError
<ul>
<li>有错误的情况下不进行编译</li>
<li>默认值：false</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a id="4%E3%80%81webpack" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4、webpack</h3>
<ul>
<li>
<p>通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。</p>
</li>
<li>
<p>步骤：</p>
<ol>
<li>
<p>初始化项目</p>
<ul>
<li>进入项目根目录，执行命令 <code> npm init -y</code>
<ul>
<li>主要作用：创建package.json文件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>下载构建工具</p>
<ul>
<li><code>npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin</code>
<ul>
<li>共安装了7个包
<ul>
<li>webpack
<ul>
<li>构建工具webpack</li>
</ul>
</li>
<li>webpack-cli
<ul>
<li>webpack的命令行工具</li>
</ul>
</li>
<li>webpack-dev-server
<ul>
<li>webpack的开发服务器</li>
</ul>
</li>
<li>typescript
<ul>
<li>ts编译器</li>
</ul>
</li>
<li>ts-loader
<ul>
<li>ts加载器，用于在webpack中编译ts文件</li>
</ul>
</li>
<li>html-webpack-plugin
<ul>
<li>webpack中html插件，用来自动创建html文件</li>
</ul>
</li>
<li>clean-webpack-plugin
<ul>
<li>webpack中的清除插件，每次构建都会先清除目录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>根目录下创建webpack的配置文件webpack.config.js</p>
<ul>
<li>
<pre><code class="language-javascript">const path = require(&quot;path&quot;);
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
const { CleanWebpackPlugin } = require(&quot;clean-webpack-plugin&quot;);

module.exports = {
    optimization:{
        minimize: false // 关闭代码压缩，可选
    },

    entry: &quot;./src/index.ts&quot;,
    
    devtool: &quot;inline-source-map&quot;,
    
    devServer: {
        contentBase: './dist'
    },

    output: {
        path: path.resolve(__dirname, &quot;dist&quot;),
        filename: &quot;bundle.js&quot;,
        environment: {
            arrowFunction: false // 关闭webpack的箭头函数，可选
        }
    },

    resolve: {
        extensions: [&quot;.ts&quot;, &quot;.js&quot;]
    },
    
    module: {
        rules: [
            {
                test: /\.ts$/,
                use: {
                   loader: &quot;ts-loader&quot;     
                },
                exclude: /node_modules/
            }
        ]
    },

    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            title:'TS测试'
        }),
    ]

}
</code></pre>
</li>
</ul>
</li>
<li>
<p>根目录下创建tsconfig.json，配置可以根据自己需要</p>
<ul>
<li>
<pre><code class="language-json">{
    &quot;compilerOptions&quot;: {
        &quot;target&quot;: &quot;ES2015&quot;,
        &quot;module&quot;: &quot;ES2015&quot;,
        &quot;strict&quot;: true
    }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>修改package.json添加如下配置</p>
<ul>
<li>
<pre><code class="language-json">{
  ...略...
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;build&quot;: &quot;webpack&quot;,
    &quot;start&quot;: &quot;webpack serve --open chrome.exe&quot;
  },
  ...略...
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译，或者执行<code>npm start</code>来启动开发服务器</p>
</li>
</ol>
</li>
</ul>
<h3><a id="5%E3%80%81babel" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5、Babel</h3>
<ul>
<li>
<p>经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。</p>
<ol>
<li>
<p>安装依赖包：</p>
<ul>
<li><code>npm i -D @babel/core @babel/preset-env babel-loader core-js</code></li>
<li>共安装了4个包，分别是：
<ul>
<li>@babel/core
<ul>
<li>babel的核心工具</li>
</ul>
</li>
<li>@babel/preset-env
<ul>
<li>babel的预定义环境</li>
</ul>
</li>
<li>@babel-loader
<ul>
<li>babel在webpack中的加载器</li>
</ul>
</li>
<li>core-js
<ul>
<li>core-js用来使老版本的浏览器支持新版ES语法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>修改webpack.config.js配置文件</p>
<ul>
<li>
<pre><code class="language-javascript">...略...
module: {
    rules: [
        {
            test: /\.ts$/,
            use: [
                {
                    loader: &quot;babel-loader&quot;,
                    options:{
                        presets: [
                            [
                                &quot;@babel/preset-env&quot;,
                                {
                                    &quot;targets&quot;:{
                                        &quot;chrome&quot;: &quot;58&quot;,
                                        &quot;ie&quot;: &quot;11&quot;
                                    },
                                    &quot;corejs&quot;:&quot;3&quot;,
                                    &quot;useBuiltIns&quot;: &quot;usage&quot;
                                }
                            ]
                        ]
                    }
                },
                {
                    loader: &quot;ts-loader&quot;,

                }
            ],
            exclude: /node_modules/
        }
    ]
}
...略...
</code></pre>
</li>
<li>
<p>如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2><a id="%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第二章：面向对象</h2>
<p>面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。</p>
<ul>
<li>举例来说：
<ul>
<li>操作浏览器要使用window对象</li>
<li>操作网页要使用document对象</li>
<li>操作控制台要使用console对象</li>
</ul>
</li>
</ul>
<p>一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。</p>
<p>在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。</p>
<h3><a id="1%E3%80%81%E7%B1%BB%EF%BC%88class%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、类（class）</h3>
<p>要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。</p>
<ul>
<li>
<p>定义类：</p>
<ul>
<li>
<pre><code class="language-typescript">class 类名 {
	属性名: 类型;
	
	constructor(参数: 类型){
		this.属性名 = 参数;
	}
	
	方法名(){
		....
	}

}
</code></pre>
</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-typescript">class Person{
    name: string;
    age: number;

    constructor(name: string, age: number){
        this.name = name;
        this.age = age;
    }

    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>使用类：</p>
<ul>
<li>
<pre><code class="language-typescript">const p = new Person('孙悟空', 18);
p.sayHello();
</code></pre>
</li>
</ul>
</li>
</ul>
<h3><a id="2%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、面向对象的特点</h3>
<ul>
<li>
<p>封装</p>
<ul>
<li>
<p>对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装</p>
</li>
<li>
<p>默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置</p>
</li>
<li>
<p>只读属性（readonly）：</p>
<ul>
<li>如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改</li>
</ul>
</li>
<li>
<p>TS中属性具有三种修饰符：</p>
<ul>
<li>public（默认值），可以在类、子类和对象中修改</li>
<li>protected ，可以在类、子类中修改</li>
<li>private ，可以在类中修改</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<p>public</p>
<ul>
<li>
<pre><code class="language-typescript">class Person{
    public name: string; // 写或什么都不写都是public
    public age: number;

    constructor(name: string, age: number){
        this.name = name; // 可以在类中修改
        this.age = age;
    }

    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}

class Employee extends Person{
    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中可以修改
    }
}

const p = new Person('孙悟空', 18);
p.name = '猪八戒';// 可以通过对象修改
</code></pre>
</li>
</ul>
</li>
<li>
<p>protected</p>
<ul>
<li>
<pre><code class="language-typescript">class Person{
    protected name: string;
    protected age: number;

    constructor(name: string, age: number){
        this.name = name; // 可以修改
        this.age = age;
    }

    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}

class Employee extends Person{

    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中可以修改
    }
}

const p = new Person('孙悟空', 18);
p.name = '猪八戒';// 不能修改
</code></pre>
</li>
</ul>
</li>
<li>
<p>private</p>
<ul>
<li>
<pre><code class="language-typescript">class Person{
    private name: string;
    private age: number;

    constructor(name: string, age: number){
        this.name = name; // 可以修改
        this.age = age;
    }

    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}

class Employee extends Person{

    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中不能修改
    }
}

const p = new Person('孙悟空', 18);
p.name = '猪八戒';// 不能修改
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>属性存取器</p>
<ul>
<li>
<p>对于一些不希望被任意修改的属性，可以将其设置为private</p>
</li>
<li>
<p>直接将其设置为private将导致无法再通过对象修改其中的属性</p>
</li>
<li>
<p>我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器</p>
</li>
<li>
<p>读取属性的方法叫做setter方法，设置属性的方法叫做getter方法</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-typescript">class Person{
    private _name: string;

    constructor(name: string){
        this._name = name;
    }

    get name(){
        return this._name;
    }

    set name(name: string){
        this._name = name;
    }

}

const p1 = new Person('孙悟空');
console.log(p1.name); // 通过getter读取name属性
p1.name = '猪八戒'; // 通过setter修改name属性
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>静态属性</p>
<ul>
<li>
<p>静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用</p>
</li>
<li>
<p>静态属性（方法）使用static开头</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-typescript">class Tools{
    static PI = 3.1415926;
    
    static sum(num1: number, num2: number){
        return num1 + num2
    }
}

console.log(Tools.PI);
console.log(Tools.sum(123, 456));
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>this</p>
<ul>
<li>在类中，使用this表示当前对象</li>
</ul>
</li>
</ul>
</li>
<li>
<p>继承</p>
<ul>
<li>
<p>继承时面向对象中的又一个特性</p>
</li>
<li>
<p>通过继承可以将其他类中的属性和方法引入到当前类中</p>
<ul>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-typescript">class Animal{
    name: string;
    age: number;

    constructor(name: string, age: number){
        this.name = name;
        this.age = age;
    }
}

class Dog extends Animal{

    bark(){
        console.log(`${this.name}在汪汪叫！`);
    }
}

const dog = new Dog('旺财', 4);
dog.bark();
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>通过继承可以在不修改类的情况下完成对类的扩展</p>
</li>
<li>
<p>重写</p>
<ul>
<li>
<p>发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-typescript">class Animal{
    name: string;
    age: number;

    constructor(name: string, age: number){
        this.name = name;
        this.age = age;
    }

    run(){
        console.log(`父类中的run方法！`);
    }
}

class Dog extends Animal{

    bark(){
        console.log(`${this.name}在汪汪叫！`);
    }

    run(){
        console.log(`子类中的run方法，会重写父类中的run方法！`);
    }
}

const dog = new Dog('旺财', 4);
dog.bark();
</code></pre>
</li>
<li>
<p>在子类中可以使用super来完成对父类的引用</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>抽象类（abstract class）</p>
<ul>
<li>
<p>抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例</p>
</li>
<li>
<pre><code class="language-typescript">abstract class Animal{
    abstract run(): void;
    bark(){
        console.log('动物在叫~');
    }
}

class Dog extends Animals{
    run(){
        console.log('狗在跑~');
    }
}
</code></pre>
</li>
<li>
<p>使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a id="3%E3%80%81%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、接口（Interface）</h3>
<p>接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。</p>
<ul>
<li>
<p>示例（检查对象类型）：</p>
<ul>
<li>
<pre><code class="language-typescript">interface Person{
    name: string;
    sayHello():void;
}

function fn(per: Person){
    per.sayHello();
}

fn({name:'孙悟空', sayHello() {console.log(`Hello, 我是 ${this.name}`)}});

</code></pre>
</li>
</ul>
</li>
<li>
<p>示例（实现）</p>
<ul>
<li>
<pre><code class="language-typescript">interface Person{
    name: string;
    sayHello():void;
}

class Student implements Person{
    constructor(public name: string) {
    }

    sayHello() {
        console.log('大家好，我是'+this.name);
    }
}
</code></pre>
</li>
<li></li>
</ul>
</li>
</ul>
<h3><a id="4%E3%80%81%E6%B3%9B%E5%9E%8B%EF%BC%88generic%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4、泛型（Generic）</h3>
<p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。</p>
<ul>
<li>
<p>举个例子：</p>
<ul>
<li>
<pre><code class="language-typescript">function test(arg: any): any{
	return arg;
}
</code></pre>
</li>
<li>
<p>上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型</p>
</li>
<li>
<p>使用泛型：</p>
</li>
<li>
<pre><code class="language-typescript">function test&lt;T&gt;(arg: T): T{
	return arg;
}
</code></pre>
</li>
<li>
<p>这里的<code>&lt;T&gt;</code>就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。</p>
</li>
<li>
<p>那么如何使用上边的函数呢？</p>
<ul>
<li>
<p>方式一（直接使用）：</p>
<ul>
<li>
<pre><code class="language-typescript">test(10)
</code></pre>
</li>
<li>
<p>使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</p>
</li>
</ul>
</li>
<li>
<p>方式二（指定类型）：</p>
<ul>
<li>
<pre><code class="language-typescript">test&lt;number&gt;(10)
</code></pre>
</li>
<li>
<p>也可以在函数后手动指定泛型</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>可以同时指定多个泛型，泛型间使用逗号隔开：</p>
<ul>
<li>
<pre><code class="language-typescript">function test&lt;T, K&gt;(a: T, b: K): K{
    return b;
}

test&lt;number, string&gt;(10, &quot;hello&quot;);
</code></pre>
</li>
<li>
<p>使用泛型时，完全可以将泛型当成是一个普通的类去使用</p>
</li>
</ul>
</li>
<li>
<p>类中同样可以使用泛型：</p>
<ul>
<li>
<pre><code class="language-typescript">class MyClass&lt;T&gt;{
    prop: T;

    constructor(prop: T){
        this.prop = prop;
    }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>除此之外，也可以对泛型的范围进行约束</p>
<ul>
<li>
<pre><code class="language-typescript">interface MyInter{
    length: number;
}

function test&lt;T extends MyInter&gt;(arg: T): number{
    return arg.length;
}
</code></pre>
</li>
<li>
<p>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a id="typescript%E8%BF%9B%E9%98%B6%E7%AF%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeScript进阶篇</h1>
<h2><a id="%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础类型</h2>
<p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>
<h3><a id="%E5%B8%83%E5%B0%94%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>布尔值</h3>
<p>最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 <code>boolean</code>（其它语言中也一样）。</p>
<pre><code class="language-typescript">let isDone: boolean = false
</code></pre>
<h3><a id="%E6%95%B0%E5%AD%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数字</h3>
<p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p>
<pre><code class="language-typescript">let decLiteral: number = 20
let hexLiteral: number = 0x14
let binaryLiteral: number = 0b10100
let octalLiteral: number = 0o24
</code></pre>
<h3><a id="%E5%AD%97%E7%AC%A6%E4%B8%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符串</h3>
<p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>'</code>）表示字符串。</p>
<pre><code class="language-typescript">let name: string = 'bob'
name = 'smith'
</code></pre>
<p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ <code>`</code>），并且以 <code>${ expr }</code> 这种形式嵌入表达式</p>
<pre><code class="language-typescript">let name: string = `Yee`
let age: number = 37
let sentence: string = `Hello, my name is ${ name }.

I'll be ${ age + 1 } years old next month.`
</code></pre>
<p>这与下面定义 <code>sentence</code> 的方式效果相同：</p>
<pre><code class="language-typescript">let sentence: string = 'Hello, my name is ' + name + '.\n\n' +
    'I\'ll be ' + (age + 1) + ' years old next month.'
</code></pre>
<h3><a id="%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数组</h3>
<p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p>
<pre><code class="language-typescript">let list: number[] = [1, 2, 3]
</code></pre>
<p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>
<pre><code class="language-typescript">let list: Array&lt;number&gt; = [1, 2, 3]
</code></pre>
<h3><a id="%E5%85%83%E7%BB%84tuple" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>元组 Tuple</h3>
<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p>
<pre><code class="language-typescript">let x: [string, number]
x = ['hello', 10] // OK
x = [10, 'hello'] // Error
</code></pre>
<p>当访问一个已知索引的元素，会得到正确的类型：</p>
<pre><code class="language-typescript">console.log(x[0].substr(1)) // OK
console.log(x[1].substr(1)) // Error, 'number' 不存在 'substr' 方法
</code></pre>
<p>当访问一个越界的元素，会使用联合类型替代：</p>
<pre><code class="language-typescript">x[3] = 'world' // OK, 字符串可以赋值给(string | number)类型

console.log(x[5].toString()) // OK, 'string' 和 'number' 都有 toString

x[6] = true // Error, 布尔不是(string | number)类型
</code></pre>
<p>联合类型是高级主题，我们会在以后的章节里讨论它。</p>
<p><strong>注意</strong>：自从 TyeScript 3.1 版本之后，访问越界元素会报错，我们不应该再使用该特性。</p>
<h3><a id="%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>枚举</h3>
<p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<pre><code class="language-typescript">enum Color {Red, Green, Blue}
let c: Color = Color.Green
</code></pre>
<p>默认情况下，从 <code>0</code> 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code> 开始编号：</p>
<pre><code class="language-typescript">enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green
</code></pre>
<p>或者，全部都采用手动赋值：</p>
<pre><code class="language-typescript">enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green
</code></pre>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p>
<pre><code class="language-typescript">enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2]

console.log(colorName)  // 显示'Green'因为上面代码里它的值是2
</code></pre>
<h3><a id="any" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>any</h3>
<p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量：</p>
<pre><code class="language-typescript">let notSure: any = 4
notSure = 'maybe a string instead'
notSure = false // 也可以是个 boolean
</code></pre>
<p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<pre><code class="language-typescript">let list: any[] = [1, true, 'free']

list[1] = 100
</code></pre>
<h3><a id="void" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>void</h3>
<p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>
<pre><code class="language-typescript">function warnUser(): void {
  console.log('This is my warning message')
}

</code></pre>
<p>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>：</p>
<pre><code class="language-typescript">let unusable: void = undefined
</code></pre>
<h3><a id="null%E5%92%8C-undefined" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>null 和 undefined</h3>
<p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。 和 <code>void</code> 相似，它们的本身的类型用处不是很大：</p>
<pre><code class="language-typescript">let u: undefined = undefined
let n: null = null
</code></pre>
<p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p>
<p>然而，当你指定了 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 <code>string</code> 或 <code>null</code> 或 <code>undefined</code>，你可以使用联合类型 <code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p>
<h3><a id="never" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>never</h3>
<p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code> 类型，当它们被永不为真的类型保护所约束时。</p>
<p><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 <code>never</code> 的子类型或可以赋值给<code>never</code> 类型（除了 <code>never</code> 本身之外）。 即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p>
<p>下面是一些返回 <code>never</code> 类型的函数：</p>
<pre><code class="language-typescript">// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
  throw new Error(message)
}

// 推断的返回值类型为never
function fail() {
  return error(&quot;Something failed&quot;)
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
  while (true) {
  }
}
</code></pre>
<h3><a id="object" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>object</h3>
<p><code>object</code> 表示非原始类型，也就是除 <code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code> 之外的类型。</p>
<p>使用 <code>object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code>。例如：</p>
<pre><code class="language-typescript">declare function create(o: object | null): void

create({ prop: 0 }) // OK
create(null) // OK

create(42) // Error
create('string') // Error
create(false) // Error
create(undefined) // Error
</code></pre>
<h3><a id="%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型断言</h3>
<p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>
<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<pre><code class="language-typescript">let someValue: any = 'this is a string'

let strLength: number = (&lt;string&gt;someValue).length
</code></pre>
<p>另一个为 <code>as</code> 语法：</p>
<pre><code class="language-typescript">let someValue: any = 'this is a string'

let strLength: number = (someValue as string).length
</code></pre>
<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 <code>as</code> 语法断言是被允许的。</p>
<h2><a id="%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>变量声明</h2>
<p><code>let</code> 和 <code>const</code> 是 JavaScript 里相对较新的变量声明方式。<code>let</code> 在很多方面与 <code>var</code> 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。<code>const</code> 是对 <code>let</code> 的一个增强，它能阻止对一个变量再次赋值。</p>
<p>因为 TypeScript 是 JavaScript 的超集，所以它本身就支持 <code>let</code> 和 <code>const</code>。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 <code>var</code>。</p>
<p>如果你已经对 <code>var</code> 声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p>
<h3><a id="var%E5%A3%B0%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>var 声明</h3>
<p>在 ES5 的时代，我们都是通过 <code>var</code> 关键字定义JavaScript 变量：</p>
<pre><code class="language-javascript">var a = 10
</code></pre>
<p>大家都能理解，这里定义了一个名为 <code>a</code> 值为 <code>10</code> 的变量。</p>
<p>我们也可以在函数内部定义变量：</p>
<pre><code class="language-javascript">function f() {
  var message = 'Hello World!'

  return message
}
</code></pre>
<p>并且我们也可以在其它函数内部访问相同的变量：</p>
<pre><code class="language-javascript">function f() {
  var a = 10
  return function g() {
    var b = a + 1
    return b
  }
}

var g = f()
g() // returns 11
</code></pre>
<p>上面的例子是一个典型的闭包场景，<code>g</code> 可以获取到 <code>f</code> 函数里定义的 <code>a</code> 变量。 每当 <code>g</code> 被调用时，它都可以访问到 <code>f</code> 里的 <code>a</code> 变量。 即使当 <code>g</code> 在 <code>f</code> 已经执行完后才被调用，它仍然可以访问 <code>a</code>。</p>
<h3><a id="%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>作用域规则</h3>
<p><code>var</code> 声明有些奇怪的作用域规则。 看下面的例子：</p>
<pre><code class="language-javascript">function f(shouldInitialize) {
  if (shouldInitialize) {
    var x = 10
  }

  return x
}

f(true)  // returns '10'
f(false) // returns 'undefined'
</code></pre>
<p>有些同学可能要多看几遍这个例子。 变量 <code>x</code> 是定义在 <code>if</code> 语句里面，但是我们却可以在语句的外面访问它。 这是因为 <code>var</code> 声明的作用域是函数作用域，函数参数也使用函数作用域。</p>
<p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p>
<pre><code class="language-javascript">function sumMatrix(matrix) {
  var sum = 0
  for (var i = 0; i &lt; matrix.length; i++) {
    var currentRow = matrix[i]
    for (var i = 0; i &lt; currentRow.length; i++) {
      sum += currentRow[i]
    }
  }
  
  return sum
}
</code></pre>
<p>这里很容易看出一些问题，里层的 <code>for</code> 循环会覆盖变量 <code>i</code>，因为所有 <code>i</code> 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p>
<h3><a id="%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F%E6%80%AA%E5%BC%82%E4%B9%8B%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>捕获变量怪异之处</h3>
<p>猜一下下面的代码会返回什么：</p>
<pre><code class="language-javascript">for (var i = 0; i &lt; 10; i++) {
  setTimeout(function() {
    console.log(i)
  }, 100 * i)
}
</code></pre>
<p>答案是，<code>setTimeout</code> 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）：</p>
<pre><code class="language-javascript">10
10
10
10
10
10
10
10
10
10
</code></pre>
<p>很多 JavaScript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样：</p>
<pre><code class="language-javascript">0
1
2
3
4
5
6
7
8
9
</code></pre>
<blockquote>
<p>我们传给 <code>setTimeout</code> 的每一个函数表达式实际上都引用了相同作用域里的同一个 <code>i</code>。</p>
</blockquote>
<p>让我们花点时间思考一下这是为什么。 <code>setTimeout</code> 在若干毫秒后执行一个函数，并且是在 <code>for</code> 循环结束后。<code>for</code> 循环结束后，<code>i</code> 的值为 <code>10</code>。 所以当函数被调用的时候，它会打印出 <code>10</code>。</p>
<p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 <code>i</code> 的值：</p>
<pre><code class="language-javascript">for (var i = 0; i &lt; 10; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i)
    }, 100 * i)
  })(i)
}
</code></pre>
<p>这种奇怪的形式我们已经司空见惯了。 参数 <code>i</code> 会覆盖 <code>for</code> 循环里的 <code>i</code>，但是因为我们起了同样的名字，所以我们不用怎么改 <code>for</code> 循环体里的代码。</p>
<h3><a id="let%E5%A3%B0%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>let 声明</h3>
<p>现在你已经知道了 <code>var</code> 存在一些问题，这恰好说明了为什么用 <code>let</code> 语句来声明变量。 除了名字不同外， <code>let</code> 与 <code>var</code> 的写法一致：</p>
<pre><code class="language-javascript">let hello = 'Hello!'
</code></pre>
<p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p>
<h3><a id="%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>块作用域</h3>
<p>当用 <code>let</code> 声明一个变量，它使用的是块作用域。 不同于使用 <code>var</code> 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 <code>for</code> 循环之外是不能访问的。</p>
<pre><code class="language-typescript">function f(input: boolean) {
  let a = 100

  if (input) {
    // OK: 仍然能访问到 a
    let b = a + 1
    return b
  }

  // Error: 'b' 在这里不存在
  return b
}
</code></pre>
<p>这里我们定义了 2 个变量 <code>a</code> 和 <code>b</code>。 <code>a</code> 的作用域是 <code>f</code> 函数体内，而 <code>b</code> 的作用域是 <code>if</code> 语句块里。</p>
<p>在 <code>catch</code> 语句里声明的变量也具有同样的作用域规则。</p>
<pre><code class="language-typescript">try {
  throw 'Oh no!';
}
catch (e) {
  console.log('Catch it.')
}

// Error: 'e' 在这里不存在
console.log(e)
</code></pre>
<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于<em>暂时性死区</em>。 它只是用来说明我们不能在 <code>let</code> 语句之前访问它们，幸运的是 <code>TypeScript</code> 可以告诉我们这些信息。</p>
<pre><code class="language-typescript">a++ // TS2448: Block-scoped variable 'a' used before its declaration.
let a
</code></pre>
<p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 ES2015，现代的运行时会抛出一个错误；然而，现今 TypeScript 是不会报错的。</p>
<pre><code class="language-typescript">function foo() {
  // okay to capture 'a'
  return a
}

// 不能在'a'被声明前调用'foo'
// 运行时应该抛出错误
foo()

let a
</code></pre>
<p>关于<em>暂时性死区</em>的更多信息，查看这里 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let">Mozilla Developer Network</a>。</p>
<h3><a id="%E9%87%8D%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%B1%8F%E8%94%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重定义及屏蔽</h3>
<p>我们提过使用 <code>var</code> 声明时，它不在乎你声明多少次；你只会得到 1 个。</p>
<pre><code class="language-javascript">function f(x) {
  var x
  var x

  if (true) {
    var x
  }
}
</code></pre>
<p>在上面的例子里，所有 <code>x</code> 的声明实际上都引用一个相同的<code>x</code>，并且这是完全有效的代码，但这经常会成为 <code>bug</code> 的来源。幸运的是 <code>let</code> 的声明就不会这么宽松了。</p>
<pre><code class="language-typescript">let x = 10
let x = 20 // 错误，不能在 1 个作用域里多次声明 x
</code></pre>
<p>并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。</p>
<pre><code class="language-typescript">function f(x) {
  let x = 100 // Error: 干扰参数声明
}

function g() {
  let x = 100
  var x = 100 // Error: 不能同时具有 x 的两个声明
}
</code></pre>
<p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p>
<pre><code class="language-typescript">function f(condition, x) {
  if (condition) {
    let x = 100
    return x
  }

  return x
}

f(false, 0) // returns 0
f(true, 0)  // returns 100
</code></pre>
<p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 <code>let</code> 重写之前的 <code>sumMatrix</code> 函数。</p>
<pre><code class="language-typescript">function sumMatrix(matrix: number[][]) {
  let sum = 0
  for (let i = 0; i &lt; matrix.length; i++) {
    let currentRow = matrix[i]
    for (let i = 0; i &lt; currentRow.length; i++) {
      sum += currentRow[i]
    }
  }

  return sum
}
</code></pre>
<p>这个版本的循环能得到正确的结果，因为内层循环的 <code>i</code> 可以屏蔽掉外层循环的 <code>i</code>。</p>
<p>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。</p>
<h3><a id="%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%98%E9%87%8F%E7%9A%84%E8%8E%B7%E5%8F%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>块级作用域变量的获取</h3>
<p>每次进入一个作用域时，<code>let</code> 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p>
<p>回想一下前面 <code>setTimeout</code> 的例子，我们最后需要使用立即执行的函数表达式来获取每次 <code>for</code> 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 <code>TypeScript</code> 里这样做了。</p>
<p>当 <code>let</code> 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 <code>setTimeout</code> 例子里我们仅使用 <code>let</code> 声明就可以了。</p>
<pre><code class="language-typescript">for (let i = 0; i &lt; 10 ; i++) {
  setTimeout(function() {
    console.log(i)
  }, 100 * i)
}
</code></pre>
<p>会输出与预料一致的结果：</p>
<pre><code class="language-javascript">0
1
2
3
4
5
6
7
8
9
</code></pre>
<h3><a id="const%E5%A3%B0%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>const 声明</h3>
<p><code>const</code> 声明是声明变量的另一种方式。</p>
<pre><code class="language-typescript">const numLivesForCat = 9
</code></pre>
<p>它们与 <code>let</code> 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 <code>let</code> 相同的作用域规则，但是不能对它们重新赋值。</p>
<p>这很好理解，它们引用的值是不可变的。</p>
<pre><code class="language-typescript">const numLivesForCat = 9
const kitty = {
  name: 'Kitty',
  numLives: numLivesForCat
}

// Error
kitty = {
  name: 'Tommy',
  numLives: numLivesForCat
};

// OK
kitty.name = 'Jerry'
kitty.numLives--
</code></pre>
<p>除非你使用特殊的方法去避免，实际上 <code>const</code> 变量的内部状态是可修改的。 幸运的是，<code>TypeScript</code> 允许你将对象的成员设置成只读的。接口一章有详细说明。</p>
<h3><a id="let-vs-const" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>let vs. const</h3>
<p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。</p>
<p>使用最小特权原则，所有变量除了你计划去修改的都应该使用 <code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 <code>const</code> 也可以让我们更容易的推测数据的流动。</p>
<h3><a id="%E8%A7%A3%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解构</h3>
<h4><a id="%E8%A7%A3%E6%9E%84%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解构数组</h4>
<p>最简单的解构莫过于数组的解构赋值了：</p>
<pre><code class="language-typescript">let input = [1, 2]
let [first, second] = input
console.log(first) // outputs 1
console.log(second) // outputs 2
</code></pre>
<p>这创建了 2 个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p>
<pre><code class="language-typescript">let first = input[0]
let second = input[1]
</code></pre>
<p>作用于函数参数：</p>
<pre><code class="language-typescript">let input: [number, number] = [1, 2]

function f([first, second]: [number, number]) {
  console.log(first)
  console.log(second)
}

f(input)
</code></pre>
<p>你可以在数组里使用 <code>...</code> 语法创建剩余变量：</p>
<pre><code class="language-typescript">let [first, ...rest] = [1, 2, 3, 4]
console.log(first) // outputs 1
console.log(rest) // outputs [ 2, 3, 4 ]
</code></pre>
<p>你也可以忽略你不关心的尾随元素：</p>
<pre><code class="language-typescript">let [first] = [1, 2, 3, 4]
console.log(first) // outputs 1
</code></pre>
<p>或其它元素：</p>
<pre><code class="language-typescript">let [, second, , fourth] = [1, 2, 3, 4]
</code></pre>
<h4><a id="%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对象解构</h4>
<p>你也可以解构对象：</p>
<pre><code class="language-typescript">let o = {
    a: 'foo',
    b: 12,
    c: 'bar'
}
let { a, b } = o

</code></pre>
<p>这通过 <code>o.a</code> 和 <code>o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。</p>
<p>你可以在对象里使用 <code>...</code> 语法创建剩余变量：</p>
<pre><code class="language-typescript">let { a, ...passthrough } = o
let total = passthrough.b + passthrough.c.length
</code></pre>
<h4><a id="%E5%B1%9E%E6%80%A7%E9%87%8D%E5%91%BD%E5%90%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>属性重命名</h4>
<p>你也可以给属性以不同的名字：</p>
<pre><code class="language-typescript">let { a: newName1, b: newName2 } = o
</code></pre>
<p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 <code>&quot;a 作为 newName1&quot;</code>。 方向是从左到右，好像你写成了以下样子：</p>
<pre><code class="language-typescript">let newName1 = o.a
let newName2 = o.b
</code></pre>
<p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。</p>
<pre><code class="language-typescript">let {a, b}: {a: string, b: number} = o
</code></pre>
<h4><a id="%E9%BB%98%E8%AE%A4%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>默认值</h4>
<p>默认值可以让你在属性为 <code>undefined</code> 时使用缺省值：</p>
<pre><code class="language-typescript">function keepWholeObject(wholeObject: { a: string, b?: number }) {
  let { a, b = 1001 } = wholeObject
}
</code></pre>
<p>现在，即使 <code>b</code> 为 <code>undefined</code> ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p>
<h4><a id="%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数声明</h4>
<p>解构也能用于函数声明。 看以下简单的情况：</p>
<pre><code class="language-typescript">type C = { a: string, b?: number }
function f({ a, b }: C): void {
  // ...
}
</code></pre>
<p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p>
<pre><code class="language-typescript">function f({ a = '', b = 0 } = {}): void {
  // ...
}
f()
</code></pre>
<blockquote>
<p>上面的代码是一个类型推断的例子，将在后续章节介绍。</p>
</blockquote>
<p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p>
<pre><code class="language-typescript">function f({ a, b = 0 } = { a: '' }): void {
  // ...
}
f({ a: 'yes' }) // OK, 默认 b = 0
f() // OK, 默认 a: '', b = 0
f({}) // Error, 一旦传入参数则 a 是必须的
</code></pre>
<p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。</p>
<h3><a id="%E5%B1%95%E5%BC%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>展开</h3>
<pre><code class="language-typescript">let first = [1, 2]
let second = [3, 4]
let bothPlus = [0, ...first, ...second, 5]
</code></pre>
<p>这会令 <code>bothPlus</code> 的值为 <code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code> 和 <code>second的</code> 一份浅拷贝。 它们不会被展开操作所改变。</p>
<p>你还可以展开对象：</p>
<pre><code class="language-typescript">let defaults = { food: 'spicy', price: '$10', ambiance: 'noisy' }
let search = { ...defaults, food: 'rich' }
</code></pre>
<p>search的值为 <code>{ food: 'rich', price: '$10', ambiance: 'noisy' }</code>。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>
<pre><code class="language-typescript">let defaults = { food: 'spicy', price: '$10', ambiance: 'noisy' }
let search = { food: 'rich', ...defaults }
</code></pre>
<p>那么，<code>defaults</code> 里的 <code>food</code> 属性会重写 <code>food: 'rich'</code>，在这里这并不是我们想要的结果。</p>
<h2><a id="%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口</h2>
<p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<h3><a id="%E6%8E%A5%E5%8F%A3%E5%88%9D%E6%8E%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口初探</h3>
<p>下面通过一个简单示例来观察接口是如何工作的：</p>
<pre><code class="language-typescript">function printLabel(labelledObj: { label: string }) {
  console.log(labelledObj.label)
}

let myObj = { size: 10, label: 'Size 10 Object' }
printLabel(myObj)
</code></pre>
<p>类型检查器会查看 <code>printLabel</code> 的调用。<code>printLabel</code> 有一个参数，并要求这个对象参数有一个名为 <code>label</code> 类型为 <code>string</code> 的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，以及其类型是否匹配。 然而，有些时候 TypeScript  却并不会这么宽松，我们下面会稍做讲解。</p>
<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code> 属性且类型为 <code>string</code>：</p>
<pre><code class="language-typescript">interface LabelledValue {
  label: string
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label)
}

let myObj = {size: 10, label: 'Size 10 Object'}
printLabel(myObj)
</code></pre>
<p><code>LabelledValue</code> 接口就好比一个名字，用来描述上面例子里的结构。 它代表了有一个 <code>label</code> 属性且类型为<code>string</code> 的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 <code>printLabel</code> 的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>
<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>
<h3><a id="%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可选属性</h3>
<p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。</p>
<pre><code class="language-typescript">interface Square {
  color: string,
  area: number
}

interface SquareConfig {
  color?: string
  width?: number
}

function createSquare (config: SquareConfig): Square {
  let newSquare = {color: 'white', area: 100}
  if (config.color) {
    newSquare.color = config.color
  }
  if (config.width) {
    newSquare.area = config.width * config.width
  }
  return newSquare
}

let mySquare = createSquare({color: 'black'})
</code></pre>
<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <code>?</code> 符号。</p>
<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 <code>createSquare</code> 里的 <code>color</code> 属性名拼错，就会得到一个错误提示：</p>
<pre><code class="language-typescript">interface Square {
  color: string,
  area: number
}

interface SquareConfig {
   color?: string;
   width?: number;
}
 
function createSquare(config: SquareConfig): Square {
   let newSquare = {color: 'white', area: 100}
   if (config.clor) {
     // Error: 属性 'clor' 不存在于类型 'SquareConfig' 中
     newSquare.color = config.clor
   }
   if (config.width) {
     newSquare.area = config.width * config.width
   }
   return newSquare
 }
 
 let mySquare = createSquare({color: 'black'})
</code></pre>
<h3><a id="%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>只读属性</h3>
<p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code> 来指定只读属性:</p>
<pre><code class="language-typescript">interface Point {
  readonly x: number
  readonly y: number
}
</code></pre>
<p>你可以通过赋值一个对象字面量来构造一个 <code>Point</code>。 赋值后，<code>x</code> 和 <code>y</code> 再也不能被改变了。</p>
<pre><code class="language-typescript">let p1: Point = { x: 10, y: 20 }
p1.x = 5 // error!
</code></pre>
<p>TypeScript 具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>
<pre><code class="language-typescript">let a: number[] = [1, 2, 3, 4]
let ro: ReadonlyArray&lt;number&gt; = a
ro[0] = 12 // error!
ro.push(5) // error!
ro.length = 100 // error!
a = ro // error!
</code></pre>
<p>上面代码的最后一行，可以看到就算把整个 <code>ReadonlyArray</code> 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>
<pre><code class="language-typescript">a = ro as number[]
</code></pre>
<h3><a id="readonly-vs-const" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>readonly vs const</h3>
<p>最简单判断该用 <code>readonly</code> 还是 <code>const</code> 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <code>const</code>，若做为属性则使用 <code>readonly</code>。</p>
<h3><a id="%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>额外的属性检查</h3>
<p>我们在第一个例子里使用了接口，TypeScript 让我们传入 <code>{ size: number; label: string; }</code> 到仅期望得到 <code>{ label: string; }</code> 的函数里, 并且我们已经学过了可选属性。</p>
<p>然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。 比如，拿 <code>createSquare</code> 例子来说：</p>
<pre><code class="language-typescript">interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare (config: SquareConfig): { color: string; area: number } {
  let newSquare = {color: 'white', area: 100}
  if (config.color) {
    newSquare.color = config.color
  }
  if (config.width) {
    newSquare.area = config.width * config.width
  }
  return newSquare
}


let mySquare = createSquare({ colour: 'red', width: 100 })
</code></pre>
<p>注意传入 <code>createSquare</code> 的参数拼写为 <code>colour</code> 而不是 <code>color</code>。 在 JavaScript 里，这会默默地失败。</p>
<p>你可能会争辩这个程序已经正确地类型化了，因为 <code>width</code> 属性是兼容的，不存在 <code>color</code> 属性，而且额外的 <code>colour</code> 属性是无意义的。</p>
<p>然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
<pre><code class="language-typescript">// error: 'colour' 不存在于类型 'SquareConfig' 中
let mySquare = createSquare({ colour: 'red', width: 100 })
</code></pre>
<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>
<pre><code class="language-typescript">let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig)
</code></pre>
<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 <code>SquareConfig</code> 带有上面定义的类型的 <code>color</code> 和 <code>width</code> 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string
  width?: number
  [propName: string]: any
}
</code></pre>
<p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code> 可以有任意数量的属性，并且只要它们不是 <code>color</code> 和 <code>width</code>，那么就无所谓它们的类型是什么。</p>
<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 <code>squareOptions</code> 不会经过额外属性检查，所以编译器不会报错。</p>
<pre><code class="language-typescript">let squareOptions = { colour: 'red', width: 100 }
let mySquare = createSquare(squareOptions)
</code></pre>
<p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大多数额外属性检查错误是真正的bug。也就是说你遇到了额外类型检查出的错误，你应该去审查一下你的类型声明。 在这里，如果支持传入 <code>color</code> 或 <code>colour</code> 属性到 <code>createSquare</code>，你应该修改 <code>SquareConfig</code> 定义来体现出这一点。</p>
<h3><a id="%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数类型</h3>
<p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<pre><code class="language-typescript">interface SearchFunc {
  (source: string, subString: string): boolean
}
</code></pre>
<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<pre><code class="language-typescript">let mySearch: SearchFunc
mySearch = function(source: string, subString: string): boolean {
  let result = source.search(subString);
  return result &gt; -1
}
</code></pre>
<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>
<pre><code class="language-typescript">let mySearch: SearchFunc
mySearch = function(src: string, sub: string): boolean {
  let result = src.search(sub);
  return result &gt; -1
}
</code></pre>
<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了  <code>SearchFunc</code> 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 <code>false</code> 和 <code>true</code>）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 <code>SearchFunc</code> 接口中的定义不匹配。</p>
<pre><code class="language-typescript">let mySearch: SearchFunc
mySearch = function(src, sub) {
  let result = src.search(sub)
  return result &gt; -1
}
</code></pre>
<h3><a id="%E5%8F%AF%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可索引的类型</h3>
<p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 <code>a[10]</code> 或 <code>ageMap['daniel']</code>。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>
<pre><code class="language-typescript">interface StringArray {
  [index: number]: string
}

let myArray: StringArray
myArray = ['Bob', 'Fred']

let myStr: string = myArray[0]
</code></pre>
<p>上面例子里，我们定义了 <code>StringArray</code> 接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code> 去索引 <code>StringArray</code> 时会得到 <code>string</code> 类型的返回值。</p>
<p>TypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 <code>number</code> 来索引时，JavaScript 会将它转换成<code>string</code> 然后再去索引对象。 也就是说用 <code>100</code>（一个 <code>number</code>）去索引等同于使用<code>'100'</code>（一个 <code>string</code> ）去索引，因此两者需要保持一致。</p>
<pre><code class="language-typescript">class Animal {
  name: string
}
class Dog extends Animal {
  breed: string
}

// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!
interface NotOkay {
  [x: number]: Animal
  [x: string]: Dog
}
</code></pre>
<p>字符串索引签名能够很好的描述 <code>dictionary</code> 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code> 和 <code>obj['property']</code> 两种形式都可以。 下面的例子里， <code>name</code> 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<pre><code class="language-typescript">interface NumberDictionary {
  [index: string]: number;
  length: number;    // 可以，length是number类型
  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
}
</code></pre>
<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<pre><code class="language-typescript">interface ReadonlyStringArray {
  readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = ['Alice', 'Bob'];
myArray[2] = 'Mallory'; // error!
</code></pre>
<h3><a id="%E7%B1%BB%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类类型</h3>
<h4><a id="%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现接口</h4>
<p>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p>
<pre><code class="language-typescript">interface ClockInterface {
  currentTime: Date
}

class Clock implements ClockInterface {
  currentTime: Date
  constructor(h: number, m: number) { }
}
</code></pre>
<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的 <code>setTime</code> 方法一样：</p>
<pre><code class="language-typescript">interface ClockInterface {
  currentTime: Date
  setTime(d: Date)
}

class Clock implements ClockInterface {
  currentTime: Date
  setTime(d: Date) {
    this.currentTime = d
  }
  constructor(h: number, m: number) { }
}
</code></pre>
<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>
<h4><a id="%E7%B1%BB%E9%9D%99%E6%80%81%E9%83%A8%E5%88%86%E4%B8%8E%E5%AE%9E%E4%BE%8B%E9%83%A8%E5%88%86%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类静态部分与实例部分的区别</h4>
<p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>
<pre><code class="language-typescript">interface ClockConstructor {
  new (hour: number, minute: number)
}

// error
class Clock implements ClockConstructor {
  currentTime: Date
  constructor(h: number, m: number) { }
}
</code></pre>
<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。<code>constructor</code> 存在于类的静态部分，所以不在检查的范围内。</p>
<p>看下面的例子，我们定义了两个接口，  <code>ClockConstructor</code> 为构造函数所用和 <code>ClockInterface</code> 为实例方法所用。 为了方便我们定义一个构造函数 <code>createClock</code>，它用传入的类型创建实例。</p>
<pre><code class="language-typescript">interface ClockConstructor {
  new (hour: number, minute: number): ClockInterface
}
interface ClockInterface {
  tick()
}

function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
  return new ctor(hour, minute)
}

class DigitalClock implements ClockInterface {
  constructor(h: number, m: number) { }
  tick() {
    console.log('beep beep')
  }
}
class AnalogClock implements ClockInterface {
  constructor(h: number, m: number) { }
  tick() {
    console.log('tick tock')
  }
}

let digital = createClock(DigitalClock, 12, 17)
let analog = createClock(AnalogClock, 7, 32)
</code></pre>
<p>因为 <code>createClock</code> 的第一个参数是 <code>ClockConstructor</code> 类型，在 <code>createClock(AnalogClock, 7, 32)</code> 里，会检查 <code>AnalogClock</code> 是否符合构造函数签名。</p>
<h4><a id="%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>继承接口</h4>
<p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<pre><code class="language-typescript">interface Shape {
  color: string
}

interface Square extends Shape {
  sideLength: number
}

let square = {} as Square
square.color = 'blue'
square.sideLength = 10
</code></pre>
<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<pre><code class="language-typescript">interface Shape {
  color: string
}

interface PenStroke {
  penWidth: number
}

interface Square extends Shape, PenStroke {
  sideLength: number
}

let square = {} as Square
square.color = 'blue'
square.sideLength = 10
square.penWidth = 5.0
</code></pre>
<h3><a id="%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>混合类型</h3>
<p>先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>
<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
<pre><code class="language-typescript">interface Counter {
  (start: number): string
  interval: number
  reset(): void
}

function getCounter(): Counter {
  let counter = (function (start: number) { }) as Counter
  counter.interval = 123
  counter.reset = function () { }
  return counter
}

let c = getCounter()
c(10)
c.reset()
c.interval = 5.0
</code></pre>
<p>在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。这门课要重构的 <code>axios</code> 库就是一个很好的例子。</p>
<h3><a id="%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口继承类</h3>
<p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 <code>private</code> 和 <code>protected</code> 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>
<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。例：</p>
<pre><code class="language-typescript">class Control {
  private state: any
}

interface SelectableControl extends Control {
  select(): void
}

class Button extends Control implements SelectableControl {
  select() { }
}

class TextBox extends Control {
  select() { }
}

// Error：“ImageC”类型缺少“state”属性。
class ImageC implements SelectableControl {
  select() { }
}
</code></pre>
<p>在上面的例子里，<code>SelectableControl</code> 包含了 <code>Control</code> 的所有成员，包括私有成员 <code>state</code>。 因为 <code>state</code> 是私有成员，所以只能够是 <code>Control</code> 的子类们才能实现 <code>SelectableControl</code> 接口。 因为只有 <code>Control</code> 的子类才能够拥有一个声明于<code>Control</code> 的私有成员 <code>state</code>，这对私有成员的兼容性是必需的。</p>
<p>在 <code>Control</code> 类内部，是允许通过 <code>SelectableControl</code> 的实例来访问私有成员 <code>state</code> 的。 实际上，<code>SelectableControl</code> 接口和拥有 <code>select</code> 方法的 <code>Control</code> 类是一样的。<code>Button</code>和 <code>TextBox</code> 类是 <code>SelectableControl</code> 的子类（因为它们都继承自<code>Control</code> 并有 <code>select</code> 方法），但 <code>ImageC</code> 类并不是这样的。</p>
<h2><a id="%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类</h2>
<p>对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。</p>
<h3><a id="%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本示例</h3>
<p>下面看一个使用类的例子：</p>
<pre><code class="language-typescript">class Greeter {
  greeting: string
  constructor(message: string) {
    this.greeting = message
  }
  greet() {
    return 'Hello, ' + this.greeting
  }
}

let greeter = new Greeter('world')
</code></pre>
<p>如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 <code>Greeter</code> 类。这个类有 3 个成员：一个叫做 <code>greeting</code> 的属性，一个构造函数和一个 <code>greet</code> 方法。</p>
<p>你会注意到，我们在引用任何一个类成员的时候都用了 <code>this</code>。 它表示我们访问的是类的成员。</p>
<p>最后一行，我们使用 <code>new</code> 构造了 <code>Greeter</code> 类的一个实例。它会调用之前定义的构造函数，创建一个 <code>Greeter</code> 类型的新对象，并执行构造函数初始化它。</p>
<h3><a id="%E7%BB%A7%E6%89%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>继承</h3>
<p>在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>
<p>看下面的例子：</p>
<pre><code class="language-typescript">class Animal {
  move(distance: number = 0) {
    console.log(`Animal moved ${distance}m.`)
  }
}

class Dog extends Animal {
  bark() {
    console.log('Woof! Woof!')
  }
}

const dog = new Dog()
dog.bark()
dog.move(10)
</code></pre>
<p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，<code>Dog</code> 是一个 派生类，它派生自 <code>Animal</code> 基类，通过 <code>extends</code> 关键字。 派生类通常被称作<em>子类</em>，基类通常被称作<em>超类</em>。</p>
<p>因为 <code>Dog</code> 继承了 <code>Animal</code> 的功能，因此我们可以创建一个 <code>Dog</code> 的实例，它能够 <code>bark()</code> 和 <code>move()</code>。</p>
<p>下面我们来看个更加复杂的例子。</p>
<pre><code class="language-typescript">class Animal {
  name: string
  constructor(name: string) { 
    this.name = name
  }
  move(distance: number = 0) {
    console.log(`${this.name} moved ${distance}m.`)
  }
}

class Snake extends Animal {
  constructor(name: string) { 
    super(name)
  }
  move(distance: number = 5) {
    console.log('Slithering...')
    super.move(distance)
  }
}

class Horse extends Animal {
  constructor(name: string) {
    super(name)
  }
  move(distance: number = 45) {
    console.log('Galloping...')
    super.move(distance)
  }
}

let sam = new Snake('Sammy')
let tom: Animal = new Horse('Tommy')

sam.move()
tom.move(34)
</code></pre>
<p>这个例子展示了一些上面没有提到的特性。 这一次，我们使用 <code>extends</code> 关键字创建了 Animal的两个子类：<code>Horse</code> 和 <code>Snake</code>。</p>
<p>与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 <code>super()</code>，它会执行基类的构造函数。 而且，在构造函数里访问 <code>this</code> 的属性之前，我们 一定要调用 <code>super()</code>。 这个是 TypeScript 强制执行的一条重要规则。</p>
<p>这个例子演示了如何在子类里可以重写父类的方法。<code>Snake</code>类和 <code>Horse</code> 类都创建了 <code>move</code> 方法，它们重写了从 <code>Animal</code> 继承来的 <code>move</code> 方法，使得 <code>move</code> 方法根据不同的类而具有不同的功能。注意，即使 <code>tom</code> 被声明为 <code>Animal</code> 类型，但因为它的值是 <code>Horse</code>，调用 <code>tom.move(34)</code> 时，它会调用 <code>Horse</code> 里重写的方法。</p>
<pre><code class="language-plain_text">Slithering...
Sammy moved 5m.
Galloping...
Tommy moved 34m.
</code></pre>
<h3><a id="%E5%85%AC%E5%85%B1%EF%BC%8C%E7%A7%81%E6%9C%89%E4%B8%8E%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>公共，私有与受保护的修饰符</h3>
<h4><a id="%E9%BB%98%E8%AE%A4%E4%B8%BApublic" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>默认为 public</h4>
<p>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 <code>public</code> 来做修饰；例如，C# 要求必须明确地使用 <code>public</code> 指定成员是可见的。 在 TypeScript 里，成员都默认为 <code>public</code>。</p>
<p>你也可以明确的将一个成员标记成 <code>public</code>。 我们可以用下面的方式来重写上面的 <code>Animal</code> 类：</p>
<pre><code class="language-typescript">class Animal {
  public name: string
  public constructor(name: string) {
    this.name = name
  }
  public move(distance: number) {
    console.log(`${this.name} moved ${distance}m.`)
  }
}
</code></pre>
<h4><a id="%E7%90%86%E8%A7%A3private" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>理解 private</h4>
<p>当成员被标记成 <code>private</code> 时，它就不能在声明它的类的外部访问。比如：</p>
<pre><code class="language-typescript">class Animal {
  private name: string
  constructor(name: string) { 
    this.name = name
  }
}

new Animal('Cat').name // 错误: 'name' 是私有的.
</code></pre>
<p>TypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p>
<p>然而，当我们比较带有 <code>private</code> 或 <code>protected</code> 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 <code>private</code> 成员，那么只有当另外一个类型中也存在这样一个 <code>private</code> 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 <code>protected</code> 成员也使用这个规则。</p>
<p>下面来看一个例子，更好地说明了这一点：</p>
<pre><code class="language-typescript">class Animal {
  private name: string
  constructor(name: string) { 
    this.name = name 
  }
}

class Rhino extends Animal {
  constructor() { 
    super('Rhino')
  }
}

class Employee {
  private name: string
  constructor(name: string) { 
    this.name = name
  }
}

let animal = new Animal('Goat')
let rhino = new Rhino()
let employee = new Employee('Bob')

animal = rhino
animal = employee // 错误: Animal 与 Employee 不兼容.
</code></pre>
<p>这个例子中有 <code>Animal</code> 和 <code>Rhino</code> 两个类， <code>Rhino</code> 是 <code>Animal</code> 类的子类。 还有一个 <code>Employee</code> 类，其类型看上去与 <code>Animal</code> 是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 <code>Animal</code> 和 <code>Rhino</code> 共享了来自 <code>Animal</code> 里的私有成员定义 <code>private name: string</code>，因此它们是兼容的。然而 <code>Employee</code> 却不是这样。当把 <code>Employee</code> 赋值给 <code>Animal</code> 的时候，得到一个错误，说它们的类型不兼容。尽管 <code>Employee</code> 里也有一个私有成员 <code>name</code>，但它明显不是 <code>Animal</code> 里面定义的那个。</p>
<h4><a id="%E7%90%86%E8%A7%A3protected" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>理解 protected</h4>
<p><code>protected</code> 修饰符与 <code>private</code> 修饰符的行为很相似，但有一点不同，<code>protected</code>成员在派生类中仍然可以访问。例如：</p>
<pre><code class="language-typescript">class Person {
  protected name: string
  constructor(name: string) { 
    this.name = name 
  }
}

class Employee extends Person {
  private department: string

  constructor(name: string, department: string) {
    super(name)
    this.department = department
  }
  
  getElevatorPitch() {
    return `Hello, my name is ${this.name} and I work in ${this.department}.`
  }
}

let howard = new Employee('Howard', 'Sales')
console.log(howard.getElevatorPitch())
console.log(howard.name) // error
</code></pre>
<p>注意，我们不能在 <code>Person</code> 类外使用 <code>name</code>，但是我们仍然可以通过 <code>Employee</code> 类的实例方法访问，因为 <code>Employee</code> 是由 <code>Person</code>  派生而来的。</p>
<p>构造函数也可以被标记成 <code>protected</code>。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如：</p>
<pre><code class="language-typescript">class Person {
  protected name: string
  protected constructor(name: string) {
    this.name = name
  }
}

// Employee 能够继承 Person
class Employee extends Person {
  private department: string

  constructor(name: string, department: string) {
    super(name)
    this.department = department
  }

  public getElevatorPitch() {
    return `Hello, my name is ${this.name} and I work in ${this.department}.`
  }
}

let howard = new Employee('Howard', 'Sales')
let john = new Person('John') // 错误: 'Person' 的构造函数是被保护的.
</code></pre>
<h3><a id="readonly%E4%BF%AE%E9%A5%B0%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>readonly 修饰符</h3>
<p>你可以使用 <code>readonly</code> 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>
<pre><code class="language-typescript">class Person {
  readonly name: string
  constructor(name: string) {
    this.name = name
  }
}

let john = new Person('John')
john.name = 'peter'
</code></pre>
<h3><a id="%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数属性</h3>
<p>在上面的例子中，我们必须在 <code>Person</code> 类里定义一个只读成员 <code>name</code> 和一个参数为 <code>name</code> 的构造函数，并且立刻将 <code>name</code> 的值赋给 <code>this.name</code>，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 <code>Person</code> 类的修改版，使用了参数属性：</p>
<pre><code class="language-typescript">class Person {
  constructor(readonly name: string) {
  }
}
</code></pre>
<p>注意看我们是如何舍弃参数 <code>name</code>，仅在构造函数里使用 <code>readonly name: string</code> 参数来创建和初始化 <code>name</code> 成员。 我们把声明和赋值合并至一处。</p>
<p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 <code>private</code> 限定一个参数属性会声明并初始化一个私有成员；对于 <code>public</code> 和 <code>protected</code> 来说也是一样。</p>
<h3><a id="%E5%AD%98%E5%8F%96%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>存取器</h3>
<p><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>
<p>下面来看如何把一个简单的类改写成使用 <code>get</code> 和 <code>set</code>。 首先，我们从一个没有使用存取器的例子开始。</p>
<pre><code class="language-typescript">class Employee {
  fullName: string
}

let employee = new Employee()
employee.fullName = 'Bob Smith'
if (employee.fullName) {
  console.log(employee.fullName)
}
</code></pre>
<p>我们可以设置 <code>fullName</code>，因为它是 <code>public</code> 的，有时候当我们去修改它的时候触发一些额外逻辑，存取器就派上用场了。</p>
<p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。我们把对 <code>fullName</code> 的直接访问改成了可以检查密码的 <code>set</code> 方法。 我们也加了一个 <code>get</code> 方法，让上面的例子仍然可以工作。</p>
<pre><code class="language-typescript">let passcode = 'secret passcode'

class Employee {
  private _fullName: string

  get fullName(): string {
    return this._fullName
  }

  set fullName(newName: string) {
    if (passcode &amp;&amp; passcode == 'secret passcode') {
      this._fullName = newName
    }
    else {
      console.log('Error: Unauthorized update of employee!')
    }
  }
}

let employee = new Employee()
employee.fullName = 'Bob Smith'
if (employee.fullName) {
  console.log(employee.fullName)
}
</code></pre>
<p>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。</p>
<p>对于存取器有下面几点需要注意的：</p>
<p>首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。其次，只带有 <code>get</code> 不带有 <code>set</code> 的存取器自动被推断为 <code>readonly</code>。这在从代码生成 <code>.d.ts</code> 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p>
<h3><a id="%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态属性</h3>
<p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 <code>static</code> 定义 <code>origin</code>，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 <code>origin</code> 前面加上类名。 如同在实例属性上使用 <code>this.xxx</code> 来访问属性一样，这里我们使用 <code>Grid.xxx</code> 来访问静态属性。</p>
<pre><code class="language-typescript">class Grid {
  static origin = {x: 0, y: 0}

  scale: number

  constructor (scale: number) {
    this.scale = scale
  }

  calculateDistanceFromOrigin(point: {x: number; y: number}) {
    let xDist = point.x - Grid.origin.x
    let yDist = point.y - Grid.origin.y
    return Math.sqrt(xDist * xDist + yDist * yDist) * this.scale
  }
}

let grid1 = new Grid(1.0)  // 1x scale
let grid2 = new Grid(5.0)  // 5x scale

console.log(grid1.calculateDistanceFromOrigin({x: 3, y: 4}))
console.log(grid2.calculateDistanceFromOrigin({x: 3, y: 4}))
</code></pre>
<h3><a id="%E6%8A%BD%E8%B1%A1%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>抽象类</h3>
<p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 <code>abstract</code> 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<pre><code class="language-typescript">abstract class Animal {
  abstract makeSound(): void
  move(): void {
    console.log('roaming the earth...')
  }
}
</code></pre>
<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 <code>abstract</code> 关键字并且可以包含访问修饰符。</p>
<pre><code class="language-typescript">abstract class Department {
  name: string

  constructor(name: string) {
     this.name = name
  }

  printName(): void {
    console.log('Department name: ' + this.name)
  }

  abstract printMeeting(): void // 必须在派生类中实现
}

class AccountingDepartment extends Department {
  constructor() {
    super('Accounting and Auditing') // 在派生类的构造函数中必须调用 super()
  }

  printMeeting(): void {
    console.log('The Accounting Department meets each Monday at 10am.')
  }

  generateReports(): void {
    console.log('Generating accounting reports...')
  }
}

let department: Department // 允许创建一个对抽象类型的引用
department = new Department() // 错误: 不能创建一个抽象类的实例
department = new AccountingDepartment() // 允许对一个抽象子类进行实例化和赋值
department.printName()
department.printMeeting()
department.generateReports() // 错误: 方法在声明的抽象类中不存在
</code></pre>
<h3><a id="%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高级技巧</h3>
<h4><a id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>构造函数</h4>
<p>当你在 TypeScript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的<em>实例</em>的类型。</p>
<pre><code class="language-typescript">class Greeter {
  static standardGreeting = 'Hello, there'
  greeting: string
  constructor(message: string) {
    this.greeting = message
  }
  greet() {
    return 'Hello, ' + this.greeting
  }
}

let greeter: Greeter
greeter = new Greeter('world')
console.log(greeter.greet())
</code></pre>
<p>这里，我们写了 <code>let greeter: Greeter</code>，意思是 <code>Greeter</code> 类的实例的类型是 <code>Greeter</code>。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p>
<p>我们也创建了一个叫做<em>构造函数的值</em>。 这个函数会在我们使用 <code>new</code> 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：</p>
<pre><code class="language-javascript">var Greeter = /** @class */ (function () {
  function Greeter(message) {
    this.greeting = message;
  }
  Greeter.prototype.greet = function () {
    return 'Hello, ' + this.greeting;
  };
  Greeter.standardGreeting = 'Hello, there';
  return Greeter;
}());
var greeter;
greeter = new Greeter('world');
console.log(greeter.greet());
</code></pre>
<p>上面的代码里，<code>var Greeter</code> 将被构造函数赋值。 当我们调用 <code>new</code> 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有<em>实例部分</em>与<em>静态部分</em>这两个部分。</p>
<p>让我们稍微改写一下这个例子，看看它们之间的区别：</p>
<pre><code class="language-typescript">class Greeter {
  static standardGreeting = 'Hello, there'
  
  greeting: string

  constructor(message?: string) {
    this.greeting = message
  }

  greet() {
    if (this.greeting) {
      return 'Hello, ' + this.greeting
    } else {
      return Greeter.standardGreeting
    }
  }
}

let greeter: Greeter
greeter = new Greeter()
console.log(greeter.greet())

let greeterMaker: typeof Greeter = Greeter
greeterMaker.standardGreeting = 'Hey there'

let greeter2: Greeter = new greeterMaker()
console.log(greeter2.greet())
</code></pre>
<p>这个例子里， <code>greeter1</code> 与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。</p>
<p>再之后，我们直接使用类。 我们创建了一个叫做 <code>greeterMaker</code> 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 <code>typeof Greeter</code>，意思是取 <code>Greeter</code> 类的类型，而不是实例的类型。或者更确切的说，&quot;告诉我 <code>Greeter</code> 标识符的类型&quot;，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 <code>greeterMaker</code> 上使用 <code>new</code>，创建 <code>Greeter</code> 的实例。</p>
<h4><a id="%E6%8A%8A%E7%B1%BB%E5%BD%93%E5%81%9A%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>把类当做接口使用</h4>
<p>如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p>
<pre><code class="language-typescript">class Point {
  x: number
  y: number
}

interface Point3d extends Point {
  z: number
}

let point3d: Point3d = {x: 1, y: 2, z: 3}
</code></pre>
<h2><a id="%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数</h2>
<p>函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。</p>
<h3><a id="%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本示例</h3>
<p>和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。</p>
<p>通过下面的例子可以迅速回想起这两种 JavaScript 中的函数：</p>
<pre><code class="language-javascript">// 命名函数
function add(x, y) {
  return x + y
}

// 匿名函数
let myAdd = function(x, y) { 
  return x + y;
}
</code></pre>
<p>在 JavaScript 里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习 JavaScript 和 TypeScript 会很有帮助。</p>
<pre><code class="language-javascript">let z = 100

function addToZ(x, y) {
  return x + y + z
}
</code></pre>
<h3><a id="%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数类型</h3>
<h4><a id="%E4%B8%BA%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为函数定义类型</h4>
<p>让我们为上面那个函数添加类型：</p>
<pre><code class="language-typescript">function add(x: number, y: number): number {
  return x + y
}

let myAdd = function(x: number, y: number): number { 
  return x + y
}
</code></pre>
<p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。</p>
<h4><a id="%E4%B9%A6%E5%86%99%E5%AE%8C%E6%95%B4%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>书写完整函数类型</h4>
<p>现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。</p>
<pre><code class="language-typescript">let myAdd: (x: number, y: number) =&gt; number = 
function(x: number, y: number): number {
  return x + y
}

</code></pre>
<p>函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。 我们也可以这么写：</p>
<pre><code class="language-typescript">let myAdd: (baseValue: number, increment: number) =&gt; number = 
function(x: number, y: number): number {
  return x + y
}
</code></pre>
<p>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</p>
<p>第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(<code>=&gt;</code>)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 <code>void</code> 而不能留空。</p>
<p>函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成 API 的一部分。</p>
<h3><a id="%E6%8E%A8%E6%96%AD%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>推断类型</h3>
<p>尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型：</p>
<pre><code class="language-typescript">let myAdd = function(x: number, y: number): number { 
  return x + y
}

let myAdd: (baseValue: number, increment: number) =&gt; number = 
function(x, y) {
  return x + y
}
</code></pre>
<p>这叫做“按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。</p>
<h3><a id="%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E5%92%8C%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可选参数和默认参数</h3>
<p>TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 <code>null</code> 或 <code>undefined</code> 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p>
<pre><code class="language-typescript">function buildName(firstName: string, lastName: string) {
    return firstName + ' ' + lastName;
}

let result1 = buildName('Bob')                  // Error, 参数过少
let result2 = buildName('Bob', 'Adams', 'Sr.');  // Error, 参数过多
let result3 = buildName('Bob', 'Adams');         // OK
</code></pre>
<p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 <code>undefined</code>。 在TypeScript 里我们可以在参数名旁使用 <code>?</code> 实现可选参数的功能。 比如，我们想让 <code>lastName</code> 是可选的：</p>
<pre><code class="language-typescript">function buildName(firstName: string, lastName?: string): string {
  if (lastName)
    return firstName + ' ' + lastName
  else
    return firstName
}

let result1 = buildName('Bob');  // 现在正常了
let result2 = buildName('Bob', 'Adams', 'Sr.')  // Error, 参数过多
let result3 = buildName('Bob', 'Adams')  // OK
</code></pre>
<p>可选参数必须跟在必须参数后面。 如果上例我们想让 <code>firstName</code> 是可选的，那么就必须调整它们的位置，把 <code>firstName</code> 放在后面。</p>
<p>在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 <code>undefined</code> 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把<code>lastName</code> 的默认值设置为 <code>&quot;Smith&quot;</code>。</p>
<pre><code class="language-typescript">function buildName(firstName: string, lastName = 'Smith'): string {
  return firstName + ' ' + lastName
}

let result1 = buildName('Bob')                  // 返回 &quot;Bob Smith&quot;
let result2 = buildName('Bob', undefined)     // 正常, 同样 &quot;Bob Smith&quot;
let result3 = buildName('Bob', 'Adams', 'Sr.')  // 错误, 参数过多
let result4 = buildName('Bob', 'Adams')        // OK
</code></pre>
<p>与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 <code>undefined</code> 值来获得默认值。 例如，我们重写最后一个例子，让 <code>firstName</code> 是带默认值的参数：</p>
<pre><code class="language-typescript">function buildName(firstName = 'Will', lastName: string): string {
  return firstName + ' ' + lastName
}

let result1 = buildName('Bob')                  // Error, 参数过少
let result2 = buildName('Bob', 'Adams', &quot;Sr.&quot;)  // Error, 参数过多
let result3 = buildName('Bob', 'Adams')         // OK， 返回 &quot;Bob Adams&quot;
let result4 = buildName(undefined, 'Adams')     // OK，  返回 &quot;Will Adams&quot;
</code></pre>
<h3><a id="%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>剩余参数</h3>
<p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 <code>arguments</code> 来访问所有传入的参数。</p>
<p>在 TypeScript 里，你可以把所有参数收集到一个变量里：</p>
<pre><code class="language-typescript">function buildName(firstName: string, ...restOfName: string[]): string {
  return firstName + ' ' + restOfName.join(' ')
}

let employeeName = buildName('Joseph', 'Samuel', 'Lucas', 'MacKinzie')
</code></pre>
<p>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ <code>...</code>）后面给定的名字，你可以在函数体内使用这个数组。</p>
<p>这个省略号也会在带有剩余参数的函数类型定义上使用到：</p>
<pre><code class="language-typescript">function buildName(firstName: string, ...restOfName: string[]): string {
  return firstName + ' ' + restOfName.join(' ')
}

let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName
</code></pre>
<h3><a id="this" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>this</h3>
<p>学习如何在 JavaScript 里正确使用 <code>this</code> 就好比一场成年礼。由于 TypeScript 是 JavaScript 的超集，TypeScript 程序员也需要弄清 <code>this</code> 工作机制并且当有 bug 的时候能够找出错误所在。 幸运的是，TypeScript 能通知你错误地使用了 <code>this</code> 的地方。 如果你想了解 JavaScript 里的 this是如何工作的，那么首先阅读 Yehuda Katz 写的 <a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">Understanding JavaScript Function Invocation and &quot;this&quot;</a>。 Yehuda 的文章详细的阐述了 <code>this</code> 的内部工作原理，因此我们这里只做简单介绍。</p>
<h4><a id="this%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>this 和箭头函数</h4>
<p>JavaScript里，<code>this</code> 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。</p>
<p>下面看一个例子：</p>
<pre><code class="language-typescript">let deck = {
  suits: ['hearts', 'spades', 'clubs', 'diamonds'],
  cards: Array(52),
  createCardPicker: function() {
    return function() {
      let pickedCard = Math.floor(Math.random() * 52)
      let pickedSuit = Math.floor(pickedCard / 13)

      return {suit: this.suits[pickedSuit], card: pickedCard % 13}
    }
  }
}

let cardPicker = deck.createCardPicker()
let pickedCard = cardPicker()

console.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)
</code></pre>
<p>可以看到 <code>createCardPicker</code> 是个函数，并且它又返回了一个函数。如果我们尝试运行这个程序，会发现它并没有输出而是报错了。 因为 <code>createCardPicker</code> 返回的函数里的 <code>this</code> 被设置成了 <code>global</code> 而不是 <code>deck</code> 对象。 因为我们只是独立的调用了 <code>cardPicker()</code>。 顶级的非方法式调用会将 <code>this</code> 视为 <code>global</code>。</p>
<p>为了解决这个问题，我们可以在函数被返回时就绑好正确的<code>this</code>。 这样的话，无论之后怎么使用它，都会引用绑定的<code>deck</code> 对象。 我们需要改变函数表达式来使用 ECMAScript 6 箭头语法。 箭头函数能保存函数创建时的 <code>this</code> 值，而不是调用时的值：</p>
<pre><code class="language-typescript">let deck = {
  suits: ['hearts', 'spades', 'clubs', 'diamonds'],
  cards: Array(52),
  createCardPicker: function() {
    // 注意：这里使用箭头函数
    return () =&gt; {
      let pickedCard = Math.floor(Math.random() * 52)
      let pickedSuit = Math.floor(pickedCard / 13)

      return {suit: this.suits[pickedSuit], card: pickedCard % 13}
    }
  }
}

let cardPicker = deck.createCardPicker()
let pickedCard = cardPicker()

console.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)
</code></pre>
<h4><a id="this%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>this 参数</h4>
<p>在上述的例子中 <code>this.suits[pickedSuit]</code> 的类型为 <code>any</code>，这是因为 <code>this</code> 来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 <code>this</code> 参数。 <code>this</code> 参数是个假的参数，它出现在参数列表的最前面：</p>
<pre><code class="language-typescript">function f(this: void) {
  // 确保“this”在此独立函数中不可用
}
</code></pre>
<p>让我们往例子里添加一些接口，<code>Card</code> 和 <code>Deck</code>，让类型重用能够变得清晰简单些：</p>
<pre><code class="language-typescript">interface Card {
  suit: string
  card: number
}

interface Deck {
  suits: string[]
  cards: number[]

  createCardPicker (this: Deck): () =&gt; Card
}

let deck: Deck = {
  suits: ['hearts', 'spades', 'clubs', 'diamonds'],
  cards: Array(52),
  // NOTE: 函数现在显式指定其被调用方必须是 deck 类型
  createCardPicker: function (this: Deck) {
    return () =&gt; {
      let pickedCard = Math.floor(Math.random() * 52)
      let pickedSuit = Math.floor(pickedCard / 13)

      return {suit: this.suits[pickedSuit], card: pickedCard % 13}
    }
  }
}

let cardPicker = deck.createCardPicker()
let pickedCard = cardPicker()

console.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)
</code></pre>
<p>现在 TypeScrip t知道 <code>createCardPicker</code> 期望在某个 <code>Deck</code> 对象上调用。也就是说 <code>this</code> 是 <code>Deck</code> 类型的，而非 <code>any</code>。</p>
<h4><a id="this%E5%8F%82%E6%95%B0%E5%9C%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E9%87%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>this 参数在回调函数里</h4>
<p>你可以也看到过在回调函数里的 <code>this</code> 报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用，<code>this</code> 将为 <code>undefined</code>。 稍做改动，你就可以通过 <code>this</code> 参数来避免错误。 首先，库函数的作者要指定 <code>this</code> 的类型：</p>
<pre><code class="language-typescript">interface UIElement {
  addClickListener(onclick: (this: void, e: Event) =&gt; void): void
}
</code></pre>
<p><code>this: void</code> 意味着 <code>addClickListener</code> 期望传入的 <code>onclick</code> 方法不需要 <code>this</code></p>
<pre><code class="language-typescript">interface UIElement {
  addClickListener (onclick: (this: void, e: Event) =&gt; void): void
}

class Handler {
  type: string

  onClickBad (this: Handler, e: Event) {
    this.type = e.type
  }
}

let h = new Handler()

let uiElement: UIElement = {
  addClickListener () {
  }
}

uiElement.addClickListener(h.onClickBad) // error!

</code></pre>
<p>指定了 <code>this</code> 类型后，你显式声明 <code>onClickBad</code> 必须在 <code>Handler</code> 的实例上调用。 然后 TypeScript 会检测到 <code>addClickListener</code> 要求函数带有 <code>this: void</code>。 改变 <code>this</code> 类型来修复这个错误：</p>
<pre><code class="language-typescript">class Handler {
  type: string;

  onClickBad (this: void, e: Event) {
    console.log('clicked!')
  }
}

let h = new Handler()

let uiElement: UIElement = {
  addClickListener () {
  }
}

uiElement.addClickListener(h.onClickBad)
</code></pre>
<p>因为 <code>onClickGood</code> 指定了 <code>this</code> 类型为 <code>void</code>，因此传递 <code>addClickListener</code> 是合法的。 当然了，这也意味着不能使用 <code>this.info</code>。 如果你两者都想要，你不得不使用箭头函数了：</p>
<pre><code class="language-typescript">class Handler {
  type: string
  onClickGood = (e: Event) =&gt; {
    this.type = e.type 
  }
}
</code></pre>
<p>这是可行的因为箭头函数不会捕获 <code>this</code>，所以你总是可以把它们传给期望 <code>this: void</code> 的函数。</p>
<h3><a id="%E9%87%8D%E8%BD%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重载</h3>
<p>JavaScript 本身是个动态语言。JavaScript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。</p>
<pre><code class="language-typescript">let suits = ['hearts', 'spades', 'clubs', 'diamonds']

function pickCard(x): any {
  if (Array.isArray(x)) {
    let pickedCard = Math.floor(Math.random() * x.length)
    return pickedCard
  } else if (typeof x === 'number') {
    let pickedSuit = Math.floor(x / 13)
    return { suit: suits[pickedSuit], card: x % 13 }
  }
}

let myDeck = [
  { suit: 'diamonds', card: 2 },
  { suit: 'spades', card: 10 },
  { suit: 'hearts', card: 4 }
]
let pickedCard1 = myDeck[pickCard(myDeck)];
console.log('card: ' + pickedCard1.card + ' of ' + pickedCard1.suit)

let pickedCard2 = pickCard(15)
console.log('card: ' + pickedCard2.card + ' of ' + pickedCard2.suit)
</code></pre>
<p><code>pickCard</code> 方法根据传入参数的不同会返回两种不同的类型。如果传入的是代表纸牌的对象数组，函数作用是从中抓一张牌。如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。</p>
<p>方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 <code>pickCard</code> 函数。</p>
<pre><code class="language-typescript">let suits = ['hearts', 'spades', 'clubs', 'diamonds']

function pickCard(x: {suit: string; card: number }[]): number
function pickCard(x: number): {suit: string; card: number }

function pickCard(x): any {
  if (Array.isArray(x)) {
    let pickedCard = Math.floor(Math.random() * x.length)
    return pickedCard
  } else if (typeof x === 'number') {
    let pickedSuit = Math.floor(x / 13)
    return { suit: suits[pickedSuit], card: x % 13 }
  }
}

let myDeck = [
  { suit: 'diamonds', card: 2 },
  { suit: 'spades', card: 10 },
  { suit: 'hearts', card: 4 }
]
let pickedCard1 = myDeck[pickCard(myDeck)];
console.log('card: ' + pickedCard1.card + ' of ' + pickedCard1.suit)

let pickedCard2 = pickCard(15)
console.log('card: ' + pickedCard2.card + ' of ' + pickedCard2.suit)
</code></pre>
<p>这样改变后，重载的 <code>pickCard</code> 函数在调用的时候会进行正确的类型检查。</p>
<p>为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p>
<p>注意，<code>function pickCard(x): any</code> 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字。 以其它参数调用 <code>pickCard</code> 会产生错误。</p>
<h2><a id="%E6%B3%9B%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>泛型</h2>
<p>软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>
<p>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>
<h3><a id="%E5%9F%BA%E7%A1%80%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础示例</h3>
<p>下面来创建第一个使用泛型的例子：<code>identity</code> 函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 <code>echo</code> 命令。</p>
<p>不用泛型的话，这个函数可能是下面这样：</p>
<pre><code class="language-typescript">function identity(arg: number): number {
  return arg
}
</code></pre>
<p>或者，我们使用 <code>any</code> 类型来定义函数：</p>
<pre><code class="language-typescript">function identity(arg: any): any {
  return arg
}
</code></pre>
<p>使用 <code>any</code> 类型会导致这个函数可以接收任何类型的 <code>arg</code> 参数，但是这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p>
<p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了<em>类型变量</em>，它是一种特殊的变量，只用于表示类型而不是值。</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
  return arg
}
</code></pre>
<p>我们给 <code>identity</code> 添加了类型变量 <code>T</code>。 <code>T</code> 帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了 <code>T</code> 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。</p>
<p>我们把这个版本的 <code>identity</code> 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 <code>any</code>，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p>
<p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p>
<pre><code class="language-typescript">let output = identity&lt;string&gt;('myString')
</code></pre>
<p>这里我们明确的指定了 <code>T</code> 是 <code>string</code> 类型，并做为一个参数传给函数，使用了 <code>&lt;&gt;</code> 括起来而不是 <code>()</code>。</p>
<p>第二种方法更普遍。利用了<em>类型推论</em> -- 即编译器会根据传入的参数自动地帮助我们确定 <code>T</code> 的类型：</p>
<pre><code class="language-typescript">let output = identity('myString')
</code></pre>
<p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看 <code>myString</code> 的值，然后把 <code>T</code> 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 <code>T</code> 的类型，在一些复杂的情况下，这是可能出现的。</p>
<h3><a id="%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用泛型变量</h3>
<p>使用泛型创建像 <code>identity</code> 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p>
<p>看下之前 <code>identity</code> 例子：</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
  return arg
}
</code></pre>
<p>如果我们想打印出 <code>arg</code> 的长度。 我们很可能会这样做：</p>
<pre><code class="language-typescript">function loggingIdentity&lt;T&gt;(arg: T): T {
  console.log(arg.length)
  return arg
}
</code></pre>
<p>如果这么做，编译器会报错说我们使用了 <code>arg</code> 的 <code>.length</code> 属性，但是没有地方指明 <code>arg</code> 具有这个属性。记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 <code>.length</code> 属性的。</p>
<p>现在假设我们想操作 <code>T</code> 类型的数组而不直接是 <code>T</code>。由于我们操作的是数组，所以 <code>.length</code> 属性是应该存在的。我们可以像创建其它数组一样创建这个数组：</p>
<pre><code class="language-typescript">function loggingIdentity&lt;T&gt;(arg: T[]): T[] {
  console.log(arg.length)
  return arg
}
</code></pre>
<p>你可以这样理解 <code>loggingIdentity</code> 的类型：泛型函数 <code>loggingIdentity</code>，接收类型参数 <code>T</code> 和参数 <code>arg</code>，它是个元素类型是 <code>T</code> 的数组，并返回元素类型是<code>T</code> 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 <code>T</code> 的的类型为 <code>number</code>。 这可以让我们把泛型变量 <code>T</code> 当做类型的一部分使用，而不是整个类型，增加了灵活性。</p>
<h3><a id="%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>泛型类型</h3>
<p>上一节，我们创建了 <code>identity</code> 通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p>
<p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
  return arg
}

let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity
</code></pre>
<p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
  return arg
}

let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity
</code></pre>
<p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
  return arg
}

let myIdentity: {&lt;T&gt;(arg: T): T} = identity
</code></pre>
<p>这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：</p>
<pre><code class="language-typescript">interface GenericIdentityFn {
  &lt;T&gt;(arg: T): T
}

function identity&lt;T&gt;(arg: T): T {
  return arg
}

let myIdentity: GenericIdentityFn = identity
</code></pre>
<p>我们甚至可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： <code>Dictionary&lt;string&gt;</code> 而不只是<code> Dictionary</code>）。这样接口里的其它成员也能知道这个参数的类型了。</p>
<pre><code class="language-typescript">interface GenericIdentityFn&lt;T&gt; {
  (arg: T): T
}

function identity&lt;T&gt;(arg: T): T {
  return arg
}

let myIdentity: GenericIdentityFn&lt;number&gt; = identity
</code></pre>
<p>注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 <code>GenericIdentityFn</code> 的时候，还得传入一个类型参数来指定泛型类型（这里是：<code>number</code>），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</p>
<p>除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。</p>
<h3><a id="%E6%B3%9B%E5%9E%8B%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>泛型类</h3>
<p>泛型类看上去与泛型接口差不多。 泛型类使用（ <code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p>
<pre><code class="language-typescript">class GenericNumber&lt;T&gt; {
  zeroValue: T
  add: (x: T, y: T) =&gt; T
}

let myGenericNumber = new GenericNumber&lt;number&gt;()
myGenericNumber.zeroValue = 0
myGenericNumber.add = function(x, y) {
  return x + y 
}
</code></pre>
<p><code>GenericNumber</code> 类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用 <code>number</code> 类型。 也可以使用字符串或其它更复杂的类型。</p>
<pre><code class="language-typescript">let stringNumeric = new GenericNumber&lt;string&gt;()
stringNumeric.zeroValue = ''
stringNumeric.add = function(x, y) { 
  return x + y
}

console.log(stringNumeric.add(stringNumeric.zeroValue, 'test'))
</code></pre>
<p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p>
<p>我们在<a href="/chapter2/class">类</a>那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p>
<h3><a id="%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>泛型约束</h3>
<p>我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。在 <code>loggingIdentity</code> 例子中，我们想访问 <code>arg</code> 的 <code>length</code> 属性，但是编译器并不能证明每种类型都有 <code>length</code> 属性，所以就报错了。</p>
<pre><code class="language-typescript">function loggingIdentity&lt;T&gt;(arg: T): T {
  console.log(arg.length)
  return arg
}
</code></pre>
<p>相比于操作 <code>any</code> 所有类型，我们想要限制函数去处理任意带有 <code>.length</code> 属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 <code>T</code> 的约束要求。</p>
<p>我们定义一个接口来描述约束条件，创建一个包含 <code>.length</code> 属性的接口，使用这个接口和 <code>extends</code> 关键字来实现约束：</p>
<pre><code class="language-typescript">interface Lengthwise {
  length: number
}

function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {
  console.log(arg.length) // OK
  return arg
}
</code></pre>
<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>
<pre><code class="language-typescript">loggingIdentity(3);  // Error
</code></pre>
<p>我们需要传入符合约束类型的值，必须包含必须的属性：</p>
<pre><code class="language-typescript">loggingIdentity({length: 10, value: 3}) // OK
</code></pre>
<h3><a id="%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在泛型约束中使用类型参数</h3>
<p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 <code>obj</code> 上，因此我们需要在这两个类型之间使用约束。</p>
<pre><code class="language-typescript">function getProperty&lt;T, K extends keyof T&gt; (obj: T, key: K ) {
  return obj[key]
}

let x = {a: 1, b: 2, c: 3, d: 4}

getProperty(x, 'a') // okay
getProperty(x, 'm') // error
</code></pre>
<h2><a id="%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型推断</h2>
<p>这节介绍 TypeScript 里的类型推断。即，类型是在哪里如何被推断的。</p>
<h3><a id="%E5%9F%BA%E7%A1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础</h3>
<p>TypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子：</p>
<pre><code class="language-typescript">let x = 3
</code></pre>
<p>变量 <code>x</code> 的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p>
<p>大多数情况下，类型推断是直截了当地。后面的小节，我们会浏览类型推断时的细微差别。</p>
<h3><a id="%E6%9C%80%E4%BD%B3%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最佳通用类型</h3>
<p>有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，</p>
<pre><code class="language-typescript">let x = [0, 1, null]
</code></pre>
<p>为了推断 <code>x</code> 的类型，我们必须考虑所有元素的类型。 这里有两种选择：<code>number</code> 和 <code>null</code>。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p>
<p>由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：</p>
<pre><code class="language-typescript">class Animal {
  numLegs: number
}

class Bee extends Animal {
}

class Lion extends Animal {
}

let zoo = [new Bee(), new Lion()]
</code></pre>
<p>这里，我们想让 <code>zoo</code> 被推断为 <code>Animal[]</code> 类型，但是这个数组里没有对象是 <code>Animal</code> 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型：</p>
<pre><code class="language-typescript">let zoo: Animal[] = [new Bee(), new Lion()]
</code></pre>
<p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Bee | Lion)[]</code></p>
<h3><a id="%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>上下文类型</h3>
<p>有些时候，TypeScript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如：</p>
<pre><code class="language-typescript">window.onmousedown = function(mouseEvent) {
  console.log(mouseEvent.clickTime)  // Error
}
</code></pre>
<p>这个例子会得到一个类型错误，TypeScript 类型检查器使用 <code>window.onmousedown</code> 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 <code>mouseEvent</code> 参数的类型了，所以 <code>mouseEvent</code> 访问了一个不存在的属性，就报错了。</p>
<p>如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子：</p>
<pre><code class="language-typescript">window.onmousedown = function(mouseEvent:any) {
  console.log(mouseEvent.clickTime)  // OK
}
</code></pre>
<p>这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。</p>
<p>上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如：</p>
<pre><code class="language-typescript">function createZoo(): Animal[] {
  return [new Bee(), new Lion()]
}

let zoo = createZoo()
</code></pre>
<p>这个例子里，最佳通用类型有 <code>3</code> 个候选者：<code>Animal</code>，<code>Bee</code> 和 <code>Lion</code>。 其中，<code>Animal</code> 会被做为最佳通用类型。</p>
<h2><a id="%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高级类型</h2>
<h3><a id="%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>交叉类型</h3>
<p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，<code>Person &amp; Loggable</code> 同时是 <code>Person</code> 和 <code>Loggable</code>。 就是说这个类型的对象同时拥有了这两种类型的成员。</p>
<p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：</p>
<pre><code class="language-typescript">function extend&lt;T, U&gt; (first: T, second: U): T &amp; U {
  let result = {} as T &amp; U
  for (let id in first) {
    result[id] = first[id] as any
  }
  for (let id in second) {
    if (!result.hasOwnProperty(id)) {
      result[id] = second[id] as any
    }
  }
  return result
}

class Person {
  constructor (public name: string) {
  }
}

interface Loggable {
  log (): void
}

class ConsoleLogger implements Loggable {
  log () {
    // ...
  }
}

var jim = extend(new Person('Jim'), new ConsoleLogger())
var n = jim.name
jim.log()
</code></pre>
<h3><a id="%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>联合类型</h3>
<p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code> 或 <code>string</code> 类型的参数。 例如下面的函数：</p>
<pre><code class="language-typescript">function padLeft(value: string, padding: any) {
  if (typeof padding === 'number') {
    return Array(padding + 1).join(' ') + value
  }
  if (typeof padding === 'string') {
    return padding + value
  }
  throw new Error(`Expected string or number, got '${padding}'.`)
}

padLeft('Hello world', 4) // returns &quot;    Hello world&quot;

</code></pre>
<p><code>padLeft</code> 存在一个问题，<code>padding</code> 参数的类型指定成了 <code>any</code>。 这就是说我们可以传入一个既不是 <code>number</code> 也不是 <code>string</code> 类型的参数，但是 TypeScript 却不报错。</p>
<pre><code class="language-typescript">let indentedString = padLeft('Hello world', true) // 编译阶段通过，运行时报错
</code></pre>
<p>为了解决这个问题，我们可以使用 联合类型做为 <code>padding</code> 的参数：</p>
<pre><code class="language-typescript">function padLeft(value: string, padding: string | number) {
  // ...
}

let indentedString = padLeft('Hello world', true) // 编译阶段报错
</code></pre>
<p>联合类型表示一个值可以是几种类型之一。我们用竖线（<code>|</code>）分隔每个类型，所以 <code>number | string</code> 表示一个值可以是 <code>number</code> 或 <code>string</code>。</p>
<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>
<pre><code class="language-typescript">interface Bird {
  fly()
  layEggs()
}

interface Fish {
  swim()
  layEggs()
}

function getSmallPet(): Fish | Bird {
  // ...
}

let pet = getSmallPet()
pet.layEggs() // okay
pet.swim()    // error
</code></pre>
<p>这里的联合类型可能有点复杂：如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，<code>Fish</code> 具有一个 <code>swim</code> 方法，我们不能确定一个 <code>Bird | Fish</code> 类型的变量是否有 <code>swim</code>方法。 如果变量在运行时是 <code>Bird</code> 类型，那么调用 <code>pet.swim()</code> 就出错了。</p>
<h3><a id="%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型保护</h3>
<p>联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 <code>Fish</code> 或者是 <code>Bird</code> 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。</p>
<pre><code class="language-typescript">let pet = getSmallPet()

// 每一个成员访问都会报错
if (pet.swim) {
  pet.swim()
} else if (pet.fly) {
  pet.fly()
}
</code></pre>
<p>为了让这段代码工作，我们要使用类型断言：</p>
<pre><code class="language-typescript">let pet = getSmallPet()

if ((pet as Fish).swim) {
  (pet as Fish).swim()
} else {
  (pet as Bird).fly()
}
</code></pre>
<h4><a id="%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用户自定义的类型保护</h4>
<p>这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code>pet</code> 的类型的话就好了。</p>
<p>TypeScript 里的<em>类型保护</em>机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个<em>类型谓词</em>：</p>
<pre><code class="language-typescript">function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined
}
</code></pre>
<p>在这个例子里，<code>pet is Fish</code> 就是类型谓词。谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</p>
<p>每当使用一些变量调用 <code>isFish</code> 时，<code>TypeScript</code> 会将变量缩减为那个具体的类型。</p>
<pre><code class="language-typescript">if (isFish(pet)) {
  pet.swim()
}
else {
  pet.fly()
}
</code></pre>
<p>注意 <code>TypeScript</code> 不仅知道在 <code>if</code> 分支里 <code>pet</code> 是 <code>Fish</code> 类型；它还清楚在 <code>else</code> 分支里，一定不是 Fish类型而是 <code>Bird</code> 类型。</p>
<h4><a id="typeof%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>typeof 类型保护</h4>
<p>现在我们回过头来看看怎么使用联合类型书写 <code>padLeft</code> 代码。我们可以像下面这样利用类型断言来写：</p>
<pre><code class="language-typescript">function isNumber (x: any):x is string {
  return typeof x === 'number'
}

function isString (x: any): x is string {
  return typeof x === 'string'
}

function padLeft (value: string, padding: string | number) {
  if (isNumber(padding)) {
    return Array(padding + 1).join(' ') + value
  }
  if (isString(padding)) {
    return padding + value
  }
  throw new Error(`Expected string or number, got '${padding}'.`)
}
</code></pre>
<p>然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 <code>typeof x === 'number' </code>抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。</p>
<pre><code class="language-typescript">function padLeft (value: string, padding: string | number) {
  if (typeof padding === 'number') {
    return Array(padding + 1).join(' ') + value
  }
  if (typeof padding === 'string') {
    return padding + value
  }
  throw new Error(`Expected string or number, got '${padding}'.`)
}
</code></pre>
<p>这些 <code>typeof</code> 类型保护只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code>必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>，<code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。</p>
<h4><a id="instanceof%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>instanceof 类型保护</h4>
<p>如果你已经阅读了 <code>typeof</code> 类型保护并且对 JavaScript 里的 <code>instanceof</code> 操作符熟悉的话，你可能已经猜到了这节要讲的内容。</p>
<p><code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：</p>
<pre><code class="language-typescript">class Bird {
  fly () {
    console.log('bird fly')
  }

  layEggs () {
    console.log('bird lay eggs')
  }
}

class Fish {
  swim () {
    console.log('fish swim')
  }

  layEggs () {
    console.log('fish lay eggs')
  }
}

function getRandomPet () {
  return Math.random() &gt; 0.5 ? new Bird() : new Fish()
}

let pet = getRandomPet()

if (pet instanceof Bird) {
  pet.fly()
}
if (pet instanceof Fish) {
  pet.swim()
}
</code></pre>
<h3><a id="%E5%8F%AF%E4%BB%A5%E4%B8%BAnull%E7%9A%84%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可以为 null 的类型</h3>
<p>TypeScript 具有两种特殊的类型，<code>null</code> 和 <code>undefined</code>，它们分别具有值 <code>null</code> 和 <code>undefined</code>。我们在<a href="/chapter2/type">基础类型</a>一节里已经做过简要说明。 默认情况下，类型检查器认为 <code>null</code> 与 <code>undefined</code> 可以赋值给任何类型。 <code>null</code> 与 <code>undefined</code> 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。<code>null</code>的发明者，Tony Hoare，称它为<a href="https://en.wikipedia.org/wiki/Null_pointer#History">价值亿万美金的错误</a>。</p>
<p><code>--strictNullChecks</code> 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 <code>null</code> 或 <code>undefined</code>。 你可以使用联合类型明确的包含它们：</p>
<pre><code class="language-typescript">let s = 'foo'
s = null // 错误, 'null'不能赋值给'string'
let sn: string | null = 'bar'
sn = null // 可以

sn = undefined // error, 'undefined'不能赋值给'string | null'
</code></pre>
<p>注意，按照 JavaScript 的语义，TypeScript 会把 <code>null</code> 和 <code>undefined</code> 区别对待。<code>string | null</code>，<code>string | undefined</code> 和 <code>string | undefined | null</code> 是不同的类型。</p>
<h3><a id="%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可选参数和可选属性</h3>
<p>使用了 <code>--strictNullChecks</code>，可选参数会被自动地加上 <code>| undefined</code>:</p>
<pre><code class="language-typescript">function f(x: number, y?: number) {
  return x + (y || 0)
}
f(1, 2)
f(1)
f(1, undefined)
f(1, null) // error, 'null' 不能赋值给 'number | undefined'
</code></pre>
<p>可选属性也会有同样的处理：</p>
<pre><code class="language-typescript">class C {
  a: number
  b?: number
}
let c = new C()
c.a = 12
c.a = undefined // error, 'undefined' 不能赋值给 'number'
c.b = 13
c.b = undefined // ok
c.b = null // error, 'null' 不能赋值给 'number | undefined'
</code></pre>
<h3><a id="%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型保护和类型断言</h3>
<p>由于可以为 <code>null</code> 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 <code>null</code>。幸运地是这与在 <code>JavaScript</code> 里写的代码一致：</p>
<pre><code class="language-typescript">function f(sn: string | null): string {
  if (sn === null) {
    return 'default'
  } else {
    return sn
  }
}
</code></pre>
<p>这里很明显地去除了 <code>null</code>，你也可以使用短路运算符：</p>
<pre><code class="language-typescript">function f(sn: string | null): string {
  return sn || 'default'
}
</code></pre>
<p>如果编译器不能够去除 <code>null</code> 或 <code>undefined</code>，你可以使用类型断言手动去除。语法是添加 <code>!</code> 后缀： <code>identifier!</code> 从 <code>identifier</code> 的类型里去除了 <code>null</code> 和 <code>undefined</code>：</p>
<pre><code class="language-typescript">function broken(name: string | null): string {
  function postfix(epithet: string) {
    return name.charAt(0) + '.  the ' + epithet // error, 'name' 可能为 null
  }
  name = name || 'Bob'
  return postfix('great')
}

function fixed(name: string | null): string {
  function postfix(epithet: string) {
    return name!.charAt(0) + '.  the ' + epithet // ok
  }
  name = name || 'Bob'
  return postfix('great')
}

broken(null)

</code></pre>
<p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的 <code>null</code>（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 <code>name</code> 的类型。</p>
<h3><a id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符串字面量类型</h3>
<p>字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p>
<pre><code class="language-typescript">type Easing = 'ease-in' | 'ease-out' | 'ease-in-out'

class UIElement {
  animate (dx: number, dy: number, easing: Easing) {
    if (easing === 'ease-in') {
      // ...
    } else if (easing === 'ease-out') {
    } else if (easing === 'ease-in-out') {
    } else {
      // error! 不能传入 null 或者 undefined.
    }
  }
}

let button = new UIElement()
button.animate(0, 0, 'ease-in')
button.animate(0, 0, 'uneasy') // error

</code></pre>
<p>你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。</p>
<pre><code class="language-plain_text">Argument of type '&quot;uneasy&quot;' is not assignable to parameter of type '&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;'
</code></pre>
<h3><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h3>
<p>那么到这里，我们的 TypeScript 常用语法学习就告一段落了，当然 TypeScript 还有其他的语法我们并没有讲，我们只是讲了 TypeScript 的一些常用语法，你们把这些知识学会已经足以开发一般的应用了。如果你在使用 TypeScript 开发项目中遇到了其他的 TypeScript 语法知识，你可以通过 TypeScript 的<a href="https://www.typescriptlang.org/docs/home.html">官网文档</a>学习。因为学基础最好的方法还是去阅读它的官网文档，敲上面的小例子。其实我们课程的基础知识结构也是大部分参考了官网文档，要记住学习一门技术的基础官网文档永远是最好的第一手资料。</p>
<p>但是 TypeScript 的学习不能仅仅靠看官网文档，你还需要动手实践，在实践中你才能真正掌握 TypeScript。相信很多同学学习到这里已经迫不及待想要大展身手了，那么下面我们就开始把理论转换为实践，一起来用 TypeScript 重构 axios 吧！</p>

]]></content>
  </entry>
  
</feed>

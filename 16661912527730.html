<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    基于Vue3最新标准，实现后台前端综合解决方案 - 
    
    </title>
    

    
    
    <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">Home</a>
                
                <a target="_self" class="navbar-item " href="archives.html">Archives</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            基于Vue3最新标准，实现后台前端综合解决方案   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2022/10/19</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='Vue.html'>Vue</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <h1><a id="01%E5%BC%80%E7%AF%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>01 开篇</h1>
<h2><a id="vue%E7%9A%84%E6%9C%80%E6%96%B0%E5%8F%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>vue 的最新变化</h2>
<p>自从 <code>vue</code> 在 <code>2020年09月18日</code> 发布了 <code>3.0</code> 的版本之后，很多开发者都开始尝试被大受推崇的 <code>Composition API</code> ，但是在经过了短期的追捧之后，大家却发现，在企业中 <code>Composition API</code> 却并没有被大范围的普及，很多的公司虽然升级到了 <code>vue 3</code> ，但却依然使用着 <code>options API</code> 语法。</p>
<p>追其根本，原因还是在 <code>Composition API</code> 所提供的 <code>setup 函数语法</code> 中，如果你使用 <code>setup 函数语法</code> ，那么你得到的代码可能是这样的：</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904095.png" alt="image-20210908103648564" /></p>
<p>此时我们想要在 <code>template</code> 中使用一个 <strong>响应式数据</strong>，不但要通过 <code>ref</code> 进行声明，还需要在 <code>setup</code> 函数中进行 <code>return</code> 操作。同样方法也是如此。</p>
<p>那么当我们的一个项目足够复杂时，这样的一种结构形式就会变得 <strong>非常的难看</strong> 并且 <strong>难以维护</strong></p>
<p>而这样的问题作为 <code>vue</code> 官方也是看到了的。</p>
<p>所以说在 <code>vue3</code> 仅仅发布了一个月之后，也就是在 <code>2020年10月28</code> ，<code>Vue</code> 就提出了一个 <code>RFC</code> ，尝试新的方式来废弃掉这种 <code>setup 函数式</code> 语法。</p>
<p>时隔一年，在 <code>2021年8月5日</code> ，伴随着 <code>vue 3.2</code> 的发布，<code>vue</code> 正式推出了全新的 <code>composition API</code> 语法标准 <code>script-setup</code></p>
<p><code>script-setup</code> 的推出，标记着 <code>setup 函数式语法</code> 正式称为过去式！</p>
<p>基于 <code>script-setup 语法标准</code> ，我们再去实现之前的业务，代码则变成了这样：</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904112.png" alt="image-20211014190033745" /></p>
<p>原本 25 行的代码量被压缩到了 14 行，并且大家可以发现，现在我们可以像 <strong>写普通的 <code>js</code> 一样去写 <code>vue</code> 了</strong></p>
<p>除此之外 <code>vue3.2</code> 版本还带来了很多其他的巨大改变，比如：</p>
<ol>
<li>耗时一年才发布的全新响应式优化</li>
<li>组件状态驱动的动态 <code>CSS</code> 值</li>
<li>...</li>
</ol>
<p>这些新的改变，我们在开篇这里就不再赘述了</p>
<h2><a id="%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B9%BF%E6%B3%9B%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>后台系统的广泛性</h2>
<p>而对于后台系统而言，相信只要是前端开发的工程师，那么就不陌生了。</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904125.png" alt="image-20211014192615333" /></p>
<p>如图所示，根据我们之前的多次数据统计分析，在 1-5 年经验的前端开发者中，后台管理系统的项目占比为 <code>59.62%</code> 。为前端开发中最为重要的工作方向。</p>
<h2><a id="%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目功能介绍</h2>
<p>而我们本次的课程则是专门针对于这种最为重要的工作方向，抽离出其中几十个经典业务模型，争取可以制作出覆盖大家大部分后台开发业务场景的综合性解决方案。</p>
<p>具体业务模型有：</p>
<ol>
<li>基于最新 <code>vue</code> 标准的：
<ol>
<li>script setup 语法标准</li>
<li>最新的响应式变更</li>
<li>组件状态驱动的动态 css</li>
<li>最新 <code>vue</code> 全家桶</li>
</ol>
</li>
<li>基于大厂编程规范的：
<ol>
<li>eslint</li>
<li>prettier</li>
<li>Commitizen</li>
<li>husky</li>
<li>commitlint</li>
<li>pre-commit</li>
<li>lint-staged</li>
</ol>
</li>
<li>以及：
<ol>
<li>Svg Sprite Icon</li>
<li>环境变量处理方案</li>
<li>接口模块封装方案</li>
<li>请求动作封装方案</li>
<li>token 处理方案</li>
<li>登录鉴权方案</li>
<li>主动登出方案</li>
<li>被动登出方案</li>
<li>动态路由表处理方案</li>
<li>动态菜单项处理方案</li>
<li>动态面包屑处理方案</li>
<li>联动处理</li>
<li>动画处理</li>
<li>国际化处理方案</li>
<li>动态主题处理方案</li>
<li>全屏处理方案</li>
<li>页面检索处理方案</li>
<li>TagsView 处理方案</li>
<li>功能引导处理方案</li>
<li>多组件</li>
<li>基于文件选择的 Excel 导入方案</li>
<li>基于文件拖拽的 Excel 导入方案</li>
<li>Excel 数据导出方案</li>
<li>RBAC 的权限分控体系</li>
<li>动态权限设定</li>
<li>页面权限处理方案</li>
<li>功能权限处理方案</li>
<li>动态表格处理方案</li>
<li>拖拽表格处理方案</li>
<li>辅助库选择标准</li>
<li>markdown 编辑器处理</li>
<li>富文本编辑器处理</li>
<li>打包优化处理方案</li>
<li>服务器、域名购买与备案标准</li>
<li>前端项目部署方案</li>
</ol>
</li>
</ol>
<p>等一揽子处理方案内容</p>
<h2><a id="%E8%AF%A6%E7%BB%86%E7%9A%84%E5%9B%BE%E6%96%87%E8%8A%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>详细的图文节</h2>
<p>每一小节的视频都会对应详细的图文节内容</p>
<h2><a id="%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目功能演示</h2>
<h2><a id="%E8%AF%BE%E7%A8%8B%E6%94%B6%E8%8E%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>课程收获</h2>
<p>那么到这里相信大家对本课程中的内容应该有了一个大致的了解。</p>
<p>总结一下，学习完本课程之后，大家可以获取到如下三点收获：</p>
<ol>
<li>大厂标准的编程规范</li>
<li>明星级项目的架构设计</li>
<li>数十个经典业务模型以及对应的解决方案</li>
</ol>
<p>足够帮助你在 面试 或者 晋升 中脱颖而出！</p>
<h2><a id="%E9%80%82%E5%BA%94%E4%BA%BA%E7%BE%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>适应人群</h2>
<p>因为本课程为通用的解决方案课程，所以无论是：</p>
<ol>
<li>在校学生</li>
<li>新入职场的开发者</li>
<li>有一定开发经验的开发者</li>
</ol>
<p>都可以学习本课程的内容并获取到足够的收获！</p>
<p>那么还在犹豫什么呢？快来一起学习吧！</p>
<h1><a id="02-eslint-git-hooks" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>02 ESLint + Git Hooks</h1>
<blockquote>
<p>标准化大厂编程规范解决方案之ESLint + Git Hooks</p>
</blockquote>
<h2><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么需要编程规范？</h2>
<p><strong>工欲善其事，必先利其器</strong></p>
<p>对于一些大型的企业级项目而言，通常情况下我们都是需要一个团队来进行开发的。而又因为团队人员对技术理解上的参差不齐，所以就会导致出现一种情况，那就是《<strong>一个项目无法具备统一的编程规范，导致项目的代码像多个不同材质的补丁拼接起来一样</strong>》</p>
<p>设想一下，下面的这段代码有一个团队进行开发，因为没有具备统一的代码标准，所以生成了下面的代码：</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904137.png" alt="image-20210903190021029" /></p>
<p>这段代码可以正常运行没有问题，但是整体的代码结构却非常的难看。</p>
<blockquote>
<p>有的地方有空格进行分割，有的地方却没有</p>
<p>有的地方是单引号，有的地方却是双引号</p>
<p>有的地方有分号，有的地方没有分号</p>
<p>....</p>
</blockquote>
<p>这样的项目虽然可以正常运行，但是如果把它放到大厂的项目中，确实 <strong>不及格</strong> 的，它会被认为是 <strong>不可维护、不可扩展的代码内容</strong></p>
<p>那么所谓的大厂标准的代码结构应该是什么样子的呢？</p>
<p>我们把上面的代码进行一下修正，做一个对比：</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904148.png" alt="image-20210903193913261" /></p>
<p>修改之后的代码具备了统一的规范之后，是不是看起来就舒服多了！</p>
<p>并且以上所列举出来的只是《编程规范》中的一小部分内容！</p>
<p>那么有些同学可能就会说了，你列举出来这些编程规范有什么用啊！</p>
<p>哪怕你写上一部书，我们一个团队这么多人，总不能指望所有人都看一遍，并且严格的遵守你所说的规范吧！</p>
<p>说的没错！指望人主动的遵守这些规范不太现实</p>
<p>那怎么办呢？</p>
<p>那么我们可不可以另辟蹊径，让程序自动处理规范化的内容呢？</p>
<p>答案是：可以的！</p>
<p>这些也是我们本章节所需要讲解的重点内容！</p>
<p>本章节中我们会为大家讲解，如何自动化的对代码进行规范，其中主要包括：</p>
<ol>
<li>编码规范</li>
<li>git 规范</li>
</ol>
<p>两大类</p>
<p>那么明确好了我们的范围之后，接下来就让我们创建一个项目，开始我们的代码规范之旅吧！</p>
<h2><a id="%E4%BD%BF%E7%94%A8vue-cli%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 vue-cli 创建项目</h2>
<p>这一小节我们需要创建一个 <code>vue3</code> 的项目，而创建项目的方式依然是通过 <code>vue-cli</code> 进行创建。</p>
<p>不过这里有一点大家需要注意，因为我们需要使用最新的模板，所以请保证你的 <code>vue-cli</code> 的版本在 <code>4.5.13</code> 以上，你可以通过以下的方式来查看你的 <code>vue-cli</code> 版本：</p>
<pre><code class="language-plain_text">vue -V
------
@vue/cli 4.5.13 // 输出版本号
</code></pre>
<p>如果你需要升级版本，那么可以通过以下指令进行升级：</p>
<pre><code class="language-plain_text">npm update -g @vue/cli
</code></pre>
<p>具体的方式也可以点击 <a href="https://cli.vuejs.org/zh/guide/installation.html">这里</a> 进行参考。</p>
<p>升级之后，即可通过以下方式创建最新的 <code>vue3</code> 项目，终端输入 <code>vue create 项目名称</code> ，即可进入 <strong>模板选择</strong></p>
<pre><code class="language-js">// 利用 vue-cli 创建项目
vue create imooc-admin
// 进入模板选择
Vue CLI v4.5.13
? Please pick a preset:
  Default ([Vue 2] babel, eslint)
  Default (Vue 3) ([Vue 3] babel, eslint) 
&gt; Manually select features  // 选择手动配置
// ----------------------------------------------------------
? Check the features needed for your project: 
 (*) Choose Vue version // 选择 vue 版本
 (*) Babel // 使用 babel
 ( ) TypeScript // 不使用 ts
 ( ) Progressive Web App (PWA) Support // 不使用 PWA
 (*) Router // 添加 vue-router
 (*) Vuex // 添加 vuex
&gt;(*) CSS Pre-processors // 使用 css 预处理器
 (*) Linter / Formatter // 代码格式化
 ( ) Unit Testing // 不配置测试
 ( ) E2E Testing  // // 不配置测试
// ----------------------------------------------------------
 Choose a version of Vue.js that you want to start the project with 
  2.x
&gt; 3.x // 选择 vue 3.0 版本
// ----------------------------------------------------------
 Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) n // 不使用 history模式 的路由
// ----------------------------------------------------------
 ? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): 
&gt; Sass/SCSS (with dart-sass) // 使用基于 dart-sass 的 scss 预处理器
  Sass/SCSS (with node-sass) 
  Less
  Stylus
// ----------------------------------------------------------
? Pick a linter / formatter config: 
  ESLint with error prevention only 
  ESLint + Airbnb config
&gt; ESLint + Standard config // 使用 ESLint 标准代码格式化方案
  ESLint + Prettier 
// ----------------------------------------------------------
? Pick additional lint features: 
 (*) Lint on save //  
&gt;(*) Lint and fix on commit  // 保存时 &amp;&amp; 提交时，都进行 lint
// ----------------------------------------------------------
? Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys)
&gt; In dedicated config files // 单独的配置文件
  In package.json
// ----------------------------------------------------------
 Save this as a preset for future projects? (y/N) n // 不存储预设
</code></pre>
<p>等待片刻之后，你的项目就会生成成功。</p>
<p>生成之后，可以通过以下两个指令来运行你的项目：</p>
<pre><code class="language-plain_text">cd 项目目录
npm run serve
</code></pre>
<p>执行成功之后，项目即可运行！</p>
<h2><a id="%E5%8D%87%E7%BA%A7vue%E6%94%AF%E6%8C%81-script-setup%E8%AF%AD%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>升级 vue 支持 script setup 语法</h2>
<p>因为使用 <code>@vue/cli-v4.5.13</code> 版本创建的项目中，<code>vue</code> 的版本为 <code>v 3.0.0</code> 。</p>
<p>但是我们的项目需要使用最新的 <code>script setup 语法</code>，该语法在 <code>v 3.0.0</code> 版本中是不支持的，所以我们需要升级 <code>vue</code> 版本。</p>
<p>大家可以通过以下指令进行升级：</p>
<p>执行：</p>
<pre><code class="language-js">npm i vue@3.2.8 vue-router@4.0.11 vuex@4.0.2
</code></pre>
<p>升级之后，查看 <code>package.json</code> 得到的版本应为：</p>
<pre><code class="language-json">&quot;vue&quot;: &quot;^3.2.8&quot;,
&quot;vue-router&quot;: &quot;^4.0.11&quot;,
&quot;vuex&quot;: &quot;^4.0.2&quot;
</code></pre>
<h2><a id="%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7eslint" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码检测工具 ESLint</h2>
<blockquote>
<p>大厂编程规范一：代码检测工具 ESLint 你了解多少？</p>
</blockquote>
<p>在我们去创建项目的时候，脚手架工具已经帮助我们安装了 <code>ESLint</code> 代码检测工具。</p>
<p>对于 <code>ESLint</code> 的大名，同学们或多或少的应该都听说过，只不过有些同学可能了解的多一些，有些同学了解的少一些。</p>
<p>那么本小节我们就先来聊一下，这个赫赫有名的代码检测工具 <code>ESLint</code></p>
<p>首先 <code>ESLint</code> 是 <code>2013年6月</code> 创建的一个开源项目，它的目标非常简单，只有一个，那就是 <strong>提供一个插件化的 <code>javascript</code> 代码检测工具</strong> ，说白了就是做 <strong>代码格式检测使用的</strong></p>
<p>在咱们当前的项目中，包含一个 <code>.eslintrc.js</code> 文件，这个文件就是 <code>eslint</code> 的配置文件。</p>
<p>随着大家对代码格式的规范性越来越重视，<code>eslint</code> 也逐渐被更多的人所接收，同时也有很多大厂在原有的 <code>eslint</code> 规则基础之上进行了一些延伸。</p>
<p>我们在创建项目时，就进行过这样的选择：</p>
<pre><code class="language-js">? Pick a linter / formatter config: 
  ESLint with error prevention only // 仅包含错误的 ESLint
  ESLint + Airbnb config // Airbnb 的 ESLint 延伸规则
  ESLint + Standard config // 标准的 ESLint 规则
</code></pre>
<p>我们当前选择了 <strong>标准的 ESLint 规则</strong> ，那么接下来我们就在该规则之下，看一看 <code>ESLint</code> 它的一些配置都有什么？</p>
<p>打开项目中的 <code>.eslintrc.js</code> 文件</p>
<pre><code class="language-js">// ESLint 配置文件遵循 commonJS 的导出规则，所导出的对象就是 ESLint 的配置对象
// 文档：https://eslint.bootcss.com/docs/user-guide/configuring
module.exports = {
  // 表示当前目录即为根目录，ESLint 规则将被限制到该目录下
  root: true,
  // env 表示启用 ESLint 检测的环境
  env: {
    // 在 node 环境下启动 ESLint 检测
    node: true
  },
  // ESLint 中基础配置需要继承的配置
  extends: [&quot;plugin:vue/vue3-essential&quot;, &quot;@vue/standard&quot;],
  // 解析器
  parserOptions: {
    parser: &quot;babel-eslint&quot;
  },
  // 需要修改的启用规则及其各自的错误级别
  /**
   * 错误级别分为三种：
   * &quot;off&quot; 或 0 - 关闭规则
   * &quot;warn&quot; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)
   * &quot;error&quot; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)
   */
  rules: {
    &quot;no-console&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,
    &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;
  }
};

</code></pre>
<p>那么到这里咱们已经大致的了解了<code>.eslintrc.js</code> 文件，基于 <code>ESLint</code> 如果我们出现不符合规范的代码格式时，那么就会得到一个对应的错误。</p>
<p>比如：</p>
<blockquote>
<p>我们可以把 <code>Home.vue</code> 中的 <code>name</code> 属性值，由单引号改为双引号</p>
</blockquote>
<p>此时，只要我们一保存代码，那么就会得到一个对应的错误</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904158.png" alt="image-20210904185336318" /></p>
<p>这个错误表示：</p>
<ol>
<li>此时我们触发了一个 《错误级别的错误》</li>
<li>触发该错误的位置是 在 <code>Home.vue</code> 的第 13 行 第九列 中</li>
<li>错误描述为：字符串必须使用单引号</li>
<li>错误规则为：<code>quotes</code></li>
</ol>
<p>那么想要解决这个错误，通常情况下我们有两种方式：</p>
<ol>
<li>按照 <code>ESLint</code> 的要求修改代码</li>
<li>修改 <code>ESLint</code> 的验证规则</li>
</ol>
<p><strong>按照 <code>ESLint</code> 的要求修改代码：</strong></p>
<blockquote>
<p>在 <code>Home.vue</code> 的第 13 行中把双引号改为单引号</p>
</blockquote>
<p><strong>修改 <code>ESLint</code> 的验证规则：</strong></p>
<ol>
<li>
<p>在 <code>.eslintrc.js</code> 文件中，新增一条验证规则</p>
<pre><code class="language-json">&quot;quotes&quot;: &quot;error&quot; // 默认
&quot;quotes&quot;: &quot;warn&quot; // 修改为警告
&quot;quotes&quot;: &quot;off&quot; // 修改不校验
</code></pre>
</li>
</ol>
<p>那么这一小节，我们了解了 <code>vue-cli</code> 创建 <code>vue3</code> 项目时，<code>Standard config</code> 的 <code>ESLint</code> 配置，并且知道了如何解决 <code>ESLint</code> 报错的问题。</p>
<p>但是一个团队中，人员的水平高低不齐，大量的 <code>ESLint</code> 规则校验，会让很多的开发者头疼不已，从而大大影响了项目的开发进度。</p>
<p>试想一下，在你去完成项目代码的同时，还需要时时刻刻注意代码的格式问题，这将是一件多么痛苦的事情！</p>
<p>那么有没有什么办法，既可以保证 <code>ESLint</code> 规则校验，又可以解决严苛的格式规则导致的影响项目进度的问题呢？</p>
<h2><a id="%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96prettier" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码格式化 Prettier</h2>
<blockquote>
<p>大厂编程规范二：你知道代码格式化 Prettier 吗？</p>
</blockquote>
<p>在上一小节中，我们知道了 <code>ESLint</code> 可以让我们的代码格式变得更加规范，但是同样的它也会带来开发时编码复杂度上升的问题。</p>
<p>那么有没有办法既可以保证 <code>ESLint</code> 规则校验，又可以让开发者无需关注格式问题来进行顺畅的开发呢？</p>
<p>答案是：有的！</p>
<p>而解决这个问题的关键就是 <code>prettier</code>！（点击 <a href="https://www.prettier.cn/">这里</a> 进入 <code>prettier</code> 中文官网！）</p>
<p><strong><code>prettier</code> 是什么？</strong></p>
<ol>
<li>一个代码格式化工具</li>
<li>开箱即用</li>
<li>可以直接集成到 <code>VSCode</code> 之中</li>
<li>在保存时，让代码直接符合 <code>ESLint</code> 标准（需要通过一些简单配置）</li>
</ol>
<p>那么这些简单配置具体指的是什么呢？</p>
<p>请看下一小节《ESLint 与 Prettier 配合解决代码格式问题》</p>
<h2><a id="eslint%E4%B8%8E-prettier%E9%85%8D%E5%90%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ESLint 与 Prettier 配合</h2>
<blockquote>
<p>ESLint 与 Prettier 配合解决代码格式问题</p>
</blockquote>
<p>在上一小节中，我们提到《<code>prettier</code> 可以在保存代码时，让我们的代码直接符合 <code>ESLint</code> 标准》但是想要实现这样的功能需要进行一些配置。</p>
<p>那么这一小节，我们就来去完成这个功能：</p>
<ol>
<li>
<p>在 <code>VSCode</code> 中安装 <code>prettier</code> 插件（搜索 <code>prettier</code>），这个插件可以帮助我们在配置 <code>prettier</code> 的时候获得提示</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904168.png" alt="image-20210904195026475" /></p>
<p>如果使用的是Webstorm，同样在插件市场中找到 Prettier插件：<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904182.jpg" alt="" /></p>
<p>启用Prettier后Webstorm这里会出现Prettier配置项，如下所示勾选即可：<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904203.jpg" alt="" /></p>
</li>
<li>
<p>在项目中新建 <code>.prettierrc</code> 文件，该文件为 <code>perttier</code> 默认配置文件</p>
</li>
<li>
<p>在该文件中写入如下配置：</p>
<pre><code class="language-json">{
  // 不尾随分号
  &quot;semi&quot;: false,
  // 使用单引号
  &quot;singleQuote&quot;: true,
  // 多行逗号分割的语法中，最后一行不加逗号
  &quot;trailingComma&quot;: &quot;none&quot;
}
</code></pre>
</li>
<li>
<p>打开 <code>VSCode</code> 《设置面板》</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904218.png" alt="image-20210904200638072" /></p>
</li>
<li>
<p>在设置中，搜索 <code>save</code> ，勾选 <code>Format On Save</code></p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904228.png" alt="image-20210904200738067" /></p>
</li>
</ol>
<p>至此，你即可在 <strong><code>VSCode</code> 保存时，自动格式化代码！</strong></p>
<p>如果使用的是Webstorm则在 .prettierrc 文件中编写相关配置：</p>
<pre><code class="language-javascript">{
  &quot;singleQuote&quot;: true,
  &quot;semi&quot;: false,
  &quot;trailingComma&quot;: &quot;none&quot;  ,
  &quot;printWidth&quot;: 120,
  &quot;tabWidth&quot;: 4,
  &quot;endOfLine&quot;: &quot;auto&quot;,
  &quot;editor.formatOnSave&quot;: false,
  &quot;[javascript]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,
    &quot;editor.formatOnSave&quot;: true
  },
  &quot;[typescript]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;, 
    &quot;editor.formatOnSave&quot;: true
  }
}
</code></pre>
<p><strong>但是！</strong> 你只做到这样还不够！</p>
<blockquote>
<ol>
<li>
<p>VSCode 而言，默认一个 tab 等于 4 个空格，而 ESLint 希望一个 tab 为两个空格</p>
</li>
<li>
<p>如果大家的 VSCode 安装了多个代码格式化工具的化</p>
</li>
<li>
<p>ESLint 和 prettier 之间的冲突问题</p>
</li>
</ol>
</blockquote>
<p>我们尝试在 <code>Home.vue</code> 中写入一个 <code>created</code> 方法，写入完成之后，打开我们的控制台我们会发现，此时代码抛出了一个 <code>ESLint</code> 的错误</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904238.png" alt="image-20210904201057594" /></p>
<p>这个错误的意思是说：<strong><code>created</code> 这个方法名和后面的小括号之间，应该有一个空格！</strong></p>
<p>但是当我们加入了这个空格之后，只要一保存代码，就会发现 <code>prettier</code> 会自动帮助我们去除掉这个空格。</p>
<p>那么此时的这个问题就是 <code>prettier</code> 和 <code>ESLint</code> 的冲突问题。</p>
<p>针对于这个问题我们想要解决也非常简单：</p>
<ol>
<li>
<p>打开 <code>.eslintrc.js</code> 配置文件</p>
</li>
<li>
<p>在 <code>rules</code> 规则下，新增一条规则</p>
<pre><code class="language-json">'space-before-function-paren': 'off'
</code></pre>
</li>
<li>
<p>该规则表示关闭《方法名后增加空格》的规则</p>
</li>
<li>
<p>重启项目</p>
</li>
</ol>
<p>至此我们整个的 <code>perttier</code> 和 <code>ESLint</code> 的配合使用就算是全部完成了。</p>
<p>在之后我们写代码的过程中，只需要保存代码，那么 <code>perttier</code> 就会帮助我们自动格式化代码，使其符合 <code>ESLint</code> 的校验规则。而无需我们手动进行更改了。</p>
<h2><a id="git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Git提交规范</h2>
<p>在前面我们通过 <code>prettier + ESLint</code> 解决了代码格式的问题，但是我们之前也说过 <strong>编程规范</strong> 指的可不仅仅只是 <strong>代码格式规范</strong> 。</p>
<p>除了 <strong>代码格式规范</strong> 之外，还有另外一个很重要的规范就是 <strong><code>git</code> 提交规范！</strong></p>
<p>在现在的项目开发中，通常情况下，我们都会通过 <code>git</code> 来管理项目。只要通过 <code>git</code> 来管理项目，那么就必然会遇到使用 <code>git</code> 提交代码的场景</p>
<p>当我们执行 <code>git commit -m &quot;描述信息&quot;</code> 的时候，我们知道此时必须添加一个描述信息。但是中华文化博大精深，不同的人去填写描述信息的时候，都会根据自己的理解来进行描述。</p>
<p>而很多人的描述 “天马行空” ，这样就会导致别人在看你的提交记录时，看不懂你说的什么意思？不知道你当前的这次提交到底做了什么事情？会不会存在潜在的风险？</p>
<p>比如说，我们来看这几条提交记录：</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904248.png" alt="image-20210904203051754" /></p>
<p>你能够想象得到它们经历了什么吗？</p>
<p>所以 <strong><code>git</code> 提交规范</strong> 势在必行。</p>
<p>对于 <strong><code>git</code> 提交规范</strong> 来说，不同的团队可能会有不同的标准，那么咱们今天就以目前使用较多的 <a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines">Angular团队规范</a> 延伸出的 <a href="https://www.conventionalcommits.org/zh-hans/v1.0.0/">Conventional Commits specification（约定式提交）</a> 为例，来为大家详解  <strong><code>git</code> 提交规范</strong></p>
<p>约定式提交规范要求如下：</p>
<pre><code class="language-js">&lt;type&gt;[optional scope]: &lt;description&gt;

[optional body]

[optional footer(s)]

--------  翻译 -------------
    
&lt;类型&gt;[可选 范围]: &lt;描述&gt;

[可选 正文]

[可选 脚注]
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 类型，必须是一个可选的值，比如：</p>
<ol>
<li>新功能：<code>feat</code></li>
<li>修复：<code>fix</code></li>
<li>文档变更：<code>docs</code></li>
<li>....</li>
</ol>
<p>也就是说，如果要按照 <strong>约定式提交规范</strong> 来去做的化，那么你的一次提交描述应该式这个样子的：</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904256.png" alt="image-20210904205519762" /></p>
<p>我想大家看到这样的一个提交描述之后，心里的感觉应该和我一样是崩溃的！要是每次都这么写，写到猴年马月了！</p>
<p>如果你有这样的困惑，那么 ”恭喜你“ ，接下来我们将一起解决这个问题！</p>
<p>欲知后事如何，请看下一节《Commitizen助你规范化提交代码》</p>
<h2><a id="commitizen%E8%A7%84%E8%8C%83%E5%8C%96%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Commitizen规范化提交代码</h2>
<blockquote>
<p>更多详细配置参考笔记：<a href="https://note.youdao.com/s/VBn9zlM6">https://note.youdao.com/s/VBn9zlM6</a></p>
</blockquote>
<p>在上一小节我们讲述了 <a href="https://www.conventionalcommits.org/zh-hans/v1.0.0/">约定式提交规范</a> ，我们知道如果严格安装 <strong>约定式提交规范</strong>， 来手动进行代码提交的话，那么是一件非常痛苦的事情，但是 <strong>git 提交规范的处理</strong> 又势在必行，那么怎么办呢？</p>
<p>你遇到的问题，也是其他人所遇到的！</p>
<p>经过了很多人的冥思苦想，就出现了一种叫做 <strong>git 提交规范化工具</strong> 的东西，而我们要学习的 <code>commitizen</code> 就是其中的佼佼者！</p>
<p><code>commitizen</code> 仓库名为 <a href="https://github.com/commitizen/cz-cli">cz-cli</a> ，它提供了一个 <code>git cz</code> 的指令用于代替 <code>git commit</code>，简单一句话介绍它：</p>
<blockquote>
<p>当你使用 <code>commitizen</code> 进行代码提交（git commit）时，<code>commitizen</code> 会提交你在提交时填写所有必需的提交字段！</p>
</blockquote>
<p>这句话怎么解释呢？不用着急，下面我们就来安装并且使用一下 <code>commitizen</code> ，使用完成之后你自然就明白了这句话的意思！</p>
<ol>
<li>
<p>全局安装<code>Commitizen</code></p>
<pre><code class="language-js">npm install -g commitizen@4.2.4
</code></pre>
</li>
<li>
<p>安装并配置 <code>cz-customizable</code> 插件</p>
<ol>
<li>
<p>使用 <code>npm</code> 下载 <code>cz-customizable</code></p>
<pre><code class="language-node">npm i cz-customizable@6.3.0 --save-dev
</code></pre>
</li>
<li>
<p>添加以下配置到 <code>package.json </code> 中</p>
<pre><code class="language-json">...
  &quot;config&quot;: {
    &quot;commitizen&quot;: {
      &quot;path&quot;: &quot;node_modules/cz-customizable&quot;
    }
  }
</code></pre>
</li>
</ol>
</li>
<li>
<p>项目根目录下创建 <code>.cz-config.js</code> 自定义提示文件</p>
<pre><code class="language-js">module.exports = {
  // 可选类型
  types: [
    { value: 'feat', name: 'feat:     新功能' },
    { value: 'fix', name: 'fix:      修复' },
    { value: 'docs', name: 'docs:     文档变更' },
    { value: 'style', name: 'style:    代码格式(不影响代码运行的变动)' },
    {
      value: 'refactor',
      name: 'refactor: 重构(既不是增加feature，也不是修复bug)'
    },
    { value: 'perf', name: 'perf:     性能优化' },
    { value: 'test', name: 'test:     增加测试' },
    { value: 'chore', name: 'chore:    构建过程或辅助工具的变动' },
    { value: 'revert', name: 'revert:   回退' },
    { value: 'build', name: 'build:    打包' }
  ],
  // 消息步骤
  messages: {
    type: '请选择提交类型:',
    customScope: '请输入修改范围(可选):',
    subject: '请简要描述提交(必填):',
    body: '请输入详细描述(可选):',
    footer: '请输入要关闭的issue(可选):',
    confirmCommit: '确认使用以上信息提交？(y/n/e/h)'
  },
  // 跳过问题(配置此选项后，中括号里的步骤将跳过)
  // skipQuestions: ['body', 'footer'],
  // subject文字长度默认是72
  subjectLimit: 72
}
</code></pre>
</li>
<li>
<p>使用 <code>git cz</code> 代替 <code>git commit</code><br />
使用 <code>git cz</code> 代替 <code>git commit</code>，即可看到提示内容</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904266.jpg" alt="" /></p>
</li>
</ol>
<p>那么到这里我们就已经可以使用<code>git cz</code> 来代替了 <code>git commit</code> 实现了规范化的提交诉求了，但是当前依然存在着一个问题，那就是我们必须要通过 <code>git cz</code> 指令才可以完成规范化提交！</p>
<p>那么如果有马虎的同事，它们忘记了使用 <code>git cz</code> 指令，直接就提交了怎么办呢？</p>
<p>那么有没有方式来限制这种错误的出现呢？</p>
<p>答案是有的！</p>
<p>下一节我们来看 《什么是 Git Hooks》</p>
<h2><a id="git-hooks" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Git Hooks</h2>
<p>上一小节中我们使用了 <code>git cz</code> 来代替了 <code>git commit</code> 实现了规范化的提交诉求，但是依然存在着有人会忘记使用的问题。那么这一小节我们就来看一下这样的问题，我们应该如何去进行解决。</p>
<p>先来明确一下我们最终要实现的效果：我们希望当《提交描述信息》不符合 <a href="https://www.conventionalcommits.org/zh-hans/v1.0.0/">约定式提交规范</a> 的时候，阻止当前的提交，并抛出对应的错误提示。而要实现这个目的，我们就需要先来了解一个概念，叫做 <code>Git hooks（git 钩子 || git 回调方法）</code></p>
<p>也就是：<strong><code>git</code> 在执行某个事件之前或之后进行一些其他额外的操作</strong></p>
<p>而我们所期望的 <strong>阻止不合规的提交消息</strong>，那么就需要使用到 <code>hooks</code> 的钩子函数。</p>
<p>下面是我整理出来的所有的 <code>hooks</code> ，大家可以进行一下参考，其中加粗的是常用到的 <code>hooks</code>：</p>
<table>
<thead>
<tr>
<th style="text-align: left">Git Hook</th>
<th>调用时机</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">pre-applypatch</td>
<td><code>git am</code>执行前</td>
<td></td>
</tr>
<tr>
<td style="text-align: left">applypatch-msg</td>
<td><code>git am</code>执行前</td>
<td></td>
</tr>
<tr>
<td style="text-align: left">post-applypatch</td>
<td><code>git am</code>执行后</td>
<td>不影响<code>git am</code>的结果</td>
</tr>
<tr>
<td style="text-align: left"><strong>pre-commit</strong></td>
<td><code>git commit</code>执行前</td>
<td>可以用<code>git commit --no-verify</code>绕过</td>
</tr>
<tr>
<td style="text-align: left"><strong>commit-msg</strong></td>
<td><code>git commit</code>执行前</td>
<td>可以用<code>git commit --no-verify</code>绕过</td>
</tr>
<tr>
<td style="text-align: left">post-commit</td>
<td><code>git commit</code>执行后</td>
<td>不影响<code>git commit</code>的结果</td>
</tr>
<tr>
<td style="text-align: left">pre-merge-commit</td>
<td><code>git merge</code>执行前</td>
<td>可以用<code>git merge --no-verify</code>绕过。</td>
</tr>
<tr>
<td style="text-align: left">prepare-commit-msg</td>
<td><code>git commit</code>执行后，编辑器打开之前</td>
<td></td>
</tr>
<tr>
<td style="text-align: left">pre-rebase</td>
<td><code>git rebase</code>执行前</td>
<td></td>
</tr>
<tr>
<td style="text-align: left">post-checkout</td>
<td><code>git checkout</code>或<code>git switch</code>执行后</td>
<td>如果不使用<code>--no-checkout</code>参数，则在<code>git clone</code>之后也会执行。</td>
</tr>
<tr>
<td style="text-align: left">post-merge</td>
<td><code>git commit</code>执行后</td>
<td>在执行<code>git pull</code>时也会被调用</td>
</tr>
<tr>
<td style="text-align: left">pre-push</td>
<td><code>git push</code>执行前</td>
<td></td>
</tr>
<tr>
<td style="text-align: left">pre-receive</td>
<td><code>git-receive-pack</code>执行前</td>
<td></td>
</tr>
<tr>
<td style="text-align: left">update</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align: left">post-receive</td>
<td><code>git-receive-pack</code>执行后</td>
<td>不影响<code>git-receive-pack</code>的结果</td>
</tr>
<tr>
<td style="text-align: left">post-update</td>
<td>当 <code>git-receive-pack</code>对 <code>git push</code> 作出反应并更新仓库中的引用时</td>
<td></td>
</tr>
<tr>
<td style="text-align: left">push-to-checkout</td>
<td>当``git-receive-pack<code>对</code>git push`做出反应并更新仓库中的引用时，以及当推送试图更新当前被签出的分支且`receive.denyCurrentBranch`配置被设置为`updateInstead`时</td>
<td></td>
</tr>
<tr>
<td style="text-align: left">pre-auto-gc</td>
<td><code>git gc --auto</code>执行前</td>
<td></td>
</tr>
<tr>
<td style="text-align: left">post-rewrite</td>
<td>执行<code>git commit --amend</code>或<code>git rebase</code>时</td>
<td></td>
</tr>
<tr>
<td style="text-align: left">sendemail-validate</td>
<td><code>git send-email</code>执行前</td>
<td></td>
</tr>
<tr>
<td style="text-align: left">fsmonitor-watchman</td>
<td>配置<code>core.fsmonitor</code>被设置为<code>.git/hooks/fsmonitor-watchman</code>或<code>.git/hooks/fsmonitor-watchmanv2</code>时</td>
<td></td>
</tr>
<tr>
<td style="text-align: left">p4-pre-submit</td>
<td><code>git-p4 submit</code>执行前</td>
<td>可以用<code>git-p4 submit --no-verify</code>绕过</td>
</tr>
<tr>
<td style="text-align: left">p4-prepare-changelist</td>
<td><code>git-p4 submit</code>执行后，编辑器启动前</td>
<td>可以用<code>git-p4 submit --no-verify</code>绕过</td>
</tr>
<tr>
<td style="text-align: left">p4-changelist</td>
<td><code>git-p4 submit</code>执行并编辑完<code>changelist message</code>后</td>
<td>可以用<code>git-p4 submit --no-verify</code>绕过</td>
</tr>
<tr>
<td style="text-align: left">p4-post-changelist</td>
<td><code>git-p4 submit</code>执行后</td>
<td></td>
</tr>
<tr>
<td style="text-align: left">post-index-change</td>
<td>索引被写入到<code>read-cache.c do_write_locked_index</code>后</td>
<td></td>
</tr>
</tbody>
</table>
<p>PS：详细的 <code>HOOKS介绍</code> 可点击<a href="https://git-scm.com/docs/githooks">这里</a>查看</p>
<p>整体的 <code>hooks</code> 非常多，当时我们其中用的比较多的其实只有两个：</p>
<table>
<thead>
<tr>
<th style="text-align: left">Git Hook</th>
<th>调用时机</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left"><strong>pre-commit</strong></td>
<td><code>git commit</code>执行前<br />它不接受任何参数，并且在获取提交日志消息并进行提交之前被调用。脚本<code>git commit</code>以非零状态退出会导致命令在创建提交之前中止。</td>
<td>可以用<code>git commit --no-verify</code>绕过</td>
</tr>
<tr>
<td style="text-align: left"><strong>commit-msg</strong></td>
<td><code>git commit</code>执行前<br />可用于将消息规范化为某种项目标准格式。<br />还可用于在检查消息文件后拒绝提交。</td>
<td>可以用<code>git commit --no-verify</code>绕过</td>
</tr>
</tbody>
</table>
<p>简单来说这两个钩子：</p>
<ol>
<li><code>commit-msg</code>：可以用来规范化标准格式，并且可以按需指定是否要拒绝本次提交</li>
<li><code>pre-commit</code>：会在提交前被调用，并且可以按需指定是否要拒绝本次提交</li>
</ol>
<p>而我们接下来要做的关键，就在这两个钩子上面。</p>
<h2><a id="husky-commitlint%E6%A3%80%E6%9F%A5%E6%8F%90%E4%BA%A4%E6%98%AF%E5%90%A6%E8%A7%84%E8%8C%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>husky + commitlint 检查提交是否规范</h2>
<p>在上一小节中，我们了解了 <code>git hooks</code> 的概念，那么接下来我们就使用 <code>git hooks</code> 来去校验我们的提交信息。</p>
<p>要完成这么个目标，那么我们需要使用两个工具：</p>
<ol>
<li>
<p><a href="https://github.com/conventional-changelog/commitlint">commitlint</a>：用于检查提交信息</p>
</li>
<li>
<p><a href="https://github.com/typicode/husky">husky</a>：是<code>git hooks</code>工具</p>
</li>
</ol>
<p>注意：<strong><code>npm</code> 需要在 7.x 以上版本！！！！！</strong></p>
<p>那么下面我们分别来去安装一下这两个工具：</p>
<h3><a id="commitlint" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>commitlint</h3>
<ol>
<li>
<p>安装依赖：</p>
<pre><code class="language-plain_text">npm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4
</code></pre>
</li>
<li>
<p>创建 <code>commitlint.config.js</code> 文件</p>
<pre><code class="language-plain_text">echo &quot;module.exports = {extends: ['@commitlint/config-conventional']}&quot; &gt; commitlint.config.js
</code></pre>
</li>
<li>
<p>打开 <code>commitlint.config.js</code> ， 增加配置项（ <a href="https://github.com/conventional-changelog/commitlint/blob/master/@commitlint/config-conventional/index.js">config-conventional 默认配置点击可查看</a> ）：</p>
<pre><code class="language-js">module.exports = {
  // 继承的规则
  extends: ['@commitlint/config-conventional'],
  // 定义规则类型
  rules: {
    // type 类型定义，表示 git 提交的 type 必须在以下类型范围内
    'type-enum': [
      2,
      'always',
      [
        'feat', // 新功能 feature
        'fix', // 修复 bug
        'docs', // 文档注释
        'style', // 代码格式(不影响代码运行的变动)
        'refactor', // 重构(既不增加新功能，也不是修复bug)
        'perf', // 性能优化
        'test', // 增加测试
        'chore', // 构建过程或辅助工具的变动
        'revert', // 回退
        'build' // 打包
      ]
    ],
    // subject 大小写不做校验
    'subject-case': [0]
  }
}

</code></pre>
</li>
</ol>
<p><strong>注意：确保保存为 <code>UTF-8</code> 的编码格式</strong>，否则可能会出现以下错误：</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904278.png" alt="image-20210710121456416" /></p>
<p>接下来我们来安装 <code>husky</code></p>
<h3><a id="husky" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>husky</h3>
<ol>
<li>
<p>安装依赖：</p>
<pre><code class="language-plain_text">npm install husky@7.0.1 --save-dev
</code></pre>
</li>
<li>
<p>启动 <code>hooks</code> ， 生成 <code>.husky</code> 文件夹</p>
<pre><code class="language-plain_text">npx husky install
</code></pre>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904287.png" alt="image-20210906202034156" /></p>
</li>
<li>
<p>在 <code>package.json</code> 中生成 <code>prepare</code> 指令（ <strong>需要 npm &gt; 7.0 版本</strong> ）</p>
<pre><code class="language-plain_text">npm set-script prepare &quot;husky install&quot;
</code></pre>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904296.png" alt="image-20210906202128323" /></p>
</li>
<li>
<p>执行 <code>prepare</code> 指令</p>
<pre><code class="language-plain_text">npm run prepare
</code></pre>
</li>
<li>
<p>执行成功，提示<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904306.png" alt="image-20210710120053221" /></p>
</li>
<li>
<p>添加 <code>commitlint</code> 的 <code>hook</code> 到 <code>husky</code>中，并指令在 <code>commit-msg</code> 的 <code>hooks</code> 下执行 <code>npx --no-install commitlint --edit &quot;$1&quot;</code> 指令</p>
<pre><code class="language-plain_text">npx husky add .husky/commit-msg 'npx --no-install commitlint --edit &quot;$1&quot;'
</code></pre>
</li>
<li>
<p>此时的 <code>.husky</code> 的文件结构<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904314.png" alt="image-20210710120228931" /></p>
</li>
</ol>
<p>至此， 不符合规范的 commit 将不再可提交：</p>
<pre><code class="language-plain_text">PS F:\xxxxxxxxxxxxxxxxxxxxx\imooc-admin&gt; git commit -m &quot;测试&quot;
⧗   input: 测试
✖   subject may not be empty [subject-empty]
✖   type may not be empty [type-empty]

✖   found 2 problems, 0 warnings
ⓘ   Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlint

husky - commit-msg hook exited with code 1 (error)
</code></pre>
<p>那么至此，我们就已经可以处理好了 <strong>强制规范化的提交要求</strong>，到现在 <strong>不符合规范的提交信息，将不可在被提交！</strong></p>
<p>那么到这里我们的 <strong>规范化目标</strong> 就完成了吗？当然没有！现在我们还缺少一个 <strong>规范化的处理</strong> ，那就是 <strong>代码格式提交规范处理！</strong> 有同学看到这里可能说，咦！ 这个怎么看着这么眼熟啊？这个事情我们之前不是做过了吗？还需要在处理什么？</p>
<p>欲知后事如何，请看下一节《通过 pre-commit 处理提交时代码规范》</p>
<h2><a id="pre-commit%E6%A3%80%E6%B5%8B%E6%8F%90%E4%BA%A4%E6%97%B6%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>pre-commit 检测提交时代码规范</h2>
<p>在 <strong><code>ESLint</code> 与 <code>Prettier</code> 配合解决代码格式问题</strong> 的章节中，我们讲解了如何处理 <strong>本地代码格式问题。</strong> 但是这样的一个格式处理问题，他只能够在本地进行处理，并且我们还需要 <strong>手动在  <code>VSCode</code> 中配置自动保存</strong> 才可以。那么这样就会存在一个问题，要是有人忘记配置这个东西了怎么办呢？他把代码写的乱七八糟的直接就提交了怎么办呢？</p>
<p>所以我们就需要有一种方式来规避这种风险。</p>
<p>那么想要完成这么一个操作就需要使用 <code>husky</code> 配合 <code>eslint</code> 才可以实现。</p>
<p>我们期望通过 <strong><code>husky</code> 监测 <code>pre-commit</code> 钩子，在该钩子下执行 <code>npx eslint --ext .js,.vue src</code></strong> 指令来去进行相关检测：</p>
<ol>
<li>
<p>执行 <code>npx husky add .husky/pre-commit &quot;npx eslint --ext .js,.vue src&quot;</code> 添加 <code>commit</code> 时的 <code>hook</code> （<code>npx eslint --ext .js,.vue src</code> 会在执行到该 hook 时运行）</p>
</li>
<li>
<p>该操作会生成对应文件 <code>pre-commit</code>：<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904323.png" alt="image-20210906204043915" /></p>
</li>
<li>
<p>关闭 <code>VSCode</code> 的自动保存操作</p>
</li>
<li>
<p>修改一处代码，使其不符合 <code>ESLint</code> 校验规则</p>
</li>
<li>
<p>执行 <strong>提交操作</strong> 会发现，抛出一系列的错误，代码无法提交</p>
<pre><code class="language-plain_text">PS F:\xxxxxxxxxxxxxxxxxxx\imooc-admin&gt; git commit -m 'test'

F:\xxxxxxxxxxxxxxxx\imooc-admin\src\views\Home.vue
  13:9  error  Strings must use singlequote  quotes

✖ 1 problem (1 error, 0 warnings)
  1 error and 0 warnings potentially fixable with the `--fix` option.

husky - pre-commit hook exited with code 1 (error)
</code></pre>
</li>
<li>
<p>想要提交代码，必须处理完成所有的错误信息</p>
</li>
</ol>
<p>那么到这里位置，我们已经通过 <code>pre-commit</code> 检测到了代码的提交规范问题。</p>
<p>那么到这里就万事大吉了吗？</p>
<p>在这个世界上从来不缺的就是懒人，错误的代码格式可能会抛出很多的 <code>ESLint</code> 错误，让人看得头皮发麻。严重影响程序猿的幸福指数。</p>
<p>那么有没有办法，让程序猿在 0 配置的前提下，哪怕代码格式再乱，也可以 <strong>”自动“</strong> 帮助他修复对应的问题，并且完成提交呢？</p>
<p>你别说，还真有！</p>
<p>那么咱们来看下一节《lint-staged 自动修复格式错误》</p>
<h2><a id="lint-staged%E8%87%AA%E5%8A%A8%E4%BF%AE%E5%A4%8D%E6%A0%BC%E5%BC%8F%E9%94%99%E8%AF%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>lint-staged 自动修复格式错误</h2>
<p>在上一章中我们通过 <code>pre-commit</code> 处理了 <strong>检测代码的提交规范问题，当我们进行代码提交时，会检测所有的代码格式规范</strong> 。</p>
<p>但是这样会存在两个问题：</p>
<ol>
<li>我们只修改了个别的文件，没有必要检测所有的文件代码格式</li>
<li>它只能给我们提示出对应的错误，我们还需要手动的进行代码修改</li>
</ol>
<p>那么这一小节，我们就需要处理这两个问题</p>
<p>那么想要处理这两个问题，就需要使用另外一个插件 <a href="https://github.com/okonet/lint-staged">lint-staged</a> ！</p>
<p><a href="https://github.com/okonet/lint-staged">lint-staged</a> 可以让你当前的代码检查 <strong>只检查本次修改更新的代码，并在出现错误的时候，自动修复并且推送</strong></p>
<p><a href="https://github.com/okonet/lint-staged">lint-staged</a> 无需单独安装，我们生成项目时，<code>vue-cli</code> 已经帮助我们安装过了，所以我们直接使用就可以了</p>
<ol>
<li>
<p>修改 <code>package.json</code> 配置</p>
<pre><code class="language-js">&quot;lint-staged&quot;: {
    &quot;src/**/*.{js,vue}&quot;: [
      &quot;eslint --fix&quot;,
      &quot;git add&quot;
    ]
  }
</code></pre>
</li>
<li>
<p>如上配置，每次它只会在你本地 <code>commit</code> 之前，校验你提交的内容是否符合你本地配置的 <code>eslint</code>规则(这个见文档 <a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/advanced/eslint.html">ESLint</a> )，校验会出现两种结果：</p>
<ol>
<li>如果符合规则：则会提交成功。</li>
<li>如果不符合规则：它会自动执行 <code>eslint --fix</code> 尝试帮你自动修复，如果修复成功则会帮你把修复好的代码提交，如果失败，则会提示你错误，让你修好这个错误之后才能允许你提交代码。</li>
</ol>
</li>
<li>
<p>修改 <code>.husky/pre-commit</code> 文件</p>
<pre><code class="language-js">#!/bin/sh
. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;

npx lint-staged

</code></pre>
</li>
<li>
<p>再次执行提交代码</p>
</li>
<li>
<p>发现 <strong>暂存区中</strong> 不符合 <code>ESlint</code> 的内容，被自动修复</p>
</li>
</ol>
<h2><a id="vetur%E6%A3%80%E6%B5%8B-template%E7%9A%84%E5%8D%95%E4%B8%80%E6%A0%B9%E5%85%83%E7%B4%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>vetur 检测 template 的单一根元素</h2>
<p>在 <code>vue2</code> 中，<code>template</code> 只允许存在一个根元素，但是这种情况在 <code>vue3</code> 里发生了一些变化。在 <code>Vue3</code> 中开始支持 <code>template</code> 存在多个根元素了。但是因为 <code>VSCode</code> 中的一些插件没有及时更新，所以当你在 <code>template</code> 中写入多个根元素时，有可能会出现以下的错误：</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904332.png" alt="image-20210717190311264" /></p>
<p>出现这个问题的原因主要是： <code>vetur</code> 这个 <code>vsCode</code> 插件依然按照 <code>vue2</code> 的单一根元素逻辑进行检测，所以会出现提示错误的问题。</p>
<p>但是大家要注意，虽然这样不太好看，但是 <strong>该问题并不影响代码运行！</strong> 如果你实在觉得这样太丑的话，那么可以通过以下方案来 <strong>取消 <code>vetur</code> 对 <code>template</code> 的检测：</strong></p>
<ol>
<li>
<p>在 <code>VSCode</code>  的设置中，搜索 <code>vetur</code>，找到如下设置，取消勾选</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904341.png" alt="image-20210717190629024" /></p>
</li>
<li>
<p>重启 <code>VSCode</code></p>
<p>按以上两种方式执行之后，你的多根元素就不会出现不好看的错误了<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904350.png" alt="image-20210910092410872" /></p>
</li>
</ol>
<h2><a id="%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>本章小结</h2>
<p>本章中我们处理了 <strong>编程格式规范的问题</strong>，整个规范大体可以分为两大类：</p>
<ol>
<li>代码格式规范</li>
<li><code>git</code> 提交规范</li>
</ol>
<p><strong>代码格式规范：</strong></p>
<p>对于 <strong>代码格式规范</strong> 而言，我们通过 <code>ESLint</code> + <code>Prettier</code> + <code>VSCode 配置</code> 配合进行了处理。</p>
<p>最终达到了在保存代码时，自动规范化代码格式的目的。</p>
<p><strong><code>git</code> 提交规范：</strong></p>
<p>对于 <strong><code>git</code> 提交规范</strong> 而言我们使用了 <code>husky</code> 来监测 <code>Git hooks</code> 钩子，并且通过以下插件完成了对应的配置：</p>
<ol>
<li><a href="https://www.conventionalcommits.org/zh-hans/v1.0.0/">约定式提交规范</a></li>
<li><a href="https://github.com/commitizen/cz-cli">commitizen</a>：git 提交规范化工具</li>
<li><a href="https://github.com/conventional-changelog/commitlint">commitlint</a>：用于检查提交信息</li>
<li><code>pre-commit</code>： <code>git hooks</code> 钩子</li>
<li><a href="https://github.com/okonet/lint-staged">lint-staged</a>：只检查本次修改更新的代码，并在出现错误的时候，自动修复并且推送</li>
</ol>
<p>那么处理完成这些规范操作之后，在下一章我们将会正式进入到咱们的项目开发之中！</p>
<h1><a id="%E7%99%BB%E5%BD%95%E6%9E%B6%E6%9E%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%8E%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>登录架构解决方案与实现</h1>
<p>项目架构之搭建登录架构解决方案与实现。</p>
<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>在上一章中，我们处理了基本的编码规范，那么接下来我们就可以实现对应的项目开发了。</p>
<p>那么在之后的项目开发中，我们将会使用最新的 <code>vue3 script setup</code> 语法。</p>
<p>所以说在本章节中我们需要做两件事情：</p>
<ol>
<li>
<p><code>vue3</code> 最新特性及最新语法</p>
</li>
<li>
<p>登录功能开发</p>
</li>
</ol>
<p>不过大家放心，我们不会把大量的时间花费到 <strong>枯燥的语法学习之中</strong>，而是会在实际的项目开发中和大家一起逐渐深入学习  <code>script setup</code> 语法，毕竟 <strong>学以致用</strong> 才是我们遵循的唯一目标。</p>
<p>那么明确好了我们接下来要做的事情之后，咱们就开始新的篇章吧！</p>
<h2><a id="vue3%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>vue3 项目结构解析</h2>
<p>想要进行项目的开发，那么首先我们需要先去了解一下 <code>vue3</code> 项目的初始结构</p>
<p>在这里我们把它和 <code>vue2</code> 的项目进行对比来去说明</p>
<ol>
<li><code>main.js</code>
<ol>
<li>通过 <strong>按需导入</strong>的 <code>createApp</code> 方法来来构建 <code>vue</code> 实例</li>
<li>通过 <code>vue实例.use</code> 方法来挂载插件（<code>router</code>、<code>vuex</code>）</li>
<li>没有了 <code>Vue</code> 构造方法，无法再挂载原型</li>
</ol>
<pre><code class="language-javascript"> import { createApp } from 'vue'
 import App from './App.vue'
 import router from './router'
 import store from './store'
 
 createApp(App).use(store).use(router).mount('#app')
</code></pre>
</li>
<li><code>App.vue</code>
<ol>
<li>组件内部结构无变化，依然是
<ol>
<li><code>tempalte</code></li>
<li><code>script</code></li>
<li><code>style</code></li>
</ol>
</li>
<li><code>&lt;template&gt;</code> 标签中支持多个根标签</li>
</ol>
</li>
<li><code>store/index.js</code>
<ol>
<li>通过 <strong>按需导入</strong>的 <code>createStore</code> 方法来来构建 <code>store</code> 实例</li>
<li>无需再通过 <code>Vue.use(Vuex)</code> 的形式进行挂载</li>
</ol>
<pre><code class="language-javascript"> import { createStore } from 'vuex'
 
 export default createStore({
   state: {
   },
   getters: {
   },
   mutations: {
   },
   actions: {
   },
   modules: {
   }
 })
</code></pre>
</li>
<li><code>router/index.js</code>
<ol>
<li>通过 <strong>按需导入</strong>的 <code>createRouter</code> 方法来构建 <code>router</code> 实例</li>
<li>通过 <strong>按需导入</strong>的 <code>createWebHashHistory</code> 方法来创建 <strong><code>hash</code> 模式对象</strong>，进行路由模式指定</li>
<li>无需再通过 <code>Vue.use(VueRouter)</code> 的形式进行挂载</li>
<li><code>routes</code> 路由表的定义无差别</li>
</ol>
<pre><code class="language-javascript"> import { createRouter, createWebHashHistory } from 'vue-router'
 import HomeView from '../views/HomeView.vue'
 
 const routes = [
   {
     path: '/',
     name: 'home',
     component: HomeView
   },
   {
     path: '/about',
     name: 'about',
     // route level code-splitting
     // this generates a separate chunk (about.[hash].js) for this route
     // which is lazy-loaded when the route is visited.
     component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ '../views/AboutView.vue')
   }
 ]
 
 const router = createRouter({
   history: createWebHashHistory(),
   routes
 })
 
 export default router
</code></pre>
</li>
</ol>
<p>综上所述，在 <code>vue3</code> 的初始化项目中，与 <code>vue2</code> 对比的最大差异其实就是两点：</p>
<ol>
<li><code>vue3</code> 使用 <strong>按需导入的形式</strong> 进行初始化操作</li>
<li><code>&lt;template&gt;</code> 标签中支持多个根标签</li>
</ol>
<p>那么这一小节我们主要了解了 <code>vue3</code> 项目的初始结构，通过了解我们也可以发现现在的项目中，存在很多的 <strong>无用代码</strong>，那么下一小节我们就需要 <strong>删除掉这些无用的默认代码</strong>，也就是进行  <strong>初始化项目</strong> 操作。</p>
<h2><a id="%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>初始化项目结构</h2>
<p><code>@vue/cli</code> 在帮助我们创建项目的同时，也生成了很多无用的代码，那么这一小节我们需要去除掉这些无用的代码。</p>
<p>去除的方式如下所示：</p>
<ol>
<li>
<p><code>App.vue</code> 初始化代码如下：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;router-view /&gt;
&lt;/template&gt;

&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt;
</code></pre>
</li>
<li>
<p>删除 <code>views</code> 文件夹下的所有 <code>.vue</code> 文件</p>
</li>
<li>
<p>删除 <code>components</code> 文件夹下的所有 <code>.vue</code> 文件</p>
</li>
<li>
<p><code>router/index.js</code> 中初始化代码如下：</p>
<pre><code class="language-js">import { createRouter, createWebHashHistory } from 'vue-router'

const routes = []

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router

</code></pre>
</li>
<li>
<p>浏览器中重新访问你的应用，得到如下页面即可：<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/21/16663121420341.png" alt="image-20210907193641796" /></p>
</li>
</ol>
<h2><a id="vue3%E6%96%B0%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>vue3 新特性介绍</h2>
<p>在开始本小节的内容之前，我必须要先声明一点：</p>
<p><strong>我们不会在课程中专门开辟出一段内容讲解 <code>vue3</code> 的知识。而是会在项目开发的过程中，通过实际场景逐步解锁对应的知识点，以达到学以致用的目的！</strong></p>
<p>所以说本小节的 <strong><code>vue3</code> 新特性介绍</strong> ，我们只会概述性的来介绍一下 <code>vue3</code> 中新增的主要内容。</p>
<p>那么明确好了我们的目标之后，<code>vue3</code> 中到底新增了哪些比较核心的东西呢？：</p>
<ol>
<li><code>composition API</code></li>
<li>使用了 <code>Proxy</code> 代替 <code>Object.defineProperty()</code> 实现响应式</li>
<li>全新的全家桶</li>
<li>全新的 <code>TS</code> 支持</li>
<li><code>vite</code></li>
</ol>
<h3><a id="composition-api%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F-api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Composition API：组合式 API</h3>
<p>想要了解 <strong>组合式 API</strong>，那么首先我们需要先了解 <code>options API</code>，也就是 <code>vue2</code> 中的开发形式。</p>
<p><code>vue2</code> 中的开发形式被称为 <code>options API</code>，<code>options API</code> 存在</p>
<ul>
<li>方便</li>
<li>易学</li>
<li>清晰</li>
</ul>
<p>等一些特点，但是也存在着一些问题。</p>
<p>而其中最主要的一个问题就是：<strong>当你的组件变得越来越复杂时，组件的可读性会变得越来越差。</strong></p>
<p>不知道大家有没有遇到过一种情况，那就是：<strong>你在完成一个组件代码时，总是需要不停的上下滚动滚轮，来查看 <code>data</code> 、<code>methods</code>、<code>computed</code> 之间的配合使用，就像下面一样</strong></p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/21/16663152314467.gif" alt="options api" /></p>
<p>这个截图中的代码大家不需要深究。</p>
<p>在这个动图中我们定义的两个数据 <code>optionsData</code> 和 <code>selectOption</code>，然后我们在多个方法中都使用到了它们，但是大家可以发现，我们在使用或查看的过程中，得一直不停的翻动页面！</p>
<p>因为我们的整体组件代码结构是这样的：</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/21/16663152314581.png" alt="image-20210907203504116" /></p>
<p><strong>定义数据与使用数据被分割在组件的各个位置，导致我们需要不断地翻滚页面来查看具体的业务逻辑！</strong></p>
<p>并且这种现象随着组件越来越复杂，这种情况会变得越来越严重！</p>
<p>而这个就是 <code>options API</code> 所存在的问题：<strong>当你的组件变得越来越复杂时，组件的可读性会变得越来越差。</strong></p>
<p>而 <code>Composition API</code> 所期望解决的就是这么一个问题</p>
<p><img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/21/16663152314592.jpg" alt="1570466251996_04-logical-concerns" /></p>
<p><strong>把定义数据与使用数据的逻辑放在一起进行处理，以达到更加易读，更加方便扩展的目的！</strong></p>
<p>那么具体怎么去做的，我们会在后面的课程中通过最新的 <code>RFC -&gt; script setup</code> 语法为大家进行解读。</p>
<h3><a id="%E4%BD%BF%E7%94%A8%E4%BA%86proxy%E4%BB%A3%E6%9B%BF-object-defineproperty%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用了 <code>Proxy</code> 代替 <code>Object.defineProperty()</code> 实现响应式</h3>
<p>在 <a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">vue 2 的文档中</a> 有这么一段话：</p>
<blockquote>
<p>由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化。</p>
</blockquote>
<p>这里所谓的 <strong><code>JavaScript</code> 的限制</strong>，所指的就是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty()</a> 的限制。</p>
<p>因为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty()</a> 是通过：<strong>为对象属性指定描述符</strong> 的方式来监听 <strong>对象中某个属性的 <code>get</code> 和 <code>set</code></strong>。</p>
<p>所以在以下两种情况下，新的属性是 <strong>非响应式的</strong>：</p>
<ol>
<li>
<p><a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1">对于对象</a>：</p>
<pre><code class="language-js">var vm = new Vue({
  data:{
    a:1
  }
})

// `vm.a` 是响应式的

vm.b = 2
// `vm.b` 是非响应式的
</code></pre>
</li>
<li>
<p><a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84">对于数组</a>：</p>
<pre><code class="language-js">var vm = new Vue({
  data: {
    items: ['a', 'b', 'c']
  }
})
vm.items[1] = 'x' // 不是响应性的
vm.items.length = 2 // 不是响应性的
</code></pre>
</li>
</ol>
<p>这也是为什么会存在 <a href="https://cn.vuejs.org/v2/api/#Vue-set">Vue.set</a> 这个 <code>API</code> 的原因。</p>
<p>但是，这样的一种情况其实一直都是不合理的，因为这只是无意义的增加了复杂度而已，但是一直以来因为  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty()</a> 这个 <code>API</code> 本身的限制，所以一直无法处理。</p>
<p>直到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> 被广泛支持，这种情况才发生了变化。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> 用于：<strong>为对象创建一个代理，从而实现基本操作的拦截。</strong> 那么这样就从根本上解决了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty()</a> 所面临的那么两个问题。这也是为什么 <code>vue3</code> 中不再有 <code>Vue.set</code> 方法的原因。</p>
<p>关于 <code>proxy</code> 的详细介绍，大家可以查看这一篇博客 <a href="https://www.imooc.com/article/320582">Vue 3 深入响应式原理 - 聊一聊响应式构建的那些经历</a>，在视频中，我们就不过多赘述了</p>
<h3><a id="%E5%85%A8%E6%96%B0%E7%9A%84%E5%85%A8%E5%AE%B6%E6%A1%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全新的全家桶</h3>
<p><code>vue</code> 被称为是 <strong>渐进式框架</strong>，就是因为，对于 <code>vue</code> 而言，它不仅仅只有 <code>vue.js</code> 这一个核心库，还有其他的比如 <a href="https://next.router.vuejs.org/zh/">vue-router</a>，<a href="https://next.vuex.vuejs.org/zh/index.html">vuex</a> 等一些周边库。这些周边库和 <code>vue.js</code> 一起共同组成了 <code>vue</code> 。</p>
<p>所以说当 <code>vue3</code> 发布之后，<code>vue-router</code>、<code>vuex</code> 等全家桶也迎来了一波更新。在前面的 <strong>vue3 项目结构解析</strong> 这一小节，大家应该也能看到对应的代码变化。</p>
<p>那么关于全家桶的更新内容，我们会在后面的课程中进行详细的讲解，所以就不在这里进行赘述了。</p>
<h3><a id="%E5%85%A8%E6%96%B0%E7%9A%84ts%E6%94%AF%E6%8C%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全新的 <code>TS</code> 支持</h3>
<p><code>vue 3</code> 使用 <code>TypeScript</code> 进行了重构，其目的是 <strong>为了防止随着应用的增长，而产生的许多潜在的运行时静态类型的错误</strong> 。同时这也意味着以后在 <code>vue</code> 中使用 <code>TypeScript</code> 不再需要其他的任何工具。</p>
<p>但是有一点我需要提醒大家，虽然 <code>vue</code> 对 <code>TypeScript</code> 进行全面支持，这并不代表我们应该在任何情况下都<strong>无条件</strong>的使用 <code>TypeScript</code>（后面我们简称 <code>TypeScript</code> 为 <code>TS</code>）。</p>
<p><code>TS</code> 的优势主要在于 <strong>静态类型检查和环境声明</strong>，但同时它也会为你的项目增加复杂度。如果你的项目需要使用到以上两点，那么我推荐你使用 <code>TS</code> 。否则只是增加了无谓的复杂度而已。</p>
<p><strong>决定我们应该使用哪种技术的唯一条件，就是我们的目标。</strong> 我们需要做的是在可以 <strong>完成目标</strong> 的基础上，寻找最简单的实现方案。</p>
<p>所以，基于以上原因，我们项目中并<strong>没有</strong>使用 <code>TS</code> 进行项目的开发。如果在后续的过程中，发现大家有这方面的需要，那么我会考虑专门针对 <code>TS</code> 的特性来开发一个对应的项目。</p>
<h3><a id="vite" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>vite</h3>
<p>最后就是一个新的打包工具 <a href="https://cn.vitejs.dev/">vite</a>，<a href="https://cn.vitejs.dev/">vite</a> 严格来说不能算是 <code>vue3</code> 的内容，只不过它跟随 <code>vue3</code> 进行了发布所以我们这里就把它算到了新特性里面。</p>
<p><a href="https://cn.vitejs.dev/">vite</a> 的作用其实和 <a href="https://webpack.docschina.org/">webpack</a> 是一样的，都是一个 <strong>前端构建工具</strong>。它区别于 <code>webpack</code> 的地方在于它完全使用了 <code>ES Module</code> 的特性，可以无需预先打包，而是采用实时编译的方式。这样让它具备了远高于 <code>webpack</code> 的启动速度和热更新速度。</p>
<p>但是 <strong>成也萧何，败也萧何</strong> 因为 <code>vite</code> 完全依赖 <code>ES Module</code> 就导致了 它无法直接对 <code>commonJS</code> 的模块化方式进行支持，必须得采用 <a href="https://cn.vitejs.dev/guide/dep-pre-bundling.html">依赖预构建</a> 的形式。</p>
<p>目前 <code>vite</code> 还不够稳定到足够支持商用，所以如果大家只是想要尝鲜，那么没有问题。如果大家希望创建一个商用的大型项目，那么个人还是推荐更加成熟的 <code>webpack</code> 方案。</p>
<p>而我们当前的项目旨在构建一个 <strong>后台前端解决方案系统</strong>，所以我们这里依然选择了 <code>webpack</code> ，而不是 <code>vite</code>。</p>
<h2><a id="%E5%85%A8%E6%96%B0%E7%9A%84%E6%8F%90%E6%A1%88%E8%AF%AD%E6%B3%95script-setup" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全新的提案语法 script setup</h2>
<p>如果大家使用过 早期的 <code>composition API</code> ，那么应该会对 <code>setup 函数</code> 感触颇深，它的语法是反人类的。</p>
<p>所以在  <code>vue3</code> 正式发布 40天 之后， 也就是 <code>2020年10月28日</code> （<code>vue3</code> 正式发布日期为 <code>2020年9月18日</code>）提出了新的 <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0040-script-setup.md">script  setup</a> 提案，该提案的目的只有一个：<strong>那就是让大家可以更爽的使用 <code>composition API</code> 语法</strong>！</p>
<p>该提案在 <code>2021年8月9日</code> 正式定稿，并伴随着最新的 <code>vue3</code> 版本进行了发布，这也是为什么前面我们需要升级到最新的 <code>vue</code> 版本的原因。</p>
<p>下面两张截图为对比 <code>原setup函数</code>  与   <code>script setup</code>：</p>
<ol>
<li>
<p><code>原 setup</code>函数。<br />
变量和方法都需要先定义，然后 return，当页面比较复杂是 setup 函数会比较庞大。<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/20/16662807904095.png" alt="image-20210908103648564" /></p>
</li>
<li>
<p><code>script setup</code><br />
在 script 标签上加上 setup 关键字，script 标签里边就不需要再使用 setup 函数了，并且变量和方法都不需要return，即“所见即所得“。<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/21/16663152314604.png" alt="image-20210908104702818" /></p>
</li>
</ol>
<p>从截图中可以看出 <code>script setup</code> 语法更加符合我们开发者书写 <code>JS</code> 代码的习惯，它让我们书写 <code>vue</code> 就像再写普通的 <code>js</code> 一样。</p>
<p>所以以后的 <code>composition API</code> 将是 <code>script setup</code> 语法的时代，<code>原setup函数</code> 将会逐渐退出历史舞台。而我们的项目也将会全部使用最新的 <code>script setup</code> 语法，让大家紧抓时代脉搏！</p>
<h2><a id="%E5%AF%BC%E5%85%A5element-plus" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>导入 element-plus</h2>
<p>在开发我们的项目之前，我们需要先去导入 <code>element-ui</code> 的 <code>vue3</code> 支持版本，也就是 <a href="http://element-plus.org/#/zh-CN">element-plus</a></p>
<p><code>element-plus</code> 提供了快捷导入的方式，即：<a href="https://github.com/element-plus/vue-cli-plugin-element-plus">vue-cli-plugin-element-plus</a>，大家可以通过以下方式来快捷导入 <code>element-plus</code> （注意：此种方式会自动修改 <code>App.vue</code> 文件）：</p>
<ol>
<li>
<p>在通过 <code>vue-cli</code> 创建的项目中，执行</p>
<pre><code class="language-plain_text">vue add element-plus
</code></pre>
</li>
<li>
<p>选择全局导入<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/21/16663152314614.png" alt="image-20210908111515578" /></p>
</li>
<li>
<p>暂不生成覆盖变量的 <code>scss</code> 文件<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/21/16663152314623.png" alt="image-20210908111550714" /></p>
</li>
<li>
<p>选择简体中文即可<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/21/16663152314632.png" alt="image-20210908111636178" /></p>
</li>
<li>
<p>出现该提示表示安装完成<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/21/16663152314641.png" alt="image-20210908111752361" /></p>
</li>
<li>
<p>此时运行项目，则会得到如下错误<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/21/16663152314651.png" alt="image-20210908111836008" /></p>
</li>
<li>
<p>出现该错误的原因是因为 <a href="https://github.com/element-plus/vue-cli-plugin-element-plus">vue-cli-plugin-element-plus</a> 默认修改了 <code>APP.vue</code> 文件，导入了 <code>HelloWorld</code></p>
</li>
<li>
<p>所以我们需要到 <code>APP.vue</code> 中，初始化如下代码：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;router-view /&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'App'
}
&lt;/script&gt;

&lt;style&gt;&lt;/style&gt;

</code></pre>
</li>
</ol>
<p>那么至此，<code>element-plus</code> 导入成功，下一小节我们就正式开始项目的开发工作吧！</p>
<h2><a id="%E6%9E%84%E5%BB%BA%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2ui%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>构建登录页面 UI 结构</h2>
<ol>
<li>
<p>在 <code>views</code> 中 <code>login</code> 文件夹，创建 <code>index.vue</code> 文件<br />
<img src="http://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/2022/10/25/16666630047709.png" alt="image-20210908112617459" /></p>
</li>
<li>
<p>在 <code>router/index.js</code> 中增加以下路由配置</p>
<pre><code class="language-js">/**
 * 公开路由表
 */
const publicRoutes = [
  {
    path: '/login',
    component: () =&gt; import('@/views/login/index')
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes: publicRoutes
})
</code></pre>
</li>
<li>
<p>在 <code>login/index.vue</code> 中，生成基本页面结构</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;&quot;&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import {} from 'vue'
&lt;/script&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;
</code></pre>
</li>
<li>
<p>创建登录页面基本结构</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;login-container&quot;&gt;
    &lt;el-form class=&quot;login-form&quot; &gt;
      &lt;div class=&quot;title-container&quot;&gt;
        &lt;h3 class=&quot;title&quot;&gt;用户登录&lt;/h3&gt;
      &lt;/div&gt;

      &lt;el-form-item prop=&quot;username&quot;&gt;
        &lt;span class=&quot;svg-container&quot;&gt;
          &lt;el-icon&gt;
            &lt;avatar /&gt;
          &lt;/el-icon&gt;
        &lt;/span&gt;
        &lt;el-input
          placeholder=&quot;username&quot;
          name=&quot;username&quot;
          type=&quot;text&quot;
        /&gt;
      &lt;/el-form-item&gt;

      &lt;el-form-item prop=&quot;password&quot;&gt;
        &lt;span class=&quot;svg-container&quot;&gt;
          &lt;el-icon&gt;
            &lt;avatar /&gt;
          &lt;/el-icon&gt;
        &lt;/span&gt;
        &lt;el-input
          placeholder=&quot;password&quot;
          name=&quot;password&quot;
        /&gt;
        &lt;span class=&quot;show-pwd&quot;&gt;
          &lt;el-icon&gt;
            &lt;avatar /&gt;
          &lt;/el-icon&gt;
        &lt;/span&gt;
      &lt;/el-form-item&gt;

      &lt;el-button type=&quot;primary&quot; style=&quot;width: 100%; margin-bottom: 30px&quot;
        &gt;登录&lt;/el-button
      &gt;
    &lt;/el-form&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
// 导入组件之后无需注册可直接使用，但是首先要安装，参考：https://element-plus.gitee.io/zh-CN/component/icon.html
import { Avatar } from '@element-plus/icons'
import {} from 'vue'
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h2><a id="%E7%BE%8E%E5%8C%96%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>美化登录页面样式</h2>
<ol>
<li>
<p>创建全局的 <code>style</code></p>
<ol>
<li>
<p>在 <code>src</code> 下创建 <code>styles/index.scss</code> 文件，并写入以下内容：</p>
<pre><code class="language-scss">html,
body {
  height: 100%;
  margin: 0;
  padding: 0;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
  font-family: Helvetica Neue, Helvetica, PingFang SC, Hiragino Sans GB,
    Microsoft YaHei, Arial, sans-serif;
}

#app {
  height: 100%;
}

*,
*:before,
*:after {
  box-sizing: inherit;
  margin: 0;
  padding: 0;
}

a:focus,
a:active {
  outline: none;
}

a,
a:focus,
a:hover {
  cursor: pointer;
  color: inherit;
  text-decoration: none;
}

div:focus {
  outline: none;
}

.clearfix {
  &amp;:after {
    visibility: hidden;
    display: block;
    font-size: 0;
    content: ' ';
    clear: both;
    height: 0;
  }
}

</code></pre>
</li>
<li>
<p>在 <code>main.js</code> 中导入全局样式</p>
<pre><code class="language-js">...
// 导入全局样式
import './styles/index.scss'
...
</code></pre>
</li>
<li>
<p>在 <code>views/login/index.vue</code> 中写入以下样式</p>
<pre><code class="language-scss">&lt;style lang=&quot;scss&quot; scoped&gt;
$bg: #2d3a4b;
$dark_gray: #889aa4;
$light_gray: #eee;
$cursor: #fff;

.login-container {
  min-height: 100%;
  width: 100%;
  background-color: $bg;
  overflow: hidden;

  .login-form {
    position: relative;
    width: 520px;
    max-width: 100%;
    padding: 160px 35px 0;
    margin: 0 auto;
    overflow: hidden;

    ::v-deep .el-form-item {
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(0, 0, 0, 0.1);
      border-radius: 5px;
      color: #454545;
    }

    ::v-deep .el-input {
      display: inline-block;
      height: 47px;
      width: 85%;

      input {
        background: transparent;
        border: 0px;
        -webkit-appearance: none;
        border-radius: 0px;
        padding: 12px 5px 12px 15px;
        color: $light_gray;
        height: 47px;
        caret-color: $cursor;
      }
    }
  }


  .svg-container {
    padding: 6px 5px 6px 15px;
    color: $dark_gray;
    vertical-align: middle;
    display: inline-block;
  }

  .title-container {
    position: relative;

    .title {
      font-size: 26px;
      color: $light_gray;
      margin: 0px auto 40px auto;
      text-align: center;
      font-weight: bold;
    }
  }

  .show-pwd {
    position: absolute;
    right: 10px;
    top: 7px;
    font-size: 16px;
    color: $dark_gray;
    cursor: pointer;
    user-select: none;
  }
}
&lt;/style&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h2><a id="icon%E5%9B%BE%E6%A0%87%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%9A-svgicon" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Icon 图标处理方案：SvgIcon</h2>
<p>在上一小节中我们完成了登陆页面的基本样式 。但是现在在登录页面中，还存在着最后一个样式问题，那就是 <code>icon</code> 图标。</p>
<p>在我们的项目中所使用的 <code>icon</code> 图标，一共分为两类：</p>
<ol>
<li><code>element-plus</code> 的图标</li>
<li>自定义的 <code>svg</code> 图标</li>
</ol>
<p>这也是通常情况下企业级项目开发时，所遇到的一种常见情况。</p>
<p>对于 <code>element-plus</code> 的图标我们可以直接通过 <code>el-icon</code> 来进行显示，但是自定义图标的话，我们暂时还缺少显示的方式，所以说我们需要一个自定义的组件，来显示我们自定义的 <code>svg</code> 图标。</p>
<p>那么这种自定义组件处理 <strong>自定义 <code>svg</code> 图标的形式</strong>，就是我们在面临这种问题时的通用解决方案。</p>
<p>那么对于这个组件的话，它就需要拥有两种能力：</p>
<ol>
<li>显示外部 <code>svg</code> 图标</li>
<li>显示项目内的 <code>svg</code> 图标</li>
</ol>
<p>基于以上概念，我们可以创建出以下对应代码：</p>
<blockquote>
<p>关于mask</p>
</blockquote>
<p>创建 <code>components/SvgIcon/index.vue</code>：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div
    v-if=&quot;isExternal&quot;
    :style=&quot;styleExternalIcon&quot;
    class=&quot;svg-external-icon svg-icon&quot;
    :class=&quot;className&quot;
  /&gt;
  &lt;svg v-else class=&quot;svg-icon&quot; :class=&quot;className&quot; aria-hidden=&quot;true&quot;&gt;
    &lt;use :xlink:href=&quot;iconName&quot; /&gt;
  &lt;/svg&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { isExternal as external } from '@/utils/validate'
import { defineProps, computed } from 'vue'
const props = defineProps({
  // icon 图标
  icon: {
    type: String,
    required: true
  },
  // 图标类名
  className: {
    type: String,
    default: ''
  }
})

/**
 * 判断是否为外部图标
 */
const isExternal = computed(() =&gt; external(props.icon))
/**
 * 外部图标样式
 */
const styleExternalIcon = computed(() =&gt; ({
  mask: `url(${props.icon}) no-repeat 50% 50%`,
  '-webkit-mask': `url(${props.icon}) no-repeat 50% 50%`
}))
/**
 * 项目内图标
 */
const iconName = computed(() =&gt; `#icon-${props.icon}`)
&lt;/script&gt;

&lt;style scoped&gt;
.svg-icon {
  width: 1em;
  height: 1em;
  vertical-align: -0.15em;
  fill: currentColor;
  overflow: hidden;
}

.svg-external-icon {
  background-color: currentColor;
  mask-size: cover !important;
  display: inline-block;
}
&lt;/style&gt;

</code></pre>
<p>创建 <code>utils/validate.js</code>：</p>
<pre><code class="language-js">/**
 * 判断是否为外部资源
 */
export function isExternal(path) {
  return /^(https?:|mailto:|tel:)/.test(path)
}

</code></pre>
<p>在 <code>views/login/index.vue</code> 中使用 <strong>外部 <code>svg</code> （<code>https://res.lgdsunday.club/user.svg</code>）：</strong></p>
<pre><code class="language-html">&lt;span class=&quot;svg-container&quot;&gt;
	&lt;svg-icon icon=&quot;https://res.lgdsunday.club/user.svg&quot;&gt;&lt;/svg-icon&gt;
&lt;/span&gt;
</code></pre>
<p>外部图标可正常展示。</p>
<p>那么在本小节中，我们创建了 <code>SvgIcon</code> 组件，用来处理了 <strong>外部图标</strong> 的展示，但是对于内部图标而言，我们此时依然无法进行展示。所以在下一小节中，我们就需要看一下，如何处理内部的 <code>svg</code> 图标。</p>
<h2><a id="%E5%A4%84%E7%90%86%E5%86%85%E9%83%A8svg%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理内部 svg 图标显示</h2>
<p>在上一章中，我们创建了 <code>SvgIcon</code> 组件用于显示 <strong>非 Element-ui</strong> 的图标。但是目前我们只处理了 <strong>外部 <code>svg</code> 的图标展示</strong>，内部的图标还无法展示。</p>
<p>所以这一小节，我们就需要处理 <strong>内部的 <code>svg</code> 图标展示。</strong></p>
<ol>
<li>
<p>首先导入所有的 <code>svg</code> 图标（大家可以从 讲师源代码 -&gt; <code>src -&gt; icons -&gt; svg</code> 处，获取所有 <code>svg</code> 图标），导入到 <code>src -&gt; icons -&gt; svg</code> 处</p>
</li>
<li>
<p>在 <code>icons</code> 下创建 <code>index.js</code> 文件，该文件中需要完成两件事情：</p>
<ol>
<li>导入所有的 <code>svg</code> 图标</li>
<li>完成 <code>SvgIcon</code> 的全局注册</li>
</ol>
</li>
<li>
<p>得出以下代码：</p>
<pre><code class="language-js">import SvgIcon from '@/components/SvgIcon'

// https://webpack.docschina.org/guides/dependency-management/#requirecontext
// 通过 require.context() 函数来创建自己的 context
const svgRequire = require.context('./svg', false, /\.svg$/)
// 此时返回一个 require 的函数，可以接受一个 request 的参数，用于 require 的导入。
// 该函数提供了三个属性，可以通过 require.keys() 获取到所有的 svg 图标
// 遍历图标，把图标作为 request 传入到 require 导入函数中，完成本地 svg 图标的导入
svgRequire.keys().forEach(svgIcon =&gt; svgRequire(svgIcon))

export default app =&gt; {
  app.component('svg-icon', SvgIcon)
}

</code></pre>
</li>
<li>
<p>在 <code>main.js</code> 中引入该文件</p>
<pre><code class="language-js">...
// 导入 svgIcon
import installIcons from '@/icons'
...
installIcons(app)
...

</code></pre>
</li>
<li>
<p>删除 <code>views/login</code> 下 局部导入 <code>SvgIcon</code> 的代码</p>
</li>
<li>
<p>在 <code>login/index.vue</code> 中使用 <code>SvgIcon</code> 引入本地 <code>svg</code></p>
<pre><code class="language-html">// 用户名   
&lt;svg-icon icon=&quot;user&quot; /&gt;
// 密码
&lt;svg-icon icon=&quot;password&quot; /&gt;
// 眼睛
&lt;svg-icon icon=&quot;eye&quot; /&gt;
</code></pre>
</li>
<li>
<p>此时 <strong>处理内容 <code>svg</code> 图标的代码</strong> 已经完成</p>
</li>
</ol>
<p>打开浏览器，我们发现 <strong>图标依然无法展示！</strong> 这又是因为什么原因呢？</p>
<p>来看下一节 《使用 svg-sprite-loader 处理 svg 图标》</p>
<h2><a id="%E4%BD%BF%E7%94%A8svg-sprite-loader%E5%A4%84%E7%90%86-svg%E5%9B%BE%E6%A0%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 svg-sprite-loader 处理 svg 图标</h2>
<p><a href="https://www.npmjs.com/package/svg-sprite-loader">svg-sprite-loader</a> 是 <code>webpack</code> 中专门用来处理 <code>svg</code> 图标的一个 <code>loader</code> ，在上一节中我们的图标之所有没有展示，就是因为我们缺少该 <code>loader</code>。</p>
<p>那么想要使用该 <code>loader</code> 我们需要做两件事情：</p>
<ol>
<li>
<p>下载该 <code>laoder</code>，执行：<code>npm i --save-dev svg-sprite-loader@6.0.9</code></p>
</li>
<li>
<p>创建 <code>vue.config.js</code> 文件，新增如下配置：</p>
<pre><code class="language-js">const path = require('path')
function resolve(dir) {
  return path.join(__dirname, dir)
}
// https://cli.vuejs.org/zh/guide/webpack.html#简单的配置方式
module.exports = {
  chainWebpack(config) {
    // 设置 svg-sprite-loader
    config.module
      .rule('svg')
      .exclude.add(resolve('src/icons'))  // 排除掉其他loader对svg处理
      .end()
    config.module
      .rule('icons')
      .test(/\.svg$/)
      .include.add(resolve('src/icons'))
      .end()
      .use('svg-sprite-loader')
      .loader('svg-sprite-loader')
      .options({
        symbolId: 'icon-[name]'
      })
      .end()
  }
}


// 补充，如果是直接配置 webpack。https://blog.csdn.net/codfishXY/article/details/119170583
 {
     test: /\.(png|jpe?g|gif|svg|cur)(\?.*)?$/,
     loader: 'file-loader',
     exclude: [resolve('src/icons')], //添加此行
     options: {
       esModule: false,
       name: 'images/[name].[ext]?[hash]'
     }
 },
 {
     test: /\.svg$/,
     loader: 'svg-sprite-loader',
     include: [resolve('src/icons')],
     options: {
       symbolId: 'icon-[name]'
     }
 }
</code></pre>
</li>
</ol>
<p>处理完以上配置之后，重新启动项目，图标即可显示！</p>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>

<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    Vue3.0学习笔记 - 
    
    </title>
    

    
    
    <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">Home</a>
                
                <a target="_self" class="navbar-item " href="archives.html">Archives</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            Vue3.0学习笔记   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2022/10/13</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='Vue.html'>Vue</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <ul>
<li><a href="#vue3%E7%AE%80%E4%BB%8B">Vue3简介</a>
<ul>
<li><a href="#vue3%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88">Vue3带来了什么</a>
<ul>
<li><a href="#%E6%80%A7%E8%83%BD%E7%9A%84%E6%8F%90%E5%8D%87">性能的提升</a></li>
<li><a href="#%E6%BA%90%E7%A0%81%E7%9A%84%E5%8D%87%E7%BA%A7">源码的升级</a></li>
<li><a href="#%E6%8B%A5%E6%8A%B1typescript">拥抱TypeScript</a></li>
<li><a href="#%E6%96%B0%E7%9A%84%E7%89%B9%E6%80%A7">新的特性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BAvue3-0%E5%B7%A5%E7%A8%8B">创建Vue3.0工程</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8vue-cli%E5%88%9B%E5%BB%BA">使用 vue-cli 创建</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8vite%E5%88%9B%E5%BB%BA">使用 vite 创建</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8composition-api">常用 Composition API</a>
<ul>
<li><a href="#%E6%8B%89%E5%BC%80%E5%BA%8F%E5%B9%95%E7%9A%84setup">拉开序幕的setup</a></li>
<li><a href="#ref%E5%87%BD%E6%95%B0">ref函数</a></li>
<li><a href="#reactive%E5%87%BD%E6%95%B0">reactive函数</a></li>
<li><a href="#vue3-0%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86">Vue3.0中的响应式原理</a>
<ul>
<li><a href="#vue2-x%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F">vue2.x的响应式</a></li>
<li><a href="#vue3-0%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F">Vue3.0的响应式</a></li>
</ul>
</li>
<li><a href="#reactive%E5%AF%B9%E6%AF%94ref">reactive对比ref</a></li>
<li><a href="#setup%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9">setup的两个注意点</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%91%E8%A7%86">计算属性与监视</a>
<ul>
<li><a href="#computed%E5%87%BD%E6%95%B0">computed函数</a></li>
<li><a href="#watch%E5%87%BD%E6%95%B0">watch函数</a></li>
<li><a href="#watcheffect%E5%87%BD%E6%95%B0">watchEffect函数</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">生命周期</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89hook%E5%87%BD%E6%95%B0">自定义hook函数</a></li>
<li><a href="#toref">toRef</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E5%AE%83composition-api">其它 Composition API</a>
<ul>
<li><a href="#shallowreactive%E4%B8%8E-shallowref">shallowReactive 与 shallowRef</a></li>
<li><a href="#readonly%E4%B8%8E-shallowreadonly">readonly 与 shallowReadonly</a></li>
<li><a href="#toraw%E4%B8%8E-markraw">toRaw 与 markRaw</a></li>
<li><a href="#customref">customRef</a></li>
<li><a href="#provide%E4%B8%8E-inject">provide 与 inject</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A4%E6%96%AD">响应式数据的判断</a></li>
</ul>
</li>
<li><a href="#composition-api%E7%9A%84%E4%BC%98%E5%8A%BF">Composition API 的优势</a>
<ul>
<li><a href="#options-api%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">Options API 存在的问题</a></li>
<li><a href="#composition-api%E7%9A%84%E4%BC%98%E5%8A%BF">Composition API 的优势</a></li>
</ul>
</li>
<li><a href="#%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6">新的组件</a>
<ul>
<li><a href="#fragment">Fragment</a></li>
<li><a href="#teleport">Teleport</a></li>
<li><a href="#suspense">Suspense</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a>
<ul>
<li><a href="#%E5%85%A8%E5%B1%80api%E7%9A%84%E8%BD%AC%E7%A7%BB">全局API的转移</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%94%B9%E5%8F%98">其他改变</a></li>
</ul>
</li>
</ul>
<h2><a id="vue3%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3简介</h2>
<ul>
<li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li>
<li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a></li>
<li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li>
</ul>
<h2><a id="vue3%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3带来了什么</h2>
<h3><a id="%E6%80%A7%E8%83%BD%E7%9A%84%E6%8F%90%E5%8D%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>性能的提升</h3>
<ul>
<li>
<p>打包大小减少41%</p>
</li>
<li>
<p>初次渲染快55%, 更新渲染快133%</p>
</li>
<li>
<p>内存减少54%</p>
<p>......</p>
</li>
</ul>
<h3><a id="%E6%BA%90%E7%A0%81%E7%9A%84%E5%8D%87%E7%BA%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>源码的升级</h3>
<ul>
<li>
<p>使用Proxy代替defineProperty实现响应式</p>
</li>
<li>
<p>重写虚拟DOM的实现和Tree-Shaking</p>
<p>......</p>
</li>
</ul>
<h3><a id="%E6%8B%A5%E6%8A%B1typescript" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拥抱TypeScript</h3>
<ul>
<li>Vue3可以更好的支持TypeScript</li>
</ul>
<h3><a id="%E6%96%B0%E7%9A%84%E7%89%B9%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>新的特性</h3>
<ol>
<li>
<p>Composition API（组合API）</p>
<ul>
<li>setup配置</li>
<li>ref与reactive</li>
<li>watch与watchEffect</li>
<li>provide与inject</li>
<li>......</li>
</ul>
</li>
<li>
<p>新的内置组件</p>
<ul>
<li>Fragment</li>
<li>Teleport</li>
<li>Suspense</li>
</ul>
</li>
<li>
<p>其他改变</p>
<ul>
<li>新的生命周期钩子</li>
<li>data 选项应始终被声明为一个函数</li>
<li>移除keyCode支持作为 v-on 的修饰符</li>
<li>......</li>
</ul>
</li>
</ol>
<h1><a id="%E5%88%9B%E5%BB%BAvue3-0%E5%B7%A5%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建Vue3.0工程</h1>
<h2><a id="%E4%BD%BF%E7%94%A8vue-cli%E5%88%9B%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 vue-cli 创建</h2>
<p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p>
<pre><code class="language-bash">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上
vue --version
## 安装或者升级你的@vue/cli
npm install -g @vue/cli
## 创建
vue create vue_test
## 启动
cd vue_test
npm run serve
</code></pre>
<h2><a id="%E4%BD%BF%E7%94%A8vite%E5%88%9B%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 vite 创建</h2>
<p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p>
<p>vite官网：<a href="https://vitejs.cn">https://vitejs.cn</a></p>
<ul>
<li>什么是vite？—— 新一代前端构建工具。</li>
<li>优势如下：
<ul>
<li>开发环境中，无需打包操作，可快速的冷启动。</li>
<li>轻量快速的热重载（HMR）。</li>
<li>真正的按需编译，不再等待整个应用编译完成。</li>
</ul>
</li>
<li>传统构建 与 vite构建对比图</li>
</ul>
<p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" /></p>
<pre><code class="language-bash">## 创建工程
npm init vite-app &lt;project-name&gt;
## 进入工程目录
cd &lt;project-name&gt;
## 安装依赖
npm install
## 运行
npm run dev
</code></pre>
<h1><a id="%E5%B8%B8%E7%94%A8composition-api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用 Composition API</h1>
<p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p>
<h2><a id="%E6%8B%89%E5%BC%80%E5%BA%8F%E5%B9%95%E7%9A%84setup" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拉开序幕的setup</h2>
<ol>
<li>
<p>理解：Vue3.0中一个新的配置项，值为一个函数。</p>
</li>
<li>
<p>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</p>
</li>
<li>
<p>组件中所用到的：数据、方法等等，均要配置在setup中。</p>
</li>
<li>
<p>setup函数的两种返回值：</p>
<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li>
</ol>
</li>
<li>
<p>注意点：</p>
<ol>
<li>尽量不要与Vue2.x配置混用
<ul>
<li>Vue2.x配置（data、methos、computed...）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed...）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
</ol>
</li>
<li>
<p>示例代码</p>
<pre><code class="language-js">&lt;script&gt;
// import {h} from 'vue'
export default {
  name: 'App',
  // vue3是向下兼容的，vue文件里还可以使用 data、methods 等
  data() {
    return {
      sex:'男',
      a:100
    }
  },
  methods: {
    sayWelcome(){
      alert('欢迎来到尚硅谷学习')
    },
    test1(){
      console.log(this.sex)
      console.log(this.name)
      console.log(this.age)
      console.log(this.sayHello)
    }
  },

  //setup里的数据和方法template里都能识别到
  setup(){
    //数据
    let name = '张三'
    let age = 18
    let a = 200

    //方法
    function sayHello(){
      alert(`我叫``{name}，我``{age}岁了，你好啊！`)
    }
    function test2(){
      console.log(name)
      console.log(age)
      console.log(sayHello)
      console.log(this.sex)
      console.log(this.sayWelcome)
    }

    //返回一个对象（常用）
    return {
      name,
      age,
      sayHello,
      test2,
      a
    }

    //返回一个函数（渲染函数）
    // return ()=&gt; h('h1','尚硅谷')
  }
}
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h2><a id="ref%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ref函数</h2>
<ul>
<li>
<p>作用: 定义一个响应式的数据</p>
</li>
<li>
<p>语法: <code>const xxx = ref(initValue)</code></p>
<ul>
<li>
<p>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</p>
</li>
<li>
<p>JS中操作数据： <code>xxx.value</code></p>
</li>
<li>
<p>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;{{xxx}}&lt;/div&gt;</code></p>
</li>
<li>
<p>RefImpl 如下：</p>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205300856268.png" alt="image-20220530085646330" style="zoom:75%;" />
</li>
</ul>
</li>
<li>
<p>备注：</p>
<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠\(Object.defineProperty()\)的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。reactive函数中封装了Proxy的处理逻辑。</li>
<li>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205300903127.png" alt="image-20220530090259312" style="zoom:75%;" />
</li>
</ul>
</li>
</ul>
<p>​</p>
<h2><a id="reactive%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>reactive函数</h2>
<ul>
<li>
<p>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</p>
</li>
<li>
<p>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></p>
</li>
<li>
<p>reactive定义的响应式数据是“深层次的”。</p>
</li>
<li>
<p>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</p>
</li>
<li>
<p>不需要像 ref 定义的响应式变量那样 variable.value 的方式取值，直接使用 variable 即可。</p>
<pre><code class="language-js">// 基本数据类型，只能使用 ref
let name = ref('张三')
let age = ref(18)

// 引用类型数据，可以使用 ref 和 reactive，但有区别，前者要通过 .value 取值，引用类型时 ref 内部也是使用reactive
let job = reactive({
   type:'前端工程师',
   salary:'30K'
})
let hobbies = reactive([&quot;篮球&quot;, &quot;乒乓球&quot;])


function changeInfo(){
   // 基本类型 .value 取值
	 name.value = '李四'
   age.value = 48
  
   // 引用类型，不需要value
   job.type = 'UI设计师'
   job.salary = '60K'
   hobbies[0] = &quot;象棋&quot;
} 
</code></pre>
</li>
</ul>
<h2><a id="vue3-0%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3.0中的响应式原理</h2>
<h3><a id="vue2-x%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>vue2.x的响应式</h3>
<ul>
<li>
<p>实现原理：</p>
<ul>
<li>
<p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li>
<p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<pre><code class="language-js">Object.defineProperty(data, 'count', {
    get () {}, 
    set () {}
})

let p = {}
Object.defineProperty(p,'name',{
		configurable:true,
				get(){ //有人读取name时调用
					return person.name
		},
		set(value){ //有人修改name时调用
				console.log('有人修改了name属性，我发现了，我要去更新界面！')
				person.name = value
		}
})
			
Object.defineProperty(p,'age',{
	get(){ //有人读取age时调用
			eturn person.age
	},
	set(value){ //有人修改age时调用
			console.log('有人修改了age属性，我发现了，我要去更新界面！')
			person.age = value
	}
})
</code></pre>
</li>
</ul>
</li>
<li>
<p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h3><a id="vue3-0%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3.0的响应式</h3>
<ul>
<li>
<p>实现原理:</p>
<ul>
<li>
<p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p>
</li>
<li>
<p>通过Reflect（反射）:  对源对象的属性进行操作。</p>
</li>
<li>
<p>MDN文档中描述的Proxy与Reflect：</p>
<ul>
<li>
<p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
</li>
<li>
<p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
<pre><code class="language-js">const p = new Proxy(person,{
		/有人读取p的某个属性时调用
		get(target,propName){
				console.log(`有人读取了p身上的${propName}属性`)
  			// return target[propName]
				return Reflect.get(target,propName)  //Vue3中使用了Reflect处理真正的数据，效果是一样的。
		},
		//有人修改p的某个属性、或给p追加某个属性时调用
		set(target,propName,value){
			console.log(`有人修改了p身上的${propName}属性，我要去更新界面了！`)
      // target[propName] = value;
			Reflect.set(target,propName,value)
		},
		//有人删除p的某个属性时调用
			deleteProperty(target,propName){
			console.log(`有人删除了p身上的${propName}属性，我要去更新界面了！`)
      // return delete target[propName];
			return Reflect.deleteProperty(target,propName)
		}
})

// Proxy 的基本用法
new Proxy(data, {
	// 拦截读取属性值
    get (target, prop) {
    	return Reflect.get(target, prop)
    },
    // 拦截设置属性值或添加新属性
    set (target, prop, value) {
    	return Reflect.set(target, prop, value)
    },
    // 拦截删除属性
    deleteProperty (target, prop) {
    	return Reflect.deleteProperty(target, prop)
    }
})

proxy.name = 'tom'   
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a id="reactive%E5%AF%B9%E6%AF%94ref" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>reactive对比ref</h2>
<ul>
<li>
<p>从定义数据角度对比：</p>
<ul>
<li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li>
<li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li>
<li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li>
</ul>
</li>
<li>
<p>从原理角度对比：</p>
<ul>
<li>ref通过\(Object.defineProperty()\)的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li>
</ul>
</li>
<li>
<p>从使用角度对比：</p>
<ul>
<li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li>
<li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li>
</ul>
</li>
</ul>
<h2><a id="setup%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>setup的两个注意点</h2>
<ul>
<li>
<p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li>
<p>setup的参数</p>
<ul>
<li>
<p>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</p>
</li>
<li>
<p>context：上下文对象</p>
<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
<pre><code class="language-js">// Person.vue 组件
&lt;template&gt;
  &lt;h1&gt;一个人的信息&lt;/h1&gt;
  &lt;h2&gt;姓名：{{person.name}}&lt;/h2&gt;
  &lt;h2&gt;年龄：{{person.age}}&lt;/h2&gt;
  &lt;h3&gt;兴趣爱好: {{person.hobbies}}&lt;/h3&gt;
  &lt;slot name=&quot;hello&quot;&gt;&lt;/slot&gt;
  &lt;button @click=&quot;changeInfo&quot;&gt;修改人的信息&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
import {reactive} from 'vue'

export default {
  name: 'App',
  props:[&quot;school&quot;],
  emits: [&quot;changeInfo&quot;], // 这里不加的话控制台会有警告
  setup(props, context){
    console.log(props)
    console.log(context)
    console.log(context.slots)
    //数据
    let person = reactive({
      name: &quot;张三&quot;,
      age: 18,
      hobbies: [&quot;篮球&quot;, &quot;乒乓球&quot;]
    })

    //方法
    function changeInfo(){
      person.name = &quot;李四&quot;
      person.age = 29
      person.hobbies[0] = &quot;象棋&quot;
      // 触发事件
      context.emit(&quot;changeInfo&quot;, &quot;我修改用户信息了&quot;)
    }

    return {
      person,
      changeInfo
    }
  }
}
&lt;/script&gt;


// App.vue
&lt;template&gt;
  &lt;!-- 绑定自定义事件、slot内容、传递 props --&gt;
  &lt;Person school=&quot;清华&quot; @changeInfo=&quot;handleChange&quot;&gt;
    &lt;template v-slot:hello&gt;
      &lt;span&gt;尚硅谷&lt;/span&gt;
    &lt;/template&gt;
  &lt;/Person&gt;
&lt;/template&gt;

&lt;script&gt;
import Person from &quot;./components/Person&quot;
export default {
  name: 'App',
  components:{
    Person
  },
  setup(){
    function handleChange(msg){
      console.log(msg)
    }

    return {
      handleChange
    }
  }
}
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2><a id="%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%91%E8%A7%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算属性与监视</h2>
<h3><a id="computed%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>computed函数</h3>
<ul>
<li>
<p>与Vue2.x中computed配置功能一致</p>
</li>
<li>
<p>写法</p>
<pre><code class="language-js">import {computed} from 'vue'

setup(){
    ...
	//计算属性——简写
    let fullName = computed(()=&gt;{
        return person.firstName + '-' + person.lastName
    })
    //计算属性——完整
    let fullName = computed({
        get(){
            return person.firstName + '-' + person.lastName
        },
        set(value){
            const nameArr = value.split('-')
            person.firstName = nameArr[0]
            person.lastName = nameArr[1]
        }
    })
}
</code></pre>
</li>
</ul>
<h3><a id="watch%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>watch函数</h3>
<ul>
<li>
<p>与Vue2.x中watch配置功能一致</p>
</li>
<li>
<p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个引用类型属性时：deep配置有效。</li>
</ul>
<pre><code class="language-js">//情况一：监视ref定义的响应式数据
watch(sum,(newValue,oldValue)=&gt;{
	console.log('sum变化了',newValue,oldValue)
},{immediate:true})  // 第三个参数是可选的

//情况二：监视多个ref定义的响应式数据
watch([sum,msg],(newValue,oldValue)=&gt;{
  // newValue 和 oldValue 变成数组，顺序与[sum,msg]保持一致
	console.log('sum或msg变化了',newValue,oldValue)  
}) 

/* 情况三：监视reactive定义的响应式数据
			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！
			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 
*/
watch(person,(newValue,oldValue)=&gt;{
	console.log('person变化了',newValue,oldValue)
},{immediate:true,deep:false}) //此处的deep配置不再奏效

//情况四：监视reactive定义的响应式数据中的某个属性
watch(()=&gt;person.job,(newValue,oldValue)=&gt;{
	console.log('person的job变化了',newValue,oldValue)
},{immediate:true,deep:true}) 

//情况五：监视reactive定义的响应式数据中的某些属性
watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;{
	console.log('person的job变化了',newValue,oldValue)
},{immediate:true,deep:true})

//特殊情况
watch(()=&gt;person.job,(newValue,oldValue)=&gt;{
    console.log('person的job变化了',newValue,oldValue)
},{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效
</code></pre>
</li>
<li>
<p>watch监视ref数据</p>
</li>
</ul>
<pre><code class="language-js">&lt;script&gt;
	import {ref,reactive,watch} from 'vue'
	export default {
		name: 'Demo',
		setup(){
			//数据
			let sum = ref(0);       // 这里是用ref定义基本类型数据，sum是一个RefImpl对象，sum.value是一个常量值.
			let msg = ref('你好啊');
			let person = ref({      // 这里是用ref定义引用类型数据，person也是RefImpl对象，但person.value是Proxy对象.
				name:'张三',
				age:18,
				job:{
					j1:{
						salary:20
					}
				}
			})

			console.log(person)

      // 这里不能用sum.value，因为sum是基本数据类型，sum.value 是一个常量值，不能被监视.
			watch(sum,(newValue,oldValue)=&gt;{
				console.log('sum的值变化了',newValue,oldValue)
			})

      // 如果不开启 deep:true，则这里必须监视 person.value 才能监测到name、age等数据的变化，
      // person是一个引用类型数据，person.value 是Proxy对象，是ref函数内部调用reactive函数生成的。
      watch(person.value,(newValue,oldValue)=&gt;{
        console.log('person的值变化了',newValue,oldValue)
      })

      // 如果开启了 deep:true，则这里可以直接监视person
			watch(person,(newValue,oldValue)=&gt;{
				console.log('person的值变化了',newValue,oldValue)
			},{deep:true})


			//返回一个对象（常用）
			return {
				sum,
				msg,
				person
			}
		}
	}
&lt;/script&gt;
</code></pre>
<h3><a id="watcheffect%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>watchEffect函数</h3>
<ul>
<li>
<p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li>
<p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中<strong>用到哪个属性，那就监视哪个属性</strong>。</p>
</li>
<li>
<p>watchEffect有点像computed：</p>
<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
<pre><code class="language-js">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。
watchEffect(()=&gt;{
    const x1 = sum.value
    const x2 = person.age
    const x3 = person.job.salary
    console.log('watchEffect配置的回调执行了')
})
</code></pre>
</li>
</ul>
<h2><a id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生命周期</h2>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206010950892.png" alt="image-20220601095010005" /></p>
<ul>
<li>
<p>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：</p>
<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>
<p>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：</p>
<ul>
<li><code>beforeCreate</code>===&gt;<code>setup()</code></li>
<li><code>created</code>=======&gt;<code>setup()</code></li>
<li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>=======&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> =======&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li>
</ul>
</li>
<li>
<p>组合式API生命周期验证</p>
<pre><code class="language-js">// Student.vue
&lt;template&gt;
  &lt;h1&gt;学生信息&lt;/h1&gt;
  &lt;h2&gt;姓名：{{ student.name }}&lt;/h2&gt;
  &lt;h2&gt;年龄：{{ student.age }}&lt;/h2&gt;
  &lt;h3&gt;兴趣爱好: {{ student.hobbies }}&lt;/h3&gt;
  &lt;button @click=&quot;changeInfo&quot;&gt;修改人的信息&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
import {reactive, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted} from 'vue'

export default {
  name: 'Student',
  setup(props, context) {
    let student = reactive({
      name: &quot;张三&quot;,
      age: 18,
      hobbies: [&quot;篮球&quot;, &quot;乒乓球&quot;],
    });

    const changeInfo = ()=&gt;{
      student.name = &quot;李四&quot;
      student.age = 22
      student.hobbies[0] = &quot;象棋&quot;
    }

    const destroy = () =&gt; {
      console.log(context)
    }

    //通过组合式API的形式去使用生命周期钩子
    onBeforeMount(() =&gt; {
      console.log('---onBeforeMount---')
    })
    onMounted(() =&gt; {
      console.log('---onMounted---')
    })
    onBeforeUpdate(() =&gt; {
      console.log('---onBeforeUpdate---')
    })
    onUpdated(() =&gt; {
      console.log('---onUpdated---')
    })
    onBeforeUnmount(() =&gt; {
      console.log('---onBeforeUnmount---')
    })
    onUnmounted(() =&gt; {
      console.log('---onUnmounted---')
    })

    return {
      student,
      changeInfo
    }
  }
}
&lt;/script&gt;


// App.vue 中通过 v-if 创建和销毁Student组件，从而让Student组件可以响应onBeforeUnmount和unmount生命周期函数。
&lt;template&gt;
  &lt;Student v-if=&quot;show&quot;/&gt;
  &lt;hr/&gt;
  &lt;button @click=&quot;toggle&quot;&gt;显示/隐藏&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
import {ref} from 'vue'
import Student from &quot;./components/Student&quot;

export default {
  name: 'App',
  components: {
    Person, Student
  },
  setup() {
    const show = ref(true);

    function toggle() {
      show.value = !show.value;
    }

    return {
      show,
      toggle
    }
  }
}
&lt;/script&gt;
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205310920909.png" alt="image-20220531092036051" /></p>
</li>
</ul>
<h2><a id="%E8%87%AA%E5%AE%9A%E4%B9%89hook%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义hook函数</h2>
<ul>
<li>
<p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>
</li>
<li>
<p>类似于vue2.x中的mixin。</p>
</li>
<li>
<p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
</li>
<li>
<p>获取鼠标点击位置坐标的案例</p>
<pre><code class="language-js">// 自定义 usePoint hook 函数
import {onBeforeUnmount, onMounted, reactive} from &quot;vue&quot;;

export default function () {
    // 鼠标“打点”相关的数据
    const point = reactive({
        x: 0,
        y: 0
    })

    // 鼠标“打点”相关的方法
    function savePoint(event) {
        point.x = event.pageX
        point.y = event.pageY
        console.log(`x坐标: ``{point.x}, y坐标: ``{point.y}`)
    }

    // 鼠标“打点”相关的生命周期钩子
    onMounted(() =&gt; {
        window.addEventListener(&quot;click&quot;, savePoint)
    })

    onBeforeUnmount(() =&gt; {
        window.removeEventListener(&quot;click&quot;, savePoint)
    })

    // 必须要把hooks里定义的响应式变量return出去，外部才可以使用.
    return point
}

//--------------------------------------------------------------------------------
// Test1组件 使用到了 usePoint
&lt;template&gt;
  &lt;h3&gt;Test1组件&lt;/h3&gt;
  &lt;h3&gt;x坐标：{{ point.x }}，y坐标：{{ point.y }}&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
import usePoint from &quot;../hooks/usePoint&quot;;

export default {
  name: 'Test1',
  setup() {
    const point = usePoint();

    return {
      point
    }
  }
}
&lt;/script&gt;

//--------------------------------------------------------------------------------
// Test2组件 使用到了 usePoint
&lt;template&gt;
  &lt;h3&gt;Test2组件&lt;/h3&gt;
  &lt;h3&gt;x坐标：{{ point.x }}，y坐标：{{ point.y }}&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
import usePoint from &quot;../hooks/usePoint&quot;;

export default {
  name: 'Test2',
  setup() {
    const point = usePoint();

    return {
      point
    }
  }
}
&lt;/script&gt;

//--------------------------------------------------------------------------------
// App.vue 引用Test1和Test2组件
&lt;template&gt;
  &lt;Test1/&gt;
  &lt;hr/&gt;
  &lt;Test2/&gt;
&lt;/template&gt;

&lt;script&gt;
import Test1 from &quot;./components/Test1&quot;
import Test2 from &quot;./components/Test2&quot;

export default {
  name: 'App',
  components: {
    Test1, Test2
  }
}
&lt;/script&gt;
</code></pre>
<p>当点击屏幕任意位置时，Test1组件和Test2组件都输出对应坐标，所以控制台每次点击后都输出2遍。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205311152504.gif" alt="2022-05-31 11.52.08" /></p>
</li>
</ul>
<h2><a id="toref" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>toRef</h2>
<ul>
<li>
<p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p>
</li>
<li>
<p>语法：<code>const name = toRef(person,'name')</code></p>
</li>
<li>
<p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p>
</li>
<li>
<p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p>
</li>
<li>
<p>对比使用 toRef / toRefs 与不使用的区别。</p>
<pre><code class="language-js">// 不使用toRef(s)时，模板中需要使用 person.xxx
&lt;template&gt;
  &lt;h1&gt;一个人的信息&lt;/h1&gt;
  &lt;h2&gt;姓名：{{ person.name }}&lt;/h2&gt;
  &lt;h2&gt;年龄：{{ person.age }}&lt;/h2&gt;
  &lt;h3&gt;薪水: {{ person.job.j1.salary }}&lt;/h3&gt;
  &lt;button @click=&quot;person.name=person.name+'*'&quot;&gt;修改姓名&lt;/button&gt;
  &lt;button @click=&quot;person.age++&quot;&gt;修改年龄&lt;/button&gt;
  &lt;button @click=&quot;person.job.j1.salary++&quot;&gt;修改薪水&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
import {reactive} from 'vue'

export default {
  name: 'Person',
  setup() {
    //数据
    let person = reactive({
      name: &quot;张三&quot;,
      age: 18,
      job: {
        j1: {
          salary: 20
        }
      }
    })

    return {
      person,
    }
  }
}
&lt;/script&gt;

//----------------------------------------------------------------------------------------------
// 使用toRef(s)时，模板中可以省略 person.
&lt;template&gt;
  &lt;h1&gt;一个人的信息&lt;/h1&gt;
  &lt;h2&gt;姓名：{{ name }}&lt;/h2&gt;
  &lt;h2&gt;年龄：{{ age }}&lt;/h2&gt;
  &lt;h3&gt;薪水: {{ job.j1.salary }}&lt;/h3&gt;
  &lt;button @click=&quot;name=name+'*'&quot;&gt;修改姓名&lt;/button&gt;
  &lt;button @click=&quot;age++&quot;&gt;修改年龄&lt;/button&gt;
  &lt;button @click=&quot;job.j1.salary++&quot;&gt;修改薪水&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
import {reactive, toRef, toRefs} from 'vue'

export default {
  name: 'Person',
  setup() {
    //数据
    let person = reactive({
      name: &quot;张三&quot;,
      age: 18,
      job: {
        j1: {
          salary: 20
        }
      }
    })

    // toRef 只能处理单个属性
    console.log(toRef(person, &quot;name&quot;));
    // toRefs 可以批量处理对象上的所有属性
    console.log(toRefs(person));

    return {
      person,
      ...toRefs(person)    // toRefs得到的是一个key与person相同、value均为响应式对象的键值对，故这里通过...展开。
    }
  }
}
&lt;/script&gt;
</code></pre>
<p>下面是 toRef 和 toRefs 输出结果，其中 ObjectRefImpl 就是响应式对象。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205312243758.png" alt="image-20220531224350506" /></p>
</li>
</ul>
<p>​		<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205312247199.gif" alt="2022-05-31 22.45.40" style="zoom:50%;" /></p>
<h1><a id="%E5%85%B6%E5%AE%83composition-api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其它 Composition API</h1>
<h2><a id="shallowreactive%E4%B8%8E-shallowref" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>shallowReactive 与 shallowRef</h2>
<ul>
<li>
<p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>
</li>
<li>
<p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li>
<p>什么时候使用?</p>
<ul>
<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li>
<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h2><a id="readonly%E4%B8%8E-shallowreadonly" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>readonly 与 shallowReadonly</h2>
<ul>
<li>
<p>readonly: 让一个响应式数据变为只读的（深只读）。</p>
</li>
<li>
<p>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</p>
</li>
<li>
<p>应用场景: 不希望数据被修改时。</p>
</li>
<li>
<p>示例代码</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;h4&gt;当前求和为：{{sum}}&lt;/h4&gt;
  &lt;button @click=&quot;sum++&quot;&gt;点我++&lt;/button&gt;
  &lt;hr&gt;
  &lt;h2&gt;姓名：{{name}}&lt;/h2&gt;
  &lt;h2&gt;年龄：{{age}}&lt;/h2&gt;
  &lt;h2&gt;薪资：{{job.j1.salary}}K&lt;/h2&gt;
  &lt;button @click=&quot;name+='~'&quot;&gt;修改姓名&lt;/button&gt;
  &lt;button @click=&quot;age++&quot;&gt;增长年龄&lt;/button&gt;
  &lt;button @click=&quot;job.j1.salary++&quot;&gt;涨薪&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
import {ref,reactive,toRefs,readonly,shallowReadonly} from 'vue'
export default {
  name: 'Person',
  setup(){
    let sum = ref(0)
    let person = reactive({
      name:'张三',
      age:18,
      job:{
        j1:{
          salary:20
        }
      }
    })

    // 对引用类型数据的响应式数据，readonly是深只读，shallowReadonly是浅只读.
    // person = readonly(person)
    person = shallowReadonly(person)
    
    // 对基本类型数据的响应式数据，readonly和shallowReadonly效果一样.
    // sum = readonly(sum)
    sum = shallowReadonly(sum)

    //返回一个对象（常用）
    return {
      sum,
      ...toRefs(person)
    }
  }
}
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h2><a id="toraw%E4%B8%8E-markraw" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>toRaw 与 markRaw</h2>
<ul>
<li>
<p>toRaw：</p>
<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>(只能作用于reactive生成的响应式对象，ref生成的不可以)。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>
<p>markRaw：</p>
<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>
<li>应用场景:
<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>示例代码</p>
<pre><code class="language-js">&lt;template&gt;
	&lt;h4&gt;当前求和为：{{sum}}&lt;/h4&gt;
	&lt;button @click=&quot;sum++&quot;&gt;点我++&lt;/button&gt;
	&lt;hr&gt;
	&lt;h2&gt;姓名：{{name}}&lt;/h2&gt;
	&lt;h2&gt;年龄：{{age}}&lt;/h2&gt;
	&lt;h2&gt;薪资：{{job.j1.salary}}K&lt;/h2&gt;
	&lt;h3 v-show=&quot;person.car&quot;&gt;座驾信息：{{person.car}}&lt;/h3&gt;
	&lt;button @click=&quot;name+='~'&quot;&gt;修改姓名&lt;/button&gt;
	&lt;button @click=&quot;age++&quot;&gt;增长年龄&lt;/button&gt;
	&lt;button @click=&quot;job.j1.salary++&quot;&gt;涨薪&lt;/button&gt;
	&lt;button @click=&quot;showRawPerson&quot;&gt;输出最原始的person&lt;/button&gt;
	&lt;button @click=&quot;addCar&quot;&gt;给人添加一台车&lt;/button&gt;
	&lt;button @click=&quot;person.car.name+='!'&quot;&gt;换车名&lt;/button&gt;
	&lt;button @click=&quot;changePrice&quot;&gt;换价格&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
	import {ref,reactive,toRefs,toRaw,markRaw} from 'vue'
	export default {
		name: 'Demo',
		setup(){
			//数据
			let sum = ref(0)
			let person = reactive({
				name:'张三',
				age:18,
				job:{
					j1:{
						salary:20
					}
				}
			})

			function showRawPerson(){
				const p = toRaw(person)
				console.log(p)
        p.age++  // 这里修改p.age并不会引起页面更新,因为p不是响应式的
			}

			function addCar(){
				let car = {name:'奔驰',price:40}
        // 使用markRaw后，car不再是响应式，如果 person.car = car，则car会变成响应式对象，并且是深度的。
				person.car = markRaw(car)
			}

			function changePrice(){
				person.car.price++  // person.car.price确实变了，但是页面不会更新，因为person.car不是响应式
				console.log(person.car.price) 
			}

			//返回一个对象（常用）
			return {
				sum,
				person,
				...toRefs(person),
				showRawPerson,
				addCar,
				changePrice
			}
		}
	}
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h2><a id="customref" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>customRef</h2>
<ul>
<li>
<p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
<pre><code class="language-js">//自定义一个myRef基本套路
function myRef(value){
	return customRef((track,trigger)=&gt;{
		return {
			get(){
				track();  //告诉Vue这个value值是需要被“追踪”的
				return value;
			},
			set(newValue){
				value = newValue;
				trigger(); //告诉Vue去更新界面
			}
		}
	})
}			
</code></pre>
</li>
<li>
<p>实现防抖效果：</p>
<pre><code class="language-js">&lt;template&gt;
	&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;
	&lt;h3&gt;{{keyword}}&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
	import {ref,customRef} from 'vue'
	export default {
		name:'Demo',
		setup(){
			// let keyword = ref('hello') //使用Vue准备好的内置ref
			//自定义一个myRef
			function myRef(value,delay){
				let timer
				//通过customRef去实现自定义
				return customRef((track,trigger)=&gt;{
					return{
						get(){
							track() //告诉Vue这个value值是需要被“追踪”的
							return value
						},
						set(newValue){
							clearTimeout(timer)
							timer = setTimeout(()=&gt;{
								value = newValue
								trigger() //告诉Vue去更新界面
							},delay)
						}
					}
				})
			}
			let keyword = myRef('hello',500) //使用程序员自定义的ref
			return {
				keyword
			}
		}
	}
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h2><a id="provide%E4%B8%8E-inject" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>provide 与 inject</h2>
<img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" />
<ul>
<li>
<p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p>
</li>
<li>
<p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li>
<p>具体写法：</p>
<ol>
<li>
<p>祖组件中：</p>
<pre><code class="language-js">setup(){
	......
    let car = reactive({name:'奔驰',price:'40万'})
    provide('car',car)
    ......
}
</code></pre>
</li>
<li>
<p>后代组件中：</p>
<pre><code class="language-js">setup(props,context){
	......
    const car = inject('car')
    return {car}
	......
}
</code></pre>
</li>
</ol>
</li>
<li>
<p>示例代码（类似于React中的Context传递数据的写法）</p>
<pre><code class="language-js">// App.vue 数据提供者
&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;button @click=&quot;change&quot;&gt;修改&lt;/button&gt;
    &lt;h3&gt;我是App组件（祖），{{ name }}--{{ price }}W&lt;/h3&gt;
    &lt;Child/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import {reactive, toRefs, provide} from 'vue'
import Child from './components/Child.vue'

export default {
  name: 'App',
  components: {Child},
  setup() {
    let car = reactive({name: '奔驰', price: 40})
    provide('car', car) //给自己的后代组件传递数据

    function change() {
      car.name += &quot;*&quot;
      car.price++
    }

    return {...toRefs(car), change}
  }
}
&lt;/script&gt;

&lt;style&gt;
.app {
  background-color: gray;
  padding: 10px;
}
&lt;/style&gt;

//----------------------------------------------------------------------------------------
// Child.vue 中间节点，本例并不需要使用数据，但是可以拿到provide的数据
&lt;template&gt;
  &lt;div class=&quot;child&quot;&gt;
    &lt;h3&gt;我是Child组件（子）&lt;/h3&gt;
    &lt;Son/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import {inject} from 'vue'
import Son from './Son.vue'

export default {
  name: 'Child',
  components: {Son},
  setup() {
    // 所有后代组件中都可以拿到App中provide的数据，并且它还是响应式的
    let car = inject('car')
    console.log(car, 'Child-----')
  }
}
&lt;/script&gt;

&lt;style&gt;
.child {
  background-color: skyblue;
  padding: 10px;
}
&lt;/style&gt;

//----------------------------------------------------------------------------------------
// Son.vue 使用provide的数据
&lt;template&gt;
  &lt;div class=&quot;son&quot;&gt;
    &lt;h3&gt;我是Son组件（孙），{{ car.name }}--{{ car.price }}&lt;/h3&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import {inject} from 'vue'

export default {
  name: 'Son',
  setup() {
    // 所有后代组件中都可以拿到App中provide的数据，并且它还是响应式的
    let car = inject('car')
    return {car}
  }
}
&lt;/script&gt;

&lt;style&gt;
.son {
  background-color: orange;
  padding: 10px;
}
&lt;/style&gt;
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206010614579.gif" alt="2022-06-01 06.10.21" /></p>
</li>
</ul>
<h2><a id="%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A4%E6%96%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>响应式数据的判断</h2>
<ul>
<li>
<p>isRef: 检查一个值是否为一个 ref 对象</p>
</li>
<li>
<p>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</p>
</li>
<li>
<p>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</p>
</li>
<li>
<p>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</p>
</li>
<li>
<p>示例代码</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;h3&gt;我是App组件&lt;/h3&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import {ref, reactive, readonly, isRef, isReactive, isReadonly, isProxy} from 'vue'

export default {
  name: 'App',
  setup() {
    let sum = ref(0);
    let car = reactive({name: '奔驰', price: 40})
    let car2 = readonly(car);

    console.log(&quot;-------------------判断 sum-----------------------&quot;)
    console.log(isRef(sum))
    console.log(isReactive(sum))
    console.log(isReadonly(sum))
    console.log(isProxy(sum))

    console.log(&quot;-------------------判断 car-----------------------&quot;)
    console.log(isRef(car))
    console.log(isReactive(car))
    console.log(isReadonly(car))
    console.log(isProxy(car))

    console.log(&quot;-------------------判断 car2-----------------------&quot;)
    console.log(isRef(car2))
    console.log(isReactive(car2))
    console.log(isReadonly(car2))
    console.log(isProxy(car2))

    return {}
  }
}
&lt;/script&gt;
</code></pre>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206010751704.png" alt="image-20220601075108328" style="zoom:50%;" />
</li>
</ul>
<h1><a id="composition-api%E7%9A%84%E4%BC%98%E5%8A%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Composition API 的优势</h1>
<h2><a id="options-api%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Options API 存在的问题</h2>
<p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p>
<div style="width:600px;height:370px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" />
</div>
<div style="width:300px;height:370px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> 
</div>
<h2><a id="composition-api%E7%9A%84%E4%BC%98%E5%8A%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Composition API 的优势</h2>
<p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p>
<div style="width:500px;height:340px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>
<div style="width:430px;height:340px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202205310936693.png" alt="image-20220531093600235" style="zoom:50%;" />
<h1><a id="%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>新的组件</h1>
<h2><a id="fragment" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fragment</h2>
<ul>
<li>
<p>在Vue2中: 组件必须有一个根标签</p>
</li>
<li>
<p>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</p>
</li>
<li>
<p>好处: 减少标签层级, 减小内存占用</p>
</li>
</ul>
<h2><a id="teleport" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Teleport</h2>
<ul>
<li>
<p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p>
<pre><code class="language-js">&lt;!-- 移动的位置：html, body, #hello等等，teleport能够将它包裹的html片段移动到指定的位置 --&gt;
&lt;teleport to=&quot;移动位置&quot;&gt;
	&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;
		&lt;div class=&quot;dialog&quot;&gt;
			&lt;h3&gt;我是一个弹窗&lt;/h3&gt;
			&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/teleport&gt;
</code></pre>
</li>
<li>
<p>自定义弹框示例</p>
<pre><code class="language-js">&lt;template&gt;
	&lt;div&gt;
		&lt;button @click=&quot;isShow = true&quot;&gt;点我弹个窗&lt;/button&gt;
    &lt;!-- 使用 teleport 将弹框内容移动到body中，以免影响其它组件的布局 --&gt;
		&lt;teleport to=&quot;body&quot;&gt;
			&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;
				&lt;div class=&quot;dialog&quot;&gt;
					&lt;h3&gt;我是一个弹窗&lt;/h3&gt;
					&lt;h4&gt;一些内容&lt;/h4&gt;
					&lt;h4&gt;一些内容&lt;/h4&gt;
					&lt;h4&gt;一些内容&lt;/h4&gt;
					&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;
				&lt;/div&gt;
			&lt;/div&gt;
		&lt;/teleport&gt;
	&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
	import {ref} from 'vue'
	export default {
		name:'Dialog',
		setup(){
			let isShow = ref(false)
			return {isShow}
		}
	}
&lt;/script&gt;

&lt;style&gt;
	.mask{
		position: absolute;
		top: 0;bottom: 0;left: 0;right: 0;
		background-color: rgba(0, 0, 0, 0.5);
	}
	.dialog{
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%,-50%);
		text-align: center;
		width: 300px;
		height: 300px;
		background-color: green;
	}
&lt;/style&gt;
</code></pre>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206010829044.png" alt="image-20220601082906439" style="zoom:75%;" />
</li>
</ul>
<h2><a id="suspense" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Suspense</h2>
<ul>
<li>
<p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li>
<p>使用步骤：</p>
<ul>
<li>
<p>异步引入组件</p>
<pre><code class="language-js">import {defineAsyncComponent} from 'vue'
const Child = defineAsyncComponent(()=&gt;import('./components/Child.vue'))
</code></pre>
</li>
<li>
<p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>
<pre><code class="language-js">&lt;template&gt;
	&lt;div class=&quot;app&quot;&gt;
		&lt;h3&gt;我是App组件&lt;/h3&gt;
		&lt;Suspense&gt;
			&lt;template v-slot:default&gt;
				&lt;Child/&gt;
			&lt;/template&gt;
			&lt;template v-slot:fallback&gt;
				&lt;h3&gt;加载中.....&lt;/h3&gt;
			&lt;/template&gt;
		&lt;/Suspense&gt;
	&lt;/div&gt;
&lt;/template&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p>示例代码</p>
</li>
</ul>
<pre><code class="language-js">// App.vue 使用了异步组件，以便模拟延时加载效果
&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;h3&gt;我是App组件&lt;/h3&gt;
    &lt;!-- 使用Suspense需要准备2个内容，分别对应 default、fallback 这2个插槽 --&gt;
    &lt;Suspense&gt;
      &lt;template v-slot:default&gt;
        &lt;Child/&gt;
      &lt;/template&gt;
      &lt;template v-slot:fallback&gt;
        &lt;h3&gt;稍等，加载中...&lt;/h3&gt;
      &lt;/template&gt;
    &lt;/Suspense&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// import Child from './components/Child'//静态引入组件
import {defineAsyncComponent} from 'vue'

const Child = defineAsyncComponent(() =&gt; import('./components/Child')) //异步引入组件
export default {
  name: 'App',
  components: {Child},
}
&lt;/script&gt;

&lt;style&gt;
.app {
  background-color: gray;
  padding: 10px;
}
&lt;/style&gt;

//--------------------------------------------------------------------------------------
&lt;template&gt;
  &lt;div className=&quot;child&quot;&gt;
    &lt;h3&gt;我是Child组件&lt;/h3&gt;
    {{ sum }}
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import {ref} from 'vue'

export default {
  name: 'Child',
  // 正常来讲，setup是不允许异步的，但是如果它的使用者（App.vue）是使用异步引入的方式的话，那么就可以用async修饰
  async setup() {
    let sum = ref(0)
    let p = new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        resolve({sum})
      }, 3000)
    })
    return await p
  }
}
&lt;/script&gt;

&lt;style&gt;
.child {
  background-color: skyblue;
  padding: 10px;
}
&lt;/style&gt;
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206010906029.gif" alt="2022-06-01 08.52.25" /></p>
<h1><a id="%E5%85%B6%E4%BB%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他</h1>
<h2><a id="%E5%85%A8%E5%B1%80api%E7%9A%84%E8%BD%AC%E7%A7%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全局API的转移</h2>
<ul>
<li>
<p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li>
<p>例如：注册全局组件、注册全局指令等。</p>
<pre><code class="language-js">//注册全局组件
Vue.component('MyButton', {
  data: () =&gt; ({
    count: 0
  }),
  template: '&lt;button @click=&quot;count++&quot;&gt;Clicked {{ count }} times.&lt;/button&gt;'
})

//注册全局指令
Vue.directive('focus', {
  inserted: el =&gt; el.focus()
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li>
<p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong style="color:#DD5145">移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h2><a id="%E5%85%B6%E4%BB%96%E6%94%B9%E5%8F%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他改变</h2>
<ul>
<li>
<p>data选项应始终被声明为一个函数。</p>
</li>
<li>
<p>过度类名的更改：</p>
<ul>
<li>
<p>Vue2.x写法</p>
<pre><code class="language-css">.v-enter,
.v-leave-to {
  opacity: 0;
}
.v-leave,
.v-enter-to {
  opacity: 1;
}
</code></pre>
</li>
<li>
<p>Vue3.x写法</p>
<pre><code class="language-css">.v-enter-from,
.v-leave-to {
  opacity: 0;
}

.v-leave-from,
.v-enter-to {
  opacity: 1;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li>
<p>父组件中绑定事件</p>
<pre><code class="language-js">&lt;my-component
  v-on:close=&quot;handleComponentEvent&quot;
  v-on:click=&quot;handleNativeClickEvent&quot;
/&gt;
</code></pre>
</li>
<li>
<p>子组件中声明自定义事件</p>
<p>子组件的 emits 选型中配置了的事件，表示是自定义事件，没有配置的如本例的 v-on:click=&quot;handleNativeClickEvent&quot; 中的click事件，由于没有配置在 emits 中配置，故Vue会认为它是原生的事件。</p>
<pre><code class="language-js">&lt;script&gt;
  export default {
    emits: ['close']
  }
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li>
<p>......</p>
</li>
</ul>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>

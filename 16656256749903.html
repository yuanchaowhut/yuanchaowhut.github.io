<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    城市应用管理Vue框架核心工作原理 - 
    
    </title>
    

    
    
    <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">Home</a>
                
                <a target="_self" class="navbar-item " href="archives.html">Archives</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            城市应用管理Vue框架核心工作原理   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2022/10/13</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='%E6%95%B0%E5%AD%97%E6%94%BF%E9%80%9A.html'>数字政通</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <ul>
<li><a href="#%E5%BC%95%E8%A8%80">引言</a></li>
<li><a href="#%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D">整体介绍</a>
<ul>
<li><a href="#%E5%AE%9A%E5%88%B6%E5%8A%9F%E8%83%BD">定制功能</a></li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84">项目结构</a></li>
<li><a href="#%E5%8D%95%E5%BA%94%E7%94%A8%E7%BB%93%E6%9E%84">单应用结构</a></li>
<li><a href="#%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8">安装使用</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">常用命令</a></li>
<li><a href="#%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE">代理配置</a></li>
<li><a href="#%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA">效果展示</a></li>
</ul>
</li>
<li><a href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">工作原理</a>
<ul>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E6%96%87%E4%BB%B6">路由文件</a></li>
<li><a href="#%E7%99%BB%E5%BD%95%E9%80%BB%E8%BE%91">登录逻辑</a>
<ul>
<li><a href="#%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B">登录流程</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81">核心代码</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8">数据存储</a></li>
</ul>
</li>
<li><a href="#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC">路由跳转</a></li>
<li><a href="#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6">权限控制</a></li>
<li><a href="#%E8%A7%86%E5%9B%BE%E9%AA%A8%E6%9E%B6">视图骨架</a>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84">代码结构</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE">路由配置</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82">网络请求</a>
<ul>
<li><a href="#service%E5%85%B3%E7%B3%BB%E5%9B%BE">service关系图</a></li>
<li><a href="#axiosservice-base-ts">axios/service-base.ts</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B">使用举例</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85">多应用打包</a>
<ul>
<li><a href="#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4">执行命令</a></li>
<li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE">工作流程图</a></li>
<li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AF%A6%E7%BB%86">工作流程详细</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<h1><a id="%E5%BC%95%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>引言</h1>
<p>城市应用管理部门的Vue框架源自中台提供的<a href="http://192.168.101.70:8000/framework/frontend/egova-admin-template-web.git">初始框架</a>，我在此基础上进行了相当多的定制开发。考虑到今后精细化项目都要使用本框架，所以有必要将一些核心的工作原理进行一次梳理，方便后面使用的同学们快速上手。</p>
<h1><a id="%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>整体介绍</h1>
<p>首先整体介绍一下本框架的基本情况，包括：有哪些定制功能，项目结构是什么样子，如何安装使用，如何新增一个项目，调试打包，页面展示效果等等。</p>
<h2><a id="%E5%AE%9A%E5%88%B6%E5%8A%9F%E8%83%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定制功能</h2>
<p>首先列举一下本框架已完成定制开发的功能，让大家有一个大致的了解，主要包括：</p>
<ol>
<li>
<p>支持调用 mis 的接口登录</p>
<p>新增 mislogin 模块，封装 AesTool 加密工具类等</p>
</li>
<li>
<p>支持 mis 岗位权限控制，调用 mis 接口获取导航</p>
<p>按照统一用户中心导航数据结构重新组装数据，最小限度修改权限管理代码</p>
</li>
<li>
<p>支持独立首页配置</p>
<p>新增 home 模块，并新增 hasHomePage 配置项</p>
</li>
<li>
<p>支持头部导航条主模块快捷切换</p>
<p>完善 header 组件，仿老渣土系统增加九宫格快速入口</p>
</li>
<li>
<p>支持头部标题动态显示模块标题</p>
<p>原框架始终显示的是系统标题</p>
</li>
<li>
<p>支持第三方嵌入，绕过登录页面直接登录（url 需携带 token 参数）</p>
<p>Knockout 、React 等项目可以 iframe 的形式嵌入本框架开发的页面，系统自动识别 token 并帮助完成登录、获取导航、获取微服务配置等一系列步骤。</p>
</li>
<li>
<p>支持多应用打包</p>
<p>修改原打包脚本、page.config.js、index.json 等文件，支持多个项目可以使用同一套框架。</p>
</li>
<li>
<p>支持项目单独配置</p>
<p>原框架有2个配置文件，我在此基础上又新增加了1个，用于项目独有配置，与其它项目进行区分。</p>
</li>
<li>
<p>支持使用玲珑能力</p>
<p>按照中台提供的技术文档，搭建使用玲珑的环境</p>
</li>
<li>
<p>支持动态拼接 ajax 请求的 baseUrl</p>
<p>框架涉及 mis 服务、项目微服务、玲珑微服务等多套服务，但我们编写 service 时可以无感，拦截器中通过调用 ServiceUtil 工具类中封装相关方法已经帮助动态拼接。</p>
</li>
<li>
<p>支持全局事件总线实现任意组件间通信</p>
<p>具体实现参考：<a href="https://alidocs.dingtalk.com/i/team/9JOGOLjlap1oz4QL/docs/9JOGOZ0e32gJ3m4Q">https://alidocs.dingtalk.com/i/team/9JOGOLjlap1oz4QL/docs/9JOGOZ0e32gJ3m4Q</a></p>
</li>
</ol>
<h2><a id="%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目结构</h2>
<pre><code class="language-plain_text">┌── config                  # webpack 启动/打包执行脚本
├── src                     # 源代码主要目录
│    ├── application         # 程序启动载入处理逻辑
│    ├── assets              # 可打包资源文件
│    │    ├── images              # 图片资源
│    │    ├── styles              # 样式资源
│    ├── common                 # common
│    │    ├── const               # 公共常量
│    │    ├── hooks               # 自定义钩子
│    │    └── utils              # 工具类
│    ├── components           # 项目中公共组件
│    ├── models               # 项目中模型实体定义
│    ├── pages                   # 项目文件总目录
│    │    ├── admin               # 模板示例项目
│    │    ├── construction          # 渣土精细化项目
│    │    └── xxx...                 # 后续其它项目放这里
│    │    └── index.js            # 多应用打包配置文件
│    ├── services             # 项目中公共的service类
│    ├── settings             # 项目中公共配置
│    ├── store                  # store
│    │    └── modules                  # 按模块使用
│    ├── types                  # d 文件定义
│    ├── views                  # 公共视图，如login、404之类
│
├── node_modules            # 依赖
├── public                  # 静态文件
│    ├── index.html          # 程序启动载入处理逻辑
│    └── favicon.ico          # 程序图标
├── dist                    # 打包文件目录
│    ├── construction        # 打包文件
│    └── construction.zip      # 打包文件压缩包
├── .eslintrc.js           # eslint配置
├── .gitignore            # git 忽略提交配置
├── .stylelintrc.json     # stylelint 配置
├── babel.config.js           # babel 配置
├── dll.config.js         # dll 插件配置
├── package.json              # package info
├── page.config.js        # 页面、应用配置
├── postcss.config.js       # postcss 配置
├── tsconfig.json          # typescript 配置
└── vue.config.js           # vue.config 配置(很重要)
</code></pre>
<h2><a id="%E5%8D%95%E5%BA%94%E7%94%A8%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单应用结构</h2>
<p>以渣土精细化项目举例：</p>
<pre><code class="language-plain_text">┌── pages                   # 项目文件总目录
│    ├── construction        # 渣土精细化项目
│    │    ├── routes             # 路由配置
│    │    ├── settings            # 项目配置 会覆盖公共配置
│    │    ├── views               # 所有页面
│    │    ├── main.ts                # 应用入口启动文件
└─────── index.js           # 多应用打包配置文件
</code></pre>
<p>如果要新建一个项目，只需要按照上面结构创建这些目录，并且修改index.js文件。index.js内容如下，只需要仿照新增一个对象即可。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206030756588.png" alt="01" /></p>
<h2><a id="%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装使用</h2>
<p>首先安装 Vue 官方提供的工具 <a href="https://github.com/vuejs/vue-cli">vue-cli</a></p>
<pre><code class="language-bash">npm install -g @vue/cli

# 建议环境

npm 版本为 6.14.15
node 版本为 14.18.2
@vue/cli 版本为 4.5.16

</code></pre>
<ol>
<li>项目按公司要求统一使用的 ant design 组件库</li>
<li>按照公司 ui 规范写了一套样式风格，diy 开头具体在 <code>_ant.scss</code> 文件中查看每个组件的样式名称，需要添加到自己的样式中，比如</li>
</ol>
<pre><code class="language-js">&lt;a-input class=&quot;diy-input&quot; /&gt;
</code></pre>
<p>如果项目依赖如 <code>axios</code>、<code>lodash</code> 等库，只需按照如下方式导入即可：</p>
<pre><code class="language-js">import axios from &quot;axios&quot;;
import lodash from &quot;lodash&quot;;
</code></pre>
<p>项目使用 stylelint 对样式进行检查，样式代码需要保持规范，建议开发过程中安装并开启 stylelint 插件：<br />
stylelint 配置文件<code>.stylelintrc.json</code>中配置内容有：<br />
<code>&quot;selector-max-id&quot;: 2</code>, // 限定选择器中 id 选择器个数为 2， 建议只用一个 id 选择器<br />
<code>&quot;max-nesting-depth&quot;: 5</code> // 选择器嵌套深度不能超过 5 层， 建议最多不超过 3 层<br />
<code>&quot;selector-max-compound-selectors&quot;: 5</code>, // 复合选择器数量限制为 5<br />
<code>order/properties-order: [...]</code> // 限定属性申明的顺序，大致顺序如下</p>
<ul>
<li>1、定位：<code>position</code> <code>z-index</code> <code>left</code> <code>right</code> <code>top</code> <code>bottom</code> <code>clip</code>等。</li>
<li>2、自身属性：<code>width</code> <code>height</code> <code>min-height</code> <code>max-height</code> <code>min-width</code> <code>max-width</code>等。</li>
<li>3、文字样式：<code>color</code> <code>font-size</code> <code>letter-spacing</code>, <code>color</code> <code>text-align</code>等。</li>
<li>4、背景：<code>background-image</code> <code>border</code>等。</li>
<li>5、文本属性: <code>text-align</code> <code>vertical-align</code> <code>text-wrap</code> <code>text-transform</code> <code>text-indent</code> <code>text-decoration</code> <code>letter-spacing</code> <code>word-spacing</code> <code>white-space</code> <code>text-overflow</code>等。</li>
<li>6、css3 相关属性：<code>content</code>、<code>box-shadow</code>、<code>animation</code>、<code>border-radius</code>、<code>transform</code>等</li>
</ul>
<p><em>插件会按规则自动调整某些 css 代码。例如：插件会自动按设定的属性顺序代码中书写的顺序</em></p>
<h2><a id="%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用命令</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>npm run serve 项目名</td>
<td>以开发模式启动项目</td>
<td>npm run serve construction</td>
</tr>
<tr>
<td>npm run build 项目名</td>
<td>生产打包</td>
<td>npm run build construction</td>
</tr>
<tr>
<td>npm run lint</td>
<td>使用 tslint验证源码</td>
<td>npm run lint</td>
</tr>
<tr>
<td>npm run dll</td>
<td>预打包核心依赖库</td>
<td>npm run dll</td>
</tr>
<tr>
<td>lint:css</td>
<td>使用 stylelint验证样式源码规范性</td>
<td>lint:css</td>
</tr>
<tr>
<td>lint:css-fix</td>
<td>使用 stylelint规范样式源码</td>
<td>lint:css-fix</td>
</tr>
</tbody>
</table>
<h2><a id="%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代理配置</h2>
<p>本框架是前后端分离的项目，可以代理到指定服务。配置在<code>vue.config.js</code>文件中，如下：</p>
<pre><code class="language-js">   devServer: {
        headers: {
            &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;
        },
        host: &quot;0.0.0.0&quot;,
        port: 8100,     // 端口号
        https: false,   // https:{type:Boolean}
        open: true,     // 配置自动启动浏览器
        hot: true,      // 热更新
        proxy: {
            &quot;/api&quot;: {
                target: &quot;http://localhost:8088&quot;,
                changeOrigin: true,
                ws: true,
                pathRewrite: {
                    &quot;^/api&quot;: &quot;/eUrbanMIS&quot;   // 将/api前缀替换为eUrbanMIS，以实际要连的服务为准
                }
            },
            &quot;/construction&quot;: {
                target: &quot;http://192.168.31.25:8088&quot;,  //若需要使用微服务则在proxy中增加微服务配置
                changeOrigin: true,
                ws: true,
                pathRewrite: {
                    &quot;^/construction&quot;: &quot;/construction&quot;
                }
            }
        }
   }
</code></pre>
<p>注意：proxy 中可以配置多个代理服务器，所以如果项目中使用到了微服务，开发调试阶段，可以增加微服务的代理配置。目前登录等接口走mis服务，项目接口走微服务的情况比较常见。</p>
<h2><a id="%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>效果展示</h2>
<p>以渣土精细化项目为例，截取其中几个页面：</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206030801157.png" alt="image-20220603080155127" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206030811891.png" alt="image-20220603081127230" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206030810165.png" alt="image-20220603081042337" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206030807793.png" alt="image-20220603080750016" /></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206030809856.png" alt="image-20220603080937866" /></p>
<h1><a id="%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>工作原理</h1>
<h2><a id="%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置文件</h2>
<p>原框架本来有2个配置文件，一个在 public/static 目录下，一个在 src/setting 目录下，由于我们要支持多应用所以我在此基础上又新增加了1个，放在 pages/项目目录下，各个配置文件的路径如下所示。</p>
<blockquote>
<p>备注：本文档并不会挨个解释各个配置项有什么作用，请大家自行查阅，基本都有注释。</p>
</blockquote>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031044066.png" alt="image-20220603104456399" /></p>
<p><strong>下面分别说明一下各个配置文件的功能：</strong></p>
<ol>
<li>
<p>public/static 下的配置文件</p>
<p>在 index.html 中以 script 脚本形式引入，主要用于现场可自行修改的配置。为什么要放在 public/static 目录下呢？因为public/static 下的文件编译打包后，不会压缩混淆，原来是什么样打包后还是什么样。非常方便现场自行修改相关配置。在程序运行过程中，它挂载在 window 对象上，可以通过 window.commonSetting 得到相关配置。</p>
</li>
<li>
<p>src/setting 下的配置文件</p>
<p>系统公共配置，另外在里边还要完成几个重要工作：整个项目所有配置项的合并、rem屏幕适配、部署路径及baseUrl解析等。</p>
</li>
<li>
<p>pages/项目 下的配置文件</p>
<p>用于项目独有配置，与其它项目进行区分。比如是否有独立首页等等。</p>
</li>
<li>
<p><strong>同名配置的覆盖顺序：用户配置(public/static/setting)  &gt;  项目配置(src/page/xxx项目/settings)  &gt;  公共配置(src/settings)。</strong></p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206150947803.png" alt="image-20220615094749440" /></p>
</li>
</ol>
<h2><a id="%E8%B7%AF%E7%94%B1%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>路由文件</h2>
<p>路由文件放在 pages/项目/routes 目录下，是整个项目的“灵魂”，没有它我们就什么也看不了。如下图所示，这里先给出一个结论，后面会给出具体解释。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031132972.png" alt="image-20220603113222982" /></p>
<p>框架中对路由对象，专门自定义了一个类型——RouteItem。如下所示，前面是类型，后面是具体的路由对象。</p>
<pre><code class="language-typescript">type RouteItem = {
    title?: string;
    meta: {
        icon?: string; // iconfont 图标
        title?: string; // title
        isMenuGroup?: boolean; // 是否为菜单中的父节点
        [key: string]: string | any;
    };
    children?: Array&lt;RouteItem&gt;;
} &amp; RouteConfig;

//首页
const home: RouteItem = {
    name: &quot;home&quot;,
    path: &quot;/home&quot;,
    meta: {
        icon: &quot;icon-home&quot;,
        title: &quot;首页&quot;,
        schemaId: &quot;construction:home&quot;
    },
    component: () =&gt; import(&quot;@/pages/construction/views/home&quot;)
};
</code></pre>
<p>关于路由配置文件，有一个细节要特别注意，下面举例来说明。我们先来对比一下框架内置的项目 admin 项目和渣土精细化项目 construction ，看看这两者的路由配置文件有什么不同？(我只截取了部分路由进行说明)</p>
<ol>
<li>
<p>admin 项目</p>
<pre><code class="language-typescript">import { RouteConfig } from &quot;vue-router&quot;;

type RouteItem = {
    title?: string;
    meta: {
        icon?: string; // iconfont 图标
        title?: string; // title
        isMenuGroup?: boolean; // 是否为菜单中的父节点
        [key: string]: string | any;
    };
    children?: Array&lt;RouteItem&gt;;
} &amp; RouteConfig;

const webpage: RouteItem = {
    name: &quot;webpage&quot;,
    path: &quot;/webpage&quot;,
    meta: {
        icon: &quot;icon-home&quot;,
        title: &quot;首页&quot;
    },
    redirect: &quot;/welcome&quot;,
    component: () =&gt; import(&quot;@/components/layout/main&quot;),
    children: [
        {
            name: &quot;welcome&quot;,
            path: &quot;/welcome&quot;,
            meta: {
                icon: &quot;icon-nav&quot;,
                title: &quot;主页&quot;,
                schemaId: &quot;webpage:index&quot;
            },
            component: () =&gt; import(&quot;@/components/layout/blank/index&quot;),
            redirect: &quot;/welcome/index&quot;,
            children: [
                {
                    name: &quot;welcome_index&quot;,
                    path: &quot;index&quot;,
                    meta: {
                        icon: &quot;icon-nav&quot;,
                        title: &quot;主页&quot;,
                        schemaId: &quot;webpage:index&quot;
                    },
                    component: () =&gt; import(&quot;@/pages/admin/views/welcome&quot;)
                }
            ]
        }
    ]
};

const design: RouteItem = {
    name: &quot;design&quot;,
    path: &quot;/design&quot;,
    meta: {
        icon: &quot;icon-design&quot;,
        title: &quot;设计规范&quot;,
        schemaId: &quot;design&quot;
    },
    component: () =&gt; import(&quot;@/components/layout/main&quot;),
    redirect: &quot;/design/layout&quot;,
    children: [
        {
            name: &quot;design_layout&quot;,
            path: &quot;layout&quot;,
            meta: {
                icon: &quot;icon-folder&quot;,
                title: &quot;布局&quot;,
                schemaId: &quot;design:layout&quot;,
                isMenuGroup: true
            },
            component: () =&gt; import(&quot;@/components/layout/blank/index&quot;),
            redirect: &quot;/design/layout/panel&quot;,
            children: [
                {
                    name: &quot;design_layout_panel&quot;,
                    path: &quot;panel&quot;,
                    meta: {
                        icon: &quot;icon-nav&quot;,
                        title: &quot;查询页面&quot;,
                        schemaId: &quot;design:layout&quot;,
                        isMenuGroup: true
                    },
                    component: () =&gt; import(&quot;@/pages/admin/views/design/layout/panel&quot;)
                },
                {
                    name: &quot;design_layout_panal&quot;,
                    path: &quot;panal&quot;,
                    meta: {
                        icon: &quot;icon-nav&quot;,
                        title: &quot;详情页面&quot;,
                        schemaId: &quot;design:layout&quot;,
                        isMenuGroup: true
                    },
                    component: () =&gt; import(&quot;@/pages/admin/views/design/layout/panal&quot;)
                }
            ]
        }
    ]
};

export const appRouter = {
    name: &quot;app&quot;,
    path: &quot;/&quot;,
    redirect: &quot;/webpage&quot;,
    meta: {},
    component: () =&gt; import(&quot;@/components/layout&quot;),
    children: [webpage, design]  // 前面定义的2个 RouteItem 对象放到了这里。
};

export const routes = [
    appRouter,   // 前面定义的 appRouter 对象放到了这里，最终框架构建路由系统用的就是这个 routes 对象
    {
        name: &quot;login&quot;,
        path: &quot;/login&quot;,
        title: &quot;登录&quot;,
        component: () =&gt; import(&quot;@/views/login/index&quot;)
    },
    {
        name: &quot;401&quot;,
        path: &quot;/401&quot;,
        component: () =&gt; import(&quot;@/views/errors/401&quot;)
    },
    {
        name: &quot;404&quot;,
        path: &quot;/*&quot;,
        component: () =&gt; import(&quot;@/views/errors/404&quot;)
    }
];
</code></pre>
</li>
<li>
<p>construction 项目</p>
<pre><code class="language-typescript">import { RouteConfig } from &quot;vue-router&quot;;
import { ImagePreview, OfficePreview } from &quot;@magic/design-web&quot;;

type RouteItem = {
    title?: string;
    meta: {
        icon?: string; // iconfont 图标
        title?: string; // title
        isMenuGroup?: boolean; // 是否为菜单中的父节点
        [key: string]: string | any;
    };
    children?: Array&lt;RouteItem&gt;;
} &amp; RouteConfig;

//首页
const home: RouteItem = {
    name: &quot;home&quot;,
    path: &quot;/home&quot;,
    meta: {
        icon: &quot;icon-home&quot;,
        title: &quot;首页&quot;,
        schemaId: &quot;construction:home&quot;
    },
    component: () =&gt; import(&quot;@/pages/construction/views/home&quot;)
};

//-----------------------------------不同点1：这里定义的是 RouteItem 数组------------------------------
//违规管理
const violationManage: RouteItem[] = [
    {
        name: &quot;video-monitor&quot;,
        path: &quot;/videomonitor&quot;,
        meta: {
            icon: &quot;icon-videobind&quot;,
            title: &quot;视频监控&quot;,
            schemaId: &quot;construction:video-monitor&quot;
        },
        component: () =&gt; import(&quot;@/pages/construction/views/violation/videomonitor&quot;)
    },
    {
        name: &quot;violation-discover&quot;,
        path: &quot;/discover&quot;,
        meta: {
            icon: &quot;icon-violation-discover&quot;,
            title: &quot;违规发现&quot;,
            schemaId: &quot;construction:violation-discover&quot;
        },
        component: () =&gt; import(&quot;@/components/layout/main&quot;),
        redirect: &quot;/discover/vehiclealarm&quot;,
        children: [
            {
                name: &quot;violation-livelaw&quot;,
                path: &quot;livelaw&quot;,
                meta: {
                    icon: &quot;icon-violation-livelaw&quot;,
                    title: &quot;现场执法&quot;,
                    schemaId: &quot;construction:violation-livelaw&quot;
                },
                component: () =&gt; import(&quot;@/pages/construction/views/violation/livelaw&quot;)
            }
        ]
    }
];

//土方量管理
const earthManage: RouteItem[] = [
    {
        name: &quot;earth-work&quot;,
        path: &quot;/earth&quot;,
        meta: {
            icon: &quot;icon-design&quot;,
            title: &quot;土方量&quot;,
            schemaId: &quot;construction:earth-work&quot;
        },
        component: () =&gt; import(&quot;@/components/layout/main&quot;),
        redirect: &quot;/earth/accept&quot;,
        children: [
            {
                name: &quot;earth-ticket&quot;,
                path: &quot;ticket&quot;,
                meta: {
                    icon: &quot;icon-nav&quot;,
                    title: &quot;准运票记录&quot;,
                    schemaId: &quot;construction:earth-ticket&quot;
                },
                component: () =&gt; import(&quot;@/pages/construction/views/earth/ticket&quot;)
            }
        ]
    }
];

//后台管理(各种配置相关的模块)
const backendManage: RouteItem[] = [
    {
        name: &quot;docking&quot;,
        path: &quot;/docking&quot;,
        meta: {
            icon: &quot;icon-docking&quot;,
            title: &quot;对接配置&quot;,
            schemaId: &quot;construction:docking&quot;
        },
        component: () =&gt; import(&quot;@/components/layout/main&quot;),
        redirect: &quot;/docking/videobind&quot;,
        children: [
            {
                name: &quot;videobind&quot;,
                path: &quot;videobind&quot;,
                meta: {
                    icon: &quot;icon-videobind&quot;,
                    title: &quot;视频监控绑定&quot;,
                    schemaId: &quot;construction:videobind&quot;
                },
                component: () =&gt; import(&quot;@/pages/construction/views/backend/docking/videobind&quot;)
            }
        ]
    }
];

export const appRouter = {
    name: &quot;app&quot;,
    path: &quot;/&quot;,
    redirect: &quot;/home&quot;,
    meta: {},
    component: () =&gt; import(&quot;@/components/layout&quot;),
    children: [home, ...violationManage, ...earthManage, ...backendManage]  // 不同点2，这里通过 ... 展开数组
};

export const routes = [
    appRouter,
    {
        name: &quot;login&quot;,
        path: &quot;/login&quot;,
        title: &quot;登录&quot;,
        component: () =&gt; import(&quot;@/views/mislogin/index&quot;)
    },
    {
        name: &quot;401&quot;,
        path: &quot;/401&quot;,
        component: () =&gt; import(&quot;@/views/errors/401&quot;)
    },
    {
        name: &quot;404&quot;,
        path: &quot;/*&quot;,
        component: () =&gt; import(&quot;@/views/errors/404&quot;)
    }
];
</code></pre>
</li>
</ol>
<p>通过对比，我们可以看到 admin 项目中，定义的是一个个 RouteItem对象， 而渣土精细化项目我定义的是 RouteItem 数组。为什么要这么做呢？我们再对比一下 admin 和 construction 的页面结构。前者我称它为&quot;单模块系统&quot;，后者我称它为&quot;多模块系统&quot;。回到路由配置文件，也就是说像&quot;违规管理&quot;、&quot;土方量管理&quot;、这样的大模块导航，我们没有放到 appRouter 中，当然如果非要放进去也不是完全不可以，但是就需要修改中台框架中原来的很多代码，本着尽量少改动的原则，所以 construction 中采用的是解构 RouteItem[] 的方式。现在再回顾一下开头的结论：简单的单模块系统参考 admin 的路由配置，复杂的多模块系统参考 construction 的路由配置。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031141688.png" alt="image-20220603114154498" /></p>
<h2><a id="%E7%99%BB%E5%BD%95%E9%80%BB%E8%BE%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>登录逻辑</h2>
<p>本文档主要写给城市应用管理部门的同事参考，所以这里的登录主要讨论 mislogin 模块的登录。当然，原框架中还保留原来的 login 模块，它使用的是统一用户中心的登录逻辑，将来如果公司统一切换为统一用户中心登录，我可以很快速的切换回去，并不需要修改太多代码。</p>
<h3><a id="%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>登录流程</h3>
<p>下面是正常登录流程，即在用户登录界面，输入用户名、密码，点击&quot;登录&quot;按钮后执行的逻辑。登录流程参考下图，具体代码位于：<code>src/views/mislogin/index.ts</code>中。之所以这里说正常的登录流程，是因为本框架还支持第三方登录，可以绕过登录界面，直接通过 token 验证完成登录逻辑，后面讲路由跳转工作流程时会谈到。</p>
<img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031334678.png" alt="未命名表单" style="zoom:50%;" />
<h3><a id="%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>核心代码</h3>
<pre><code class="language-typescript">public async login() {
        if (this.logging) {
            return;
        }
        this.logging = true;
        try {
            const browserVersion = WinowUtil.getBrowserInfo();
            const osVersion = WinowUtil.getOSVersion();
            const params = {
                u: this.aesTool.encrypt(this.username),
                p: this.aesTool.encrypt(this.password),
                ip: null,
                browserVersion: decodeURI(browserVersion),
                osVersion: decodeURI(osVersion),
                lock32R: &quot;&quot; //CA认证流程会用到这里暂时不管
            };
            // 调用mis登录接口
            const misLoginRes: any = await this.service.login(params);
            if (!misLoginRes.success) {
                this.loginError(misLoginRes);
                return;
            }
            // 调用mis获取token接口
            const misTokenRes: any = await this.service.getToken({
                username: this.username,
                password: Base64.stringify(Utf8.parse(this.password))
            });
            // 保存城管token后续会使用.
            Cookies.set(&quot;token&quot;, misTokenRes.token, { expires: 7 * 24 * 60 * 60 * 1000 });
            // 调用mis获取人员头像接口
            const misHumanPhotoRes: any = await this.service.getHumanPhoto();
            // 调用mis获取导航权限接口
            const misNavRes: any = await this.service.getHumanNavData({ sysName: commonSetting.sysName });
            // 如果启用了微服务则还需调用额外接口
            let misMSConfigRes: any;
            let msTokenRes: any;
            if (commonSetting.enableMicroServer) {
                // 调用mis获取微服务地址配置项的接口
                misMSConfigRes = await this.service.getMicroServiceUrl();
                // 调用微服务token交换接口
                msTokenRes = await this.service.getMicroServiceToken(misMSConfigRes.data.value, misTokenRes.token);
            }
            this.userInfo = this.buildUserInfo(
                misLoginRes,
                misTokenRes,
                misHumanPhotoRes,
                misNavRes,
                misMSConfigRes,
                msTokenRes
            );
            this.$store.commit(&quot;user/save&quot;, this.userInfo);
            this.$router.push({ path: &quot;/&quot; });
        } catch (error: any) {
            if (error?.response?.status === 401) {
                this.$message.error(error.response.data.error_description);
            } else {
                this.$message.error(&quot;调用服务异常&quot;);
            }
        } finally {
            this.logging = false;
        }
    }
</code></pre>
<h3><a id="%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据存储</h3>
<p>从登录流程图可以看到，在执行路由跳转逻辑之前，有一个数据存储的步骤。这个步骤非常重要，很多重要的信息都需要缓存起来，系统才能正常运行。如下所示，有些数据存储在Cookies中，有些数据存储在 SessonStorage 中。其中 loginFlag 、access_token 等标记非常重要，是系统判断登录与否的关键。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031354488.png" alt="image-20220603135405068" /></p>
<p>例如，下面这个方法用来判断是否已经登录：</p>
<pre><code class="language-typescript">/**
	* 判断是否有本地的 token 和 sso 的 token，只要有一个即可满足
  * @returns
  */    
public static hasToken(): boolean {
   let value = Cookies.get(&quot;access_token&quot;) || Cookies.get(&quot;token&quot;) || &quot;&quot;;
   return value.length &gt; 0;
}    
</code></pre>
<h2><a id="%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>路由跳转</h2>
<p>路由跳转分2种情况，一种是执行完登录流程后跳转，会跳转到路由配置文件里配置的默认页面；二是刷新页面后跳转，会停留在原来的页面。当项目启动后，首先会执行 workbench.ts 里的 onOpen 方法。其中第一个步骤就是初始化路由程序。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031405863.png" alt="image-20220603140547214" /></p>
<p>进入 initializeRouter  内部，里边有一个非常重要的钩子函数，router.beforeEach()，所有的路由跳转都会经过这里，从而使得我们可以在里边完成权限控制、token 登录、刷新配置信息等重要功能。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031410850.png" alt="image-20220603140958625" /></p>
<p>router.beforeEach() 代码如下，重点是 this.toPage()。</p>
<blockquote>
<p>扩展思考：如果我们只是写个Demo，不需要权限控制等等，是不是可以注释掉 this.toPage() 这一行，然后直接 next() 放行呢？</p>
</blockquote>
<pre><code class="language-typescript"> router.beforeEach(async (to: any, from: any, next: any) =&gt; {
      let title = to.meta?.title || to.title;
      if (isNil(title) || title === &quot;&quot;) {
          title = commonSetting.appTitle;
      } else {
          title = ```{title} - ``{commonSetting.appTitle}`;
      }
      window.document.title = title;

      await this.toPage(context, to, from, next);
});


// 下面是 toPage 具体代码，我删除了一些细枝末节，不影响阅读。
private async toPage(context: any, to: any, from: any, next: any) {
        // 1.如果是登录页面，先清除之前登录的标记，再进入登录页面跳转流程
        if (to.name === &quot;login&quot;) {
            // 清除之前登录的标记
            LoginUtil.clearLoginFlag();
            // 进入登录页面跳转流程
            LoginUtil.gotoLogin(to, next);
            return;
        }

        // 处理第三方登录逻辑
        if (CommonUtil.containStr(window.location.href, [&quot;third=&quot;, &quot;token=&quot;], &quot;all&quot;)) {
            LoginUtil.processThirdLogin();
        }

        // 2. 判断是否已登陆，若未登录，则进入登录页面跳转流程
        if (!LoginUtil.hasToken()) {
            let enable = await getSSOEnable();
            if (enable) {
              	.......
            } else {
                // 进入登录页面跳转流程
                LoginUtil.gotoLogin(to, next);  
                return;
            }
        }

        // 3.加载用户相关数据(此处 token 肯定存在)
        // await LoginUtil.loadUserData(context.store); // 统一用户中心使用
        await LoginUtil.loadUserInfo(context.store); // mis服务使用

        // 4. 如果上一步失败，则把 token 作废并跳转至登录页面
        if (!LoginUtil.isLogin()) {
            await LoginUtil.revokeToken();
            LoginUtil.gotoLogin(to, next);
            return;
        }

        // 5. 判断权限
        const appRouter = context.routerOptions.routes?.find((r: any) =&gt; r.name === &quot;app&quot;);
        PermissionUtil.handePermissionBeforeEach([appRouter], to, from, next);
    }
</code></pre>
<p>toPage() 中我修改了2处地方，一是增加了处理第三方登录的逻辑，二是重写了加载用户数据的方法。具体逻辑全部放在 login-util.ts 中，如下所示，注释写得非常清楚，这里就不再展开。需要特别说明一下的是：如果从其它系统嵌入我们的页面，url 中必须携带2个参数，third=true&amp;token=xxxxx。之所以多要了一个 third=true，是为了避免本系统内部跳转时，由于某种原因多了一个 token 参数，让系统误以为是第三方登录，而其实并不是。</p>
<pre><code class="language-typescript"> // 处理第三方登录逻辑
if (CommonUtil.containStr(window.location.href, [&quot;third=&quot;, &quot;token=&quot;], &quot;all&quot;)) {
   LoginUtil.processThirdLogin();
} 
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031417234.png" alt="image-20220603141757065" /></p>
<pre><code class="language-typescript">// 3.加载用户相关数据(此处 token 肯定存在) 
await LoginUtil.loadUserInfo(context.store); // mis服务使用        
</code></pre>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031419880.png" alt="image-20220603141948390" /></p>
<p>下图是模拟第三方登录场景，在浏览器地址栏直接输入url【需携带token参数】，就可以不用输入用户名、密码，直接绕过登录环节进入系统内部。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206021816606.gif" alt="1654164195748097" /></p>
<h2><a id="%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>权限控制</h2>
<p>权限控制这块仍然沿用原框架的逻辑，我没有做太多修改。需要注意的是，权限控制这块实际上是有两层控制，第一层权限控制是后台控制，是 mis 岗位权限设置，第二层控制是前端控制，是在路由配置文件中进行控制。框架中有一个专门的 permission-util.ts 工具类。其中最核心的2个方法是：handePermissionBeforeEach、getPermissions。前者与 workbench.ts 遥相呼应，是在 router.beforeEach() 的回调函数中调用，后者是获取用户具体具备哪些导航权限。</p>
<pre><code class="language-typescript">//------------------------------------------workbench.ts----------------------------------------
// 5. 判断权限
const appRouter = context.routerOptions.routes?.find((r: any) =&gt; r.name === &quot;app&quot;);
PermissionUtil.handePermissionBeforeEach([appRouter], to, from, next);


//------------------------------------------permission-util.ts----------------------------------
public static handePermissionBeforeEach(routes: Array&lt;any&gt;, to: any, from: any, next: any) {
    // 如果账号为admin或者进入的菜单schemaId为空（即不需要进行权限控制）直接放行
    if (Cookies.get(&quot;username&quot;) === &quot;admin&quot; || !(to.meta &amp;&amp; to.meta.schemaId)) {
        next();
        return;
    }
    //重要!!! 获取用户具有的权限。
    const permissions = this.getPermissions();
    if (permissions.has(to.meta.schemaId)) {
        // 如果有权限
        next();
        return;
    } else if (from.path === &quot;/&quot; || from.path === &quot;/401&quot; || from.path === &quot;/login&quot;) {
        // 如果没有即将进入的页面的权限，先进行判断，如果是刚进入 是从/ 路径重定向进入第一个默认页面，而第一个页面刚好没有权限
        // 这时候如果直接重定向到401页面体验会很差，所以这里处理是 如果从 /路径重定向到第一个默认页面，刚好第一个默认页面没有权限，
        // 这个时候去找该用户第一个有权限的页面并进入该页面
        // 如果用户一个权限也没有那么才会进入401,
        // 如果不是从/重定向过来的 如果没有权限 则直接进入401·
        let page = PermissionUtil.getFirstAuthPage(permissions, routes);
        next({ replace: true, name: page });
    } else if ( new Set((routes[0].children || []).map((v: any) =&gt; v.name)).has(to.matched.length &gt; 1 &amp;&amp; 		to.matched[1].name ) &amp;&amp; !this.isSameModel(from, to)) {
        // 前往不同的模块
        const name = to.matched.length &gt; 1 &amp;&amp; to.matched[1].name;
        const route = (routes[0].children || []).filter((v: any) =&gt; v.name === name);
        let page = PermissionUtil.findFirstAuthPage(route);
        next({
            replace: true,
            name: page
        });
    } else {
        next({
            replace: true,
            name: &quot;401&quot;
        });
    }
}


//获取用户具有的导航权限
public static getPermissions(): Set&lt;string&gt; {
    const userInfo: any = JSON.parse(sessionStorage.getItem(&quot;user&quot;) as string);
    if (!userInfo) return new Set([]);
    const { user, applicationPermissions } = userInfo;
    if (!this.permisstionsMap.has(user.id)) {
        let permissionList: Array&lt;string&gt; = [];
        for (const i of applicationPermissions || []) {
            if (!commonSetting.applicationCode || i.application?.code === commonSetting.applicationCode) {
                let appCode = i.application?.code || &quot;&quot;; // appCode 如：construction
                if (!i.resourceMenus) {
                    i.resourceMenus = [];
                }
                // permission 的格式如：construction:violation，冒号前是 appCode，冒号后实际上是 navItemName
                permissionList = permissionList.concat(i.resourceMenus.map((v: any) =&gt; ```{appCode}:``{v.code}`));
            }
        }
        this.permisstionsMap.set(user.id, new Set(permissionList));
    }
    return this.permisstionsMap.get(user.id) as Set&lt;string&gt;;
}
</code></pre>
<p>下面是 permisson 的直观展示，permission的格式如：construction:violation，冒号前是 appCode，冒号后实际上是 navItemName。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206031502120.png" alt="image-20220603150247411" /></p>
<p>同时它在路由配置文件里还有一个名称——schemaId，所以说路由配置文件是前端进行权限控制的地方。如果 schemaId 故意设置错误，就可以屏蔽用户查看此模块的权限。</p>
<pre><code class="language-js">{
   name: &quot;video-monitor&quot;,
   path: &quot;/videomonitor&quot;,
   meta: {
     icon: &quot;icon-videobind&quot;,
     title: &quot;视频监控&quot;,
     schemaId: &quot;construction:video-monitor&quot;
   },
  component: () =&gt; import(&quot;@/pages/construction/views/violation/videomonitor&quot;)
},
</code></pre>
<h2><a id="%E8%A7%86%E5%9B%BE%E9%AA%A8%E6%9E%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>视图骨架</h2>
<h3><a id="%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码结构</h3>
<p>视图骨架相关的代码全部在：src/components/layout 下。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206062046385.png" alt="image-20220606204616719" /></p>
<ul>
<li>layout/index：最外层的 router-view</li>
<li>layout/main/index：中间层的 router-view</li>
<li>layout/blank/index：最内层的 router-view</li>
</ul>
<pre><code class="language-html">&lt;!-- layout/index --&gt;
&lt;!DOCTYPE html&gt;
&lt;div class=&quot;v-layout-wrapper&quot;&gt;
    &lt;u-header v-if=&quot;!hideHeader&quot;&gt;&lt;/u-header&gt;  &lt;!--这里还用到了一个公共组件 header --&gt;
    &lt;section class=&quot;u-body&quot;&gt;
        &lt;router-view&gt;&lt;/router-view&gt;     &lt;!-- router-view --&gt;
    &lt;/section&gt;
&lt;/div&gt;

&lt;!-- --------------------------------------------------------------------------------------- --&gt;
&lt;!-- layout/main/index --&gt;
&lt;section class=&quot;v-main-wrapper&quot;&gt;
    &lt;aside v-if=&quot;!hideSideMenu&quot; class=&quot;u-aside&quot;&gt;  &lt;!-- 侧边栏 --&gt;
        &lt;u-menu :menu-list=&quot;menuList&quot; /&gt;
    &lt;/aside&gt;
    &lt;main class=&quot;u-main&quot; :style=&quot;hideSideMenu? 'padding: 0':''&quot;&gt;
        &lt;section class=&quot;u-breadcrumb&quot;&gt;
            &lt;span&gt;当前位置：&lt;/span&gt;
            &lt;a-breadcrumb&gt;  &lt;!-- 面包屑 --&gt;
                &lt;a-breadcrumb-item v-for=&quot;(item, index) in breadCrumbList&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/a-breadcrumb-item&gt;
            &lt;/a-breadcrumb&gt;
        &lt;/section&gt;
        &lt;section class=&quot;u-page&quot;&gt;
            &lt;keep-alive&gt;
                &lt;router-view&gt;&lt;/router-view&gt;   &lt;!-- router-view --&gt;
            &lt;/keep-alive&gt;
        &lt;/section&gt;
    &lt;/main&gt;
&lt;/section&gt;


&lt;!-- --------------------------------------------------------------------------------------- --&gt;
&lt;!-- layout/blank/index --&gt;
&lt;section class=&quot;v-blank-wrapper&quot;&gt;
    &lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;
        &lt;keep-alive :include=&quot;cachePageList&quot;&gt;
            &lt;router-view&gt;&lt;/router-view&gt;   &lt;!-- router-view --&gt;
        &lt;/keep-alive&gt;
    &lt;/transition&gt;
&lt;/section&gt;
</code></pre>
<p>细心的同学可能发现为啥中间层的 router-view 和 最内层的 router-view 重叠了？实际上我也有此疑问。难不成仅仅是为了使用 transition？不过既然人家提供的框架是这样，我们也不必过于在意。</p>
<h3><a id="%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>路由配置</h3>
<p>下面结合路由配置文件（ pages/项目/routes/index.js）来看，视图骨架是如何使用的？</p>
<ol>
<li>
<p>不管是没有独立首页的 admin 还是有独立首页的 construction，<strong>根视图</strong>都配置的 <code>@/components/layout</code>。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206062011908.png" alt="image-20220606201108480" /></p>
</li>
<li>
<p>如&quot;违规发现&quot;这样<strong>有children的顶部导航</strong>，配置的是：<code>@/components/layout/main</code></p>
<p>如&quot;报警处置&quot;这样<strong>有children的侧边栏导航</strong>，配置的是：<code>@/components/layout/blank</code></p>
<p>如&quot;待处置&quot;这样<strong>没有children的具体导航</strong>，配置的是：<code>@/pages/xxxx</code>具体路径。</p>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206062114018.png" alt="202206062040716" /></p>
</li>
</ol>
<h2><a id="%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>网络请求</h2>
<h3><a id="service%E5%85%B3%E7%B3%BB%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>service关系图</h3>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206080745795.png" alt="servcie关系图" /></p>
<h3><a id="axiosservice-base-ts" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>axios/service-base.ts</h3>
<ol>
<li>底层使用 axios 库作为请求框架，在 service-base.ts 中做了一层封装。</li>
<li>在 service-base.ts 中创建 axios 的实例对象，拦截器，以及封装了一些基本的请求方法（get, post 等等）。</li>
<li>axios 的拦截器中做了很多工作，包括动态拼接 baseUrl、拼接 headers、token、签名鉴权等等。需要注意的是，目前 service-base.ts 存在2个拦截器，一个是 axios 全局拦截器，用于拦截诸如玲珑等我们触碰不到的请求。另一个是 Axios 实例拦截器，用于处理项目内自己发送的请求。</li>
</ol>
<pre><code class="language-js">// 全局过滤器(用于拦截我们触摸不到的JS库中发出的axios请求)
axios.interceptors.request.use(
    (config: AxiosRequestConfig) =&gt; {
        // 拼接baseUrl
        if (config.url &amp;&amp; !ServiceUtil.isAbsoluteURL(config.url)) {
            let baseUrl = ServiceUtil.getBaseUrl(config.url);
            config.url = ServiceUtil.combineUrl(config.url, baseUrl);
        }

        // 添加mis的token
        const token = Cookies.get(&quot;token&quot;);
        config.headers.Authorization = &quot;cas csgl-wh:&quot; + token; //部门服务

        return config;
    },
    (error) =&gt; {
        console.error(error);
        return Promise.reject(error);
    }
);

const globalSource: CancelTokenSource = axios.CancelToken.source();

// Axios 实例
const instance = axios.create({
    // baseURL: commonSetting.baseUrl, //在拦截器中配置，这里只能写死，我们需要动态获取
    timeout: 10000,
    cancelToken: globalSource.token,
    validateStatus: (status: number) =&gt; {
        // token 失效
        if (status === 401) {
            Cookies.remove(&quot;access_token&quot;);
            window.location.replace(`${commonSetting.basePath}#/login`);
        }

        return status &gt;= 200 &amp;&amp; status &lt; 300;
    }
});

// Axios 实例拦截器
instance.interceptors.request.use(
    (config: AxiosRequestConfig) =&gt; {
        // 拼接baseUrl
        if (config.url &amp;&amp; !ServiceUtil.isAbsoluteURL(config.url)) {
            let baseUrl = ServiceUtil.getBaseUrl(config.url);
            config.url = ServiceUtil.combineUrl(config.url, baseUrl);
        }

        // mis的token
        const token = Cookies.get(&quot;token&quot;);
        if (token) {
            if (config.method === &quot;get&quot;) {
                config.params = config.params || {};
                config.params.token = token;
            } else if (config.method === &quot;post&quot;) {
                config.data = config.data ? ```{config.data}&amp;token=``{token}` : `token=${token}`;
            }
        }

        // 处理签名鉴权
        if (commonSetting.enableSignature) {
            signatureConfig(config);
        }

        // 微服务的token
        if (commonSetting.enableMicroServer) {
            const access_token = Cookies.get(&quot;access_token&quot;);
            if (access_token) {
                config.headers.Authorization = &quot;Bearer &quot; + access_token;
            }
        }

        return config;
    },
    (error) =&gt; {
        console.error(error);
        return Promise.reject(error);
    }
);



//---------------------------------封装基本请求方法-----------------------------------------
/**
     * 发送post请求
     * @param url 请求地址
     * @param data 发送的参数
     */
    protected _post&lt;T&gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&lt;T&gt; {
        return instance.post(url, qs.stringify(data), config).then((res) =&gt; res.data);
    }

    /**
     * 发送get请求
     * @param url 请求地址
     */
    protected _get&lt;T&gt;(url: string, params: any = {}, config: AxiosRequestConfig = {}): Promise&lt;T&gt; {
        return instance.get(url, { params, ...config }).then((res) =&gt; res.data);
    }
</code></pre>
<h3><a id="%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用举例</h3>
<ol>
<li>
<p>大多数组件目录都包含一个 service.ts，在 service.ts 中编写发送请求的代码；</p>
<pre><code class="language-js">import { service } from &quot;@egova/base-lib&quot;;
import { CommonService } from &quot;@/services&quot;;

export default class Service extends CommonService {
    @service(&quot;query&quot;, { title: &quot;获取所有视频监控类型&quot; })
    public async getMonitorTypeService(params: any): Promise&lt;any&gt; {
        return this._get(&quot;/unity/microconstruction/monitor/getmonitortypelist&quot;, params);
    }

    @service(&quot;save&quot;, { title: &quot;绑定设备&quot; })
    public async saveDeviceService(params: any): Promise&lt;any&gt; {
        return this._post(&quot;/unity/microconstruction/monitor/insertdevicelist&quot;, params);
    }
}
</code></pre>
</li>
<li>
<p>mis请求的一个特殊点。由于mis请求和微服务请求返回的数据结构不同，为了不改变 service-base 中原来的代码，我单独封装了一个 destruct()，用于处理mis的请求，注意对比下面2个请求的写法。</p>
<pre><code class="language-js">import ServiceBase from &quot;./service-base&quot;;

export default class LoginService extends ServiceBase {
    /**
     * 登录【mis请求】
     * @param params
     */
    public async login(params: any): Promise&lt;any&gt; {
        const res = await this._post(&quot;/login/validpassword&quot;, params); 
				//拿到结果先 destruct一下，然后再 return一个 promise 出去
        return Promise.resolve(this.destruct(res));  
    }


    /**
     * 获取微服务前缀【非mis请求】
     */
    public async getMicroServiceToken(microServiceUrl: string, token: string): Promise&lt;any&gt; {
        // 不需要像 mis 那么麻烦，直接 return 出去即可。
        return await this._get(this.combineUrl(&quot;/token/exchange&quot;, microServiceUrl), { token: token });
    }
}


//------------------------------service-base.ts 中 destruct()----------------------------------
 /**
     * 对响应结果进行解构
     * 城管后台接口返回格式相对固定，拿到返回数据后可以调用一下本方法，简化操作。
     * @param res
     * @protected
     */
    protected destruct(res: any): any {
        if (!res) {
            return res;
        }
        if (res.resultInfo) {
            return res.resultInfo;
        }
        if (res.data) {
            return res.data;
        }
        return res;
    }
</code></pre>
</li>
</ol>
<h2><a id="%E5%A4%9A%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多应用打包</h2>
<h3><a id="%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>执行命令</h3>
<p>npm run serve 项目名</p>
<p>npm run build 项目名</p>
<h3><a id="%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>工作流程图</h3>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206062001357.png" alt="多应用打包流程图" /></p>
<h3><a id="%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AF%A6%E7%BB%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>工作流程详细</h3>
<ol>
<li>pages/index.js 中配置对应项目，以对象形式体现。最重要的是指定入口文件 entry，如：<code>src/pages/admin/main.ts</code>。</li>
</ol>
<p><img src="https://yuanchaowhut.oss-cn-hangzhou.aliyuncs.com/images/202206061915037.png" alt="image-20220606191531214" /></p>
<ol start="2">
<li>
<p>pages/index.js 中export出去的是什么？</p>
<p>中台框架原来的代码 export 出去的就是 admin 这个对象，经过定制修改后，不再 export 固定对对象，而是根据执行的命令行参数动态获取。 例如执行 <code>npm run serve construction</code>  或 <code>npm run build construction </code>，解析得到的 entry 就是 construction，然后调用 getAppConfig() 得到的就是 construction 对应的js对象。</p>
<pre><code class="language-js">function getAppConfig(entry) {
    if (!entry || !appConfig[entry]) {
        return appConfig.default;
    }
    return appConfig[entry];
}

let entry = &quot;admin&quot;;
if (process.argv[3]) {
    if (process.argv[3].indexOf(&quot;/&quot;) &gt; 0) {
        const matches = process.argv[3].match(/^.+\/(\w+)\/main.ts$/);
        entry = matches[1];
    } else {
        entry = process.argv[3];
    }
}

//获取对应的app配置信息
const app = getAppConfig(entry);

module.exports = app;
</code></pre>
</li>
<li>
<p>page.config.js 中引入前面步骤中 export 出来的项目信息，并且动态计算项目名称 projectName，最后一起 export 出去。</p>
<pre><code class="language-js">const path = require(&quot;path&quot;);

function resolvePage(page) {
    let pagesConfig = require(path.resolve(&quot;./src/pages/index.js&quot;));  // 引入第2步export出的内容
    if (!page) return pagesConfig;
    let obj = {};
    obj[page] = pagesConfig[page];
    return obj;
}

let pages = resolvePage(process.env.page);
// 根据命令行参数计算项目名称 projectName。
let projectName = &quot;admin&quot;;
if (process.argv[3]) {
    if (process.argv[3].indexOf(&quot;/&quot;) &gt; 0) {
        const matches = process.argv[3].match(/^.+\/(\w+)\/main.ts$/);
        projectName = matches[1];
    } else {
        projectName = process.argv[3];
    }
}

//.............................一些逻辑............................
// 启动和打包脚本中会使用这里 export 出的内容。
module.exports = {
    pages: pages,
    plugin: plugin,
    projectName: projectName
};
</code></pre>
</li>
<li>
<p>执行 config/start.js 或 config/update.js 脚本</p>
<p>前面所有步骤都是为最后一步做铺垫，可以看到不管是 start.js 还是 update.js 中都要使用 page.config.js 中 export 出的东西。其实主要就是 pages 和 projectName 这两个数据。</p>
<pre><code class="language-js">// config/start.js
const cp = require(&quot;child_process&quot;);
const { pages } = require(&quot;../page.config&quot;);   // 引入项目配置

class Process {
	
}


// config/update.js
const cp = require(&quot;child_process&quot;);
const os = require(&quot;os&quot;);
const { promisify } = require(&quot;util&quot;);
const chalk = require(&quot;chalk&quot;);
const config = require(&quot;../vue.config&quot;);
const path = require(&quot;path&quot;);
const fs = require(&quot;fs&quot;);
const readdir = promisify(fs.readdir);
const compressing = require(&quot;compressing&quot;);
const { projectName } = require(&quot;../page.config&quot;);  // 引入项目配置

class Update {
  
}
</code></pre>
<p>以 start.js 为例， <code>npm run serve construction</code>  实际上会执行分支语句 <code>this.run_vue_cli()</code>。在方法内部会开启一个进程执行 <code>vue-cli-service</code>，即：<code>this.run_process(&quot;vue-cli-service&quot;, params)</code>  ，注意，这个脚本是 vue 内置的。this.entry 是什么？很显然，就是我们在 pages/index.js 中配置的项目入口文件 <code>src/pages/construction/main.ts</code>。 也就是说我们最后执行的命令相当于： <code>vue-cli-service src/pages/construction/main.ts</code>。</p>
<p><strong>总结：所谓多应用启动或多应用打包并没有多高大上，本质上就是入口文件不要写死，而是动态获取，只要你做到了根据命令行参数动态获取入口文件，那就是多应用。</strong></p>
<pre><code class="language-js">switch (command) {
            case &quot;serve&quot;:
                this.run_vue_cli();
                break;
            case &quot;build&quot;:
                this.run_vue_cli();
                this.run_update();
                break;
            case &quot;check&quot;:
                this.run_http_server();
                break;
        }

//-----------------------------------------------------------------------------
// params 举例：[ 'serve', 'src/pages/construction/main.ts' ]
run_vue_cli() {
        const params = this.entry ? [this.command, this.entry] : [this.command];
        this.webpack_process = this.run_process(&quot;vue-cli-service&quot;, params);
    }
</code></pre>
<ol start="5">
<li>
<p>最后我们看一下入口文件中到底做了什么？答案：启动应用程序。</p>
<blockquote>
<p>具体怎么启动需要研究 base-lib 包，不再本文档讨论范围，感兴趣的同学自行研究。</p>
</blockquote>
<pre><code class="language-js">import { routes } from &quot;./routes&quot;;
import modules from &quot;@/store&quot;;
import { Application } from &quot;@egova/base-lib&quot;;

import ApplicationContext from &quot;@/application/context&quot;;

// 获取应用上下文
let context = new ApplicationContext(routes, modules);

// 启动应用程序
Application.start(context);
</code></pre>
</li>
</ol>
</li>
</ol>
<h1><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h1>
<p>屈指算来，自部门推行Vue新框架以来差不多有两三个月了，在使用它处理现场需求的过程中，我们的框架也在逐步完善，可以看到很多实用的功能正在源源不断的加入进去，第三方登录啊，玲珑啊，多应用打包啊...，一切都是为了打造更好的产品，提升用户体验，增加部门乃至整个公司的前端产品的竞争力。然而毕竟时间尚短，加之我一个人精力有限，所以肯定还存在许多需要优化的地方，希望后期更多的小伙伴们加入进来，群策群力，让 urban-manage-vue 变得越来越完善，前端开发越来越轻松。最后，祝大家端午节快乐！</p>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
